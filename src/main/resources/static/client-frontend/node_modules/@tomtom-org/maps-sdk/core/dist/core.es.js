const e={commonBaseURL:"https://api.tomtom.com",apiKey:"",apiVersion:1},t=class{constructor(){this.config={...e}}put(e){this.config={...this.config,...e}}reset(){this.config={...e}}get(){return this.config}};t.instance=new t;let r=t;const n=(e={})=>({...r.instance.get(),...e}),a=["Public","Authorized","Restricted","Private","Unknown"],o=["Available","Reserved","Occupied","OutOfService","Unknown"],i=["ChargingProfileCapable","ChargingPreferencesCapable","ChipCardSupport","ContactlessCardSupport","CreditCardPayable","DebitCardPayable","PedTerminal","RemoteStartStopCapable","Reservable","RfidReader","StartSessionConnectorRequired","TokenGroupCapable","UnlockCapable","PlugAndCharge","Unknown"],s=["EvOnly","Plugged","Disabled","Customers","Motorcycles"],c=["StandardHouseholdCountrySpecific","IEC62196Type1","IEC62196Type1CCS","IEC62196Type2CableAttached","IEC62196Type2Outlet","IEC62196Type2CCS","IEC62196Type3","Chademo","GBT20234Part2","GBT20234Part3","IEC60309AC3PhaseRed","IEC60309AC1PhaseBlue","IEC60309DCWhite","Tesla"],u=["AC1","AC3","DC"],d=["Country","CountrySubdivision","CountrySecondarySubdivision","CountryTertiarySubdivision","Municipality","MunicipalitySubdivision","Neighbourhood","PostalCodeArea"],l=["POI","Street","Geography","Point Address","Address Range","Cross Street"],_=["Small_Paddle_Inductive","Large_Paddle_Inductive","IEC_60309_1_Phase","IEC_60309_3_Phase","IEC_62196_Type_1_Outlet","IEC_62196_Type_2_Outlet","IEC_62196_Type_3_Outlet","IEC_62196_Type_1_Connector_Cable_Attached","IEC_62196_Type_2_Connector_Cable_Attached","IEC_62196_Type_3_Connector_Cable_Attached","Combo_to_IEC_62196_Type_1_Base","Combo_to_IEC_62196_Type_2_Base","Type_E_French_Standard_CEE_7_5","Type_F_Schuko_CEE_7_4","Type_G_British_Standard_BS_1363","Type_J_Swiss_Standard_SEV_1011","China_GB_Part_2","China_GB_Part_3","IEC_309_DC_Plug","AVCON_Connector","Tesla_Connector","NEMA_5_20","CHAdeMO","SAE_J1772","TEPCO","Better_Place_Socket","Marechal_Socket","Standard_Household_Country_Specific"],p=["No_Payment","Subscription","Direct"],y=["tollRoads","motorways","ferries","unpavedRoads","carpools","alreadyUsedRoads","borderCrossings","tunnels","carTrains","lowEmissionZones"],C=["jam","accident","roadworks","road-closed","narrow-lanes","danger","animals-on-road","broken-down-vehicle","lane-closed","wind","fog","rain","frost","flooding","other"],h=["carTrain","ferry","tunnel","motorway","pedestrian","toll","tollVignette","country","vehicleRestricted","traffic","carpool","urban","unpaved","lowEmissionZone","speedLimit","roadShields","importantRoadStretch"],g=[...h,"lanes"],$=[...g,"leg"],m=["Unified","AR","IN","PK","IL","MA","RU","TR","CN"],f=e=>!!e&&(e.length>=4&&e[3]!==e[1]&&e[2]!==e[0]),S=e=>f(e)?e:void 0,b=(e,t)=>{if(e&&!(e.length<2))return t?[t[0]>e[0]?e[0]:t[0],t[1]>e[1]?e[1]:t[1],t[2]<e[0]?e[0]:t[2],t[3]<e[1]?e[1]:t[3]]:[e[0],e[1],e[0],e[1]]},E=(e,t)=>t&&e?[t[0]>e[0]?e[0]:t[0],t[1]>e[1]?e[1]:t[1],t[2]<e[2]?e[2]:t[2],t[3]<e[3]?e[3]:t[3]]:e||t,M=e=>e?.length?e.reduce((e,t)=>E(t,e)):void 0,P=e=>{const t=e?.length;if(!t)return;let r;const n=Math.ceil(t/1e3);for(let a=0;a<t;a+=n)r=b(e[a],r);return 1===n?r:b(e[t-1],r)},T=e=>{if(e){if(Array.isArray(e))return"number"==typeof e[0]?e.length>=4?e:void 0:M(e.map(e=>T(e)));if(e.bbox)return e.bbox;switch(e.type){case"Feature":return T(e.geometry);case"FeatureCollection":return M(e.features.map(T));case"GeometryCollection":return M(e.geometries.map(T));case"Point":return b(e.coordinates);case"LineString":case"MultiPoint":return P(e.coordinates);case"MultiLineString":case"Polygon":return M(e.coordinates.map(P));case"MultiPolygon":return M(e.coordinates.flatMap(e=>e.map(P)));default:return}}},A=(e,t)=>E(T(e),t),I=e=>[(e[0]+e[2])/2,(e[1]+e[3])/2],v=()=>Date.now().toString(36)+Math.random().toString(36).substring(2),w="MapsSDKJS",R=e=>{if(!/^[a-zA-Z0-9-]{1,100}$/.test(e))throw new TypeError(`a string matching regular expression ^[a-zA-Z0-9-]{1,100}$ is expected, but ${e} ['${typeof e}'] given`);return e},k=e=>({"TomTom-User-Agent":`${w}/0.34.0`,...e.trackingId&&{"Tracking-ID":R(e.trackingId)}}),O=(e,t)=>{if(e){if(Array.isArray(e))return e;if(e.coordinates)return e.coordinates;if(e.geometry){if("main-when-available"===t?.useEntryPoint){const t=(r=e,r?.properties?.entryPoints?.find(e=>"main"===e.type));return t?.position??e.geometry.coordinates}return e.geometry.coordinates}}var r;return null},B=(e,t)=>{const r=O(e,t);if(!r)throw new Error(`The received object does not have lng-lat coordinates: ${JSON.stringify(e)}`);return r},U=e=>({type:"Feature",geometry:{type:"Point",coordinates:e},properties:{}}),D=(e,t)=>{let r;return r=Array.isArray(e)||"Feature"!==e.type?U(B(e)):e,{...r,properties:{...r.properties,radiusMeters:t}}},N=e=>Array.isArray(e)?Array.isArray(e[0])?"path":"waypoint":"Feature"===e.type&&"LineString"===e.geometry.type?"path":"waypoint",G=["unknown","minor","moderate","major","indefinite"];const F=e=>e?.minutes??"min",L=(e,t)=>{if(e){const a=Math.abs(e)/3600;let o=Math.floor(a),i=Math.round(a%1*60);60===i&&(i=0,o++);const s={...r.instance.get().displayUnits?.time,...t};if(o)return`${o} ${n=s,n?.hours??"hr"} ${i.toString().padStart(2,"0")} ${F(s)}`;if(i)return`${i.toString()} ${F(s)}`}var n},x=1609.344,J=e=>e?.meters??"m",V=e=>e?.kilometers??"km",Z=(e,t,r)=>t<3?((e,t,r)=>{const n=Number.parseInt(t.toString()),a=t-n,o=e<0?"-":"";if(a<.125)return`${o}${n} ${r}`;const i=n>0?n:"";return a<.375?`${o}${i}¼ ${r}`:a<.625?`${o}${i}½ ${r}`:a<.875?`${o}${i}¾ ${r}`:`${o}${n+1} ${r}`})(e,t,r):t<10?((e,t,r)=>{const n=Number.parseInt(t.toString()),a=t-n,o=e<0?"-":"";return a<.25?`${o}${n} ${r}`:a<.75?`${o}${n}½ ${r}`:`${o}${n+1} ${r}`})(e,t,r):`${Math.round(e)} ${r}`,j=e=>e.miles??"mi",z=(e,t)=>{const r=e/x,n=Math.abs(r);return n<.125?((e,t)=>{const r=Math.round(e/.3048),n=Math.abs(r);return n<30?`${r} ${t}`:n<500?`${10*Math.round(r/10)} ${t}`:`${100*Math.round(r/100)} ${t}`})(e,t.feet??"ft"):Z(r,n,j(t))},H=(e,t)=>{const r=e/x,n=Math.abs(r);return n<.125?((e,t)=>{const r=Math.round(e/.9144);return Math.abs(r)<10?`${Math.round(r)} ${t}`:`${10*Math.round(r/10)} ${t}`})(e,t.yards??"yd"):Z(r,n,j(t))},K=(e,t)=>{if(null==e)return"";const n={...r.instance.get().displayUnits?.distance,...t};switch(n?.type??"metric"){case"metric":return((e,t)=>{const r=Math.abs(e);if(r<10)return`${e} ${J(t)}`;if(r<500)return`${10*Math.round(e/10)} ${J(t)}`;if(r<1e3){const r=100*Math.round(e/100);return 1e3===r||-1e3===r?`${e<0?"-":""}1 ${V(t)}`:`${r} ${J(t)}`}return r<1e4?`${100*Math.round(e/100)/1e3} ${V(t)}`:`${Math.round(e/1e3)} ${V(t)}`})(e,n);case"imperial_us":return z(e,n);case"imperial_uk":return H(e,n)}};export{w as TOMTOM_USER_AGENT_SDK_NAME,r as TomTomConfig,D as asSoftWaypoint,y as avoidableTypes,I as bboxCenter,E as bboxExpandedWithBBox,A as bboxExpandedWithGeoJSON,b as bboxExpandedWithPosition,M as bboxFromBBoxes,P as bboxFromCoordsArray,T as bboxFromGeoJSON,S as bboxOnlyIfWithArea,i as chargingPointCapabilities,s as chargingPointRestrictions,o as chargingPointStatus,a as chargingStationAccessTypes,c as connectorTypes,u as currentTypes,e as defaultConfig,K as formatDistance,L as formatDuration,v as generateId,k as generateTomTomHeaders,d as geographyTypes,O as getPosition,B as getPositionStrict,N as getRoutePlanningLocationType,G as indexedMagnitudes,h as inputSectionTypes,g as inputSectionTypesWithGuidance,f as isBBoxWithArea,n as mergeFromGlobal,p as paymentMethods,l as placeTypes,_ as plugTypes,$ as sectionTypes,U as toPointFeature,C as trafficCategories,m as views};
//# sourceMappingURL=core.es.js.map
