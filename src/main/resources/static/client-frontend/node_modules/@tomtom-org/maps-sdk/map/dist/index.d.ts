import { Anything } from '../../../../core';
import { BackgroundLayerSpecification } from 'maplibre-gl';
import { BBox } from 'geojson';
import { ChargingSpeed } from '../../../../core';
import { ChargingStop } from '../../../../core';
import { CircleLayerSpecification } from 'maplibre-gl';
import { CommonPlaceProps } from '../../../../core';
import { DataDrivenPropertyValueSpecification } from 'maplibre-gl';
import { DelayMagnitude } from '../../../../core';
import { DisplayUnits } from '../../../../core';
import { ExpressionFilterSpecification } from 'maplibre-gl';
import { ExpressionSpecification } from 'maplibre-gl';
import { Feature } from 'geojson';
import { FeatureCollection } from 'geojson';
import { GeoJSONSource } from 'maplibre-gl';
import { GeoJSONSourceSpecification } from 'maplibre-gl';
import { GetPositionEntryPointOption } from '../../../../core';
import { GlobalConfig } from '../../../../core';
import { Instruction } from '../../../../core';
import { Language } from '../../core';
import { LayerSpecification } from 'maplibre-gl';
import { LegacyFilterSpecification } from 'maplibre-gl';
import { LineLayerSpecification } from 'maplibre-gl';
import { LineString } from 'geojson';
import { LngLat } from 'maplibre-gl';
import { Map as Map_2 } from 'maplibre-gl';
import { MapGeoJSONFeature } from 'maplibre-gl';
import { MapOptions } from 'maplibre-gl';
import { Place } from '../../../../core';
import { Place as Place_2 } from '../../../core';
import { Places } from '../../../core';
import { Places as Places_2 } from '../../../../core';
import { POICategory } from '../../../core';
import { Point } from 'geojson';
import { PolygonFeatures } from '../../../core';
import { Route } from '../../../core';
import { RouteProps } from '../../../../core';
import { Routes } from 'core';
import { Routes as Routes_2 } from '../../../core';
import { SectionProps } from '../../../../core';
import { Source } from 'maplibre-gl';
import { SourceSpecification } from 'maplibre-gl';
import { StyleSpecification } from 'maplibre-gl';
import { SymbolLayerSpecification } from 'maplibre-gl';
import { TrafficSectionProps } from '../../../../core';
import { Waypoint } from '../../../core';
import { WaypointLike } from '../../../../core';
import { Waypoints } from 'core';
import { Waypoints as Waypoints_2 } from '../../../core';

/**
 * @ignore
 */
declare abstract class AbstractEventProxy {
    protected interactiveLayerIDs: string[];
    protected handlers: EventHandlers;
    /**
     * Adds the given layers as interactive, so we'll listen to them for hover and click.
     * @param sourceWithLayers The sources and layers to listen to.
     */
    private ensureInteractiveLayerIDsAdded;
    /**
     * Register an event listener to the list.
     * @param sourceWithLayers The sources and layers to added.
     * @param handlerFn Function that will handle the event.
     * @param type Type of event to listen to.
     */
    addEventHandler<T = MapGeoJSONFeature>(sourceWithLayers: SourceWithLayers, handlerFn: UserEventHandler<T>, type: EventType): void;
    /**
     * Removes the given sources and layers from the interactive list. When not present, nothing happens.
     * @param type The event type to be removed.
     * @param sourceWithLayers The sources and layers to remove, matched by source and layer IDs.
     */
    remove(sourceWithLayers: SourceWithLayers, type: EventType): void;
    /**
     * Removes all interactive sources and layers.
     */
    removeAll(): void;
    /**
     * Returns whether this source is registered for events (has handlers attached).
     * @param sourceId The source id (should be linked to a SourceWithLayers instance).
     */
    hasSourceID(sourceId: string): boolean;
    /**
     * Updates the given sourcesWithLayers, if they have any handlers.
     * * (This is typically called to refresh any registered, stale sourceWithLayers references after a map style has changed).
     * @param sourcesWithLayers The new sources with layers to replace existing ones.
     */
    updateIfRegistered(sourcesWithLayers: SourcesWithLayers): void;
    protected findHandlers: (types: EventType[], sourceId: string | undefined, layerId: string | undefined) => SourceEventTypeHandler[];
}

/**
 * Base class for all Maps SDK map modules.
 *
 * This abstract class provides the foundation for creating map modules that can display
 * and manage various types of data on a TomTom map. It handles module lifecycle management,
 * including initialization, configuration updates, and automatic restoration after map style changes.
 *
 * @remarks
 * All map modules extend this class to ensure consistent behavior across the SDK.
 * The class manages the module's sources, layers, and configuration, automatically
 * handling map style changes by restoring the module's state when needed.
 *
 * @typeParam SOURCES_WITH_LAYERS - The type defining the sources and layers used by this module
 * @typeParam CFG - The configuration type for this module, or undefined if no configuration is needed
 *
 * @example
 * ```typescript
 * class CustomModule extends AbstractMapModule<MySourcesWithLayers, MyConfig> {
 *   constructor(tomtomMap: TomTomMap, config?: MyConfig) {
 *     super('geojson', tomtomMap, config);
 *   }
 *   // Implement abstract methods...
 * }
 * ```
 *
 * @group Shared
 */
export declare abstract class AbstractMapModule<SOURCES_WITH_LAYERS extends SourcesWithLayers, CFG = undefined> {
    private readonly sourceType;
    /**
     * @ignore
     */
    protected readonly tomtomMap: TomTomMap;
    /**
     * @ignore
     */
    protected readonly eventsProxy: EventsProxy;
    /**
     * @ignore
     */
    protected readonly mapLibreMap: Map_2;
    /**
     * @ignore
     */
    protected sourcesWithLayers: SOURCES_WITH_LAYERS;
    /**
     * @ignore
     */
    protected _sourceAndLayerIDs: Record<keyof SOURCES_WITH_LAYERS, SourceWithLayerIDs>;
    /**
     * @ignore
     */
    protected config?: CFG;
    /**
     * @ignore
     */
    protected _initializing: boolean;
    /**
     * Indicates that this module is currently adding its sources and layers to the map, so during this time it might not function properly.
     * @see waitUntilModuleReady
     * @private
     */
    private moduleReady;
    /**
     * Builds this module based on a given Maps SDK map.
     * @param tomtomMap The map. It may or may not be initialized at this stage,
     * but the module ensures to initialize itself once it is.
     * @param sourceType Whether the module is based on a map style or on added GeoJSON data.
     * @param config Optional configuration to initialize directly as soon as the map is ready.
     */
    protected constructor(sourceType: MapModuleSource, tomtomMap: TomTomMap, config?: CFG);
    /**
     * Initializes the sources with layers of this module.
     * @param config The optional configuration for the module.
     * @param restore Whether we are restoring an existing module after the map style got reloaded.
     * @protected
     * @ignore
     */
    protected initSourcesWithLayers(config?: CFG, restore?: boolean): void;
    /**
     * Initializes the sources with layers for the specific module.
     * @protected
     * @ignore
     */
    protected abstract _initSourcesWithLayers(config?: CFG, restore?: boolean): SOURCES_WITH_LAYERS;
    protected waitUntilModuleReady(): Promise<void>;
    /**
     * Applies a configuration to this module.
     *
     * This method updates the module's behavior and appearance based on the provided configuration.
     * The configuration is stored internally and will be automatically reapplied if the map style changes.
     *
     * @param config - The configuration object to apply to the module. Pass `undefined` to reset
     * the configuration to default values.
     *
     * @remarks
     * When a configuration is applied, the module updates its visual representation and behavior
     * accordingly. The configuration persists across map style changes, ensuring consistent
     * module behavior even when the map's base style is modified.
     *
     * @example
     * ```typescript
     * // Apply a new configuration
     * myModule.applyConfig({ visible: true, opacity: 0.8 });
     *
     * // Reset to default configuration
     * myModule.applyConfig(undefined);
     * ```
     *
     * @see {@link resetConfig} for a convenience method to reset configuration
     * @see {@link getConfig} to retrieve the current configuration
     */
    applyConfig(config: CFG | undefined): void;
    /**
     * Internal implementation to apply config for the specific module.
     * @param config The config to apply. this.config contains the previous configuration (if any).
     * Once the method returns config, it will be assigned to this.config.
     * @protected
     * @ignore
     */
    protected abstract _applyConfig(config: CFG | undefined): CFG | undefined;
    /**
     * Resets the configuration of this module to its default values.
     *
     * This is a convenience method that clears any previously applied configuration
     * and restores the module to its initial state. This is equivalent to calling
     * `applyConfig(undefined)`.
     *
     * @remarks
     * After calling this method, the module will behave as if no configuration was ever applied.
     * Any custom settings, styling, or behavior modifications will be removed and replaced
     * with default values.
     *
     * @example
     * ```typescript
     * // Apply some configuration
     * myModule.applyConfig({ visible: true, opacity: 0.5 });
     *
     * // Later, reset to defaults
     * myModule.resetConfig();
     * ```
     *
     * @see {@link applyConfig} to apply a new configuration
     * @see {@link getConfig} to retrieve the current configuration before resetting
     */
    resetConfig(): void;
    private restoreDataAndConfig;
    /**
     * implementation needed to restore the module state (data and config applied to the module).
     * to be used to restore module state after map style change
     * @protected
     * @ignore
     */
    protected restoreDataAndConfigImpl(): void;
    /**
     * Retrieves a copy of the current module configuration.
     *
     * This method returns a shallow copy of the configuration object that is currently
     * applied to the module. If no configuration has been applied, it returns `undefined`.
     *
     * @returns A shallow copy of the current configuration object, or `undefined` if no
     * configuration is currently applied. The returned object is a copy to prevent
     * unintended modifications to the internal state.
     *
     * @remarks
     * The returned configuration object is a shallow copy, which means that while the
     * top-level properties are copied, any nested objects or arrays are still referenced
     * from the original configuration. This is sufficient for most use cases but should
     * be kept in mind when dealing with complex configurations.
     *
     * @example
     * ```typescript
     * // Apply a configuration
     * myModule.applyConfig({ visible: true, opacity: 0.8 });
     *
     * // Later, retrieve the current configuration
     * const currentConfig = myModule.getConfig();
     * console.log(currentConfig); // { visible: true, opacity: 0.8 }
     *
     * // When no config is applied
     * myModule.resetConfig();
     * console.log(myModule.getConfig()); // undefined
     * ```
     *
     * @see {@link applyConfig} to modify the configuration
     * @see {@link resetConfig} to clear the configuration
     */
    getConfig(): NonNullable<CFG> | undefined;
    /**
     * Gets the source and layer identifiers for all sources managed by this module.
     *
     * This property provides access to the MapLibre source and layer IDs that were created
     * and are managed by this module. These IDs can be used to interact directly with
     * MapLibre's API or to identify which layers belong to this module.
     *
     * @returns A record mapping each source name to its corresponding source ID and layer IDs.
     * Each entry contains the MapLibre source identifier and an array of layer identifiers
     * associated with that source.
     *
     * @remarks
     * The returned IDs are useful when you need to:
     * - Directly manipulate layers using MapLibre's native API
     * - Identify which layers on the map belong to this module
     * - Set layer ordering or positioning relative to other layers
     * - Access source or layer properties through MapLibre methods
     *
     * @example
     * ```typescript
     * const ids = myModule.sourceAndLayerIDs;
     * console.log(ids);
     * // {
     * //   mySource: {
     * //     sourceID: 'my-source-id',
     * //     layerIDs: ['layer-1', 'layer-2']
     * //   }
     * // }
     *
     * // Use with MapLibre API
     * const map = myModule.mapLibreMap;
     * ids.mySource.layerIDs.forEach(layerId => {
     *   map.setLayoutProperty(layerId, 'visibility', 'visible');
     * });
     * ```
     */
    get sourceAndLayerIDs(): Record<keyof SOURCES_WITH_LAYERS, SourceWithLayerIDs>;
}

/**
 * Contains a source and the layers to render its data.
 * @ignore
 */
export declare abstract class AbstractSourceWithLayers<SOURCE_SPEC extends SourceSpecification = SourceSpecification, RUNTIME_SOURCE extends Source = Source, LAYER_SPEC extends LayerSpecification = LayerSpecification> {
    readonly map: Map_2;
    readonly source: TomTomMapSource<SOURCE_SPEC, RUNTIME_SOURCE>;
    readonly _layerSpecs: LAYER_SPEC[];
    private _sourceAndLayerIDs;
    constructor(map: Map_2, source: TomTomMapSource<SOURCE_SPEC, RUNTIME_SOURCE>, layerSpecs: LAYER_SPEC[]);
    isAnyLayerVisible(filter?: LayerSpecFilter): boolean;
    areAllLayersVisible(filter?: LayerSpecFilter): boolean;
    private getLayerSpecs;
    _updateSourceAndLayerIDs(): void;
    private isLayerVisible;
    setLayersVisible(visible: boolean, filter?: LayerSpecFilter): void;
    get sourceAndLayerIDs(): SourceWithLayerIDs;
    equalSourceAndLayerIDs(other: SourceWithLayers): boolean;
}

/**
 * Source with layers which originally is not in the map style, but it's to be added after the map is initialized.
 * @ignore
 */
export declare class AddedSourceWithLayers<SOURCE_SPEC extends SourceSpecification = SourceSpecification, RUNTIME_SOURCE extends Source = Source> extends AbstractSourceWithLayers<SOURCE_SPEC, RUNTIME_SOURCE, ToBeAddedLayerSpec> {
    constructor(map: Map_2, sourceId: string, sourceSpec: SOURCE_SPEC, layerSpecs: ToBeAddedLayerSpecWithoutSource[]);
    private ensureLayersAddedToMap;
    ensureAddedToMapWithVisibility(visible: boolean, addLayersToMap: boolean): void;
}

/**
 * Source identifier for base map vector tiles.
 *
 * @remarks
 * References the primary vector tile source containing roads, buildings,
 * land use, water bodies, and other fundamental map features.
 *
 * @group Base Map
 */
export declare const BASE_MAP_SOURCE_ID = "vectorTiles";

/**
 * Name of a base map layer group.
 *
 * Identifies specific categories of base map layers that can be controlled together.
 *
 * @remarks
 * **Available Layer Groups:**
 * - `land` - Land areas and terrain
 * - `water` - Water bodies (oceans, lakes, rivers)
 * - `borders` - Country and administrative boundaries
 * - `buildings2D` - 2D building footprints
 * - `buildings3D` - 3D building models
 * - `houseNumbers` - House number labels
 * - `roadLines` - Road line geometries
 * - `roadLabels` - Street name labels
 * - `roadShields` - Highway shields (e.g., I-95, A1)
 * - `placeLabels` - General place labels
 * - `smallerTownLabels` - Small town/village labels
 * - `cityLabels` - City labels
 * - `capitalLabels` - Capital city labels
 * - `stateLabels` - State/province labels
 * - `countryLabels` - Country name labels
 *
 * @example
 * ```typescript
 * const group: BaseMapLayerGroupName = 'roadLines';
 * const labels: BaseMapLayerGroupName[] = ['cityLabels', 'countryLabels'];
 * ```
 *
 * @group Base Map
 */
export declare type BaseMapLayerGroupName = (typeof baseMapLayerGroupNames)[number];

/**
 * Available base map layer group identifiers.
 *
 * @remarks
 * Use these names with {@link BaseMapModule} to control layer visibility.
 *
 * @see {@link BaseMapLayerGroupName}
 * @see {@link BaseMapModuleInitConfig.layerGroupsFilter}
 *
 * @group Base Map
 */
export declare const baseMapLayerGroupNames: readonly ["land", "water", "borders", "buildings2D", "buildings3D", "houseNumbers", "roadLines", "roadLabels", "roadShields", "placeLabels", "smallerTownLabels", "cityLabels", "capitalLabels", "stateLabels", "countryLabels"];

/**
 * Layer group filter for selective base map display.
 *
 * Defines which layer groups to include or exclude from the base map module.
 * Can be expressed as explicit inclusions (show only these) or exclusions
 * (show all except these).
 *
 * @remarks
 * **Filter Modes:**
 * - `include`: Only the specified groups are shown, all others are hidden
 * - `exclude`: All groups are shown except the specified ones
 *
 * **Common Use Cases:**
 * - Show only roads and labels (minimal map)
 * - Hide buildings for cleaner appearance
 * - Show only water and land (base terrain)
 * - Remove labels for overlay maps
 *
 * @example
 * ```typescript
 * // Show only roads and borders
 * const roadsOnly: BaseMapLayerGroups = {
 *   mode: 'include',
 *   names: ['roadLines', 'roadLabels', 'borders']
 * };
 *
 * // Show everything except buildings
 * const noBuildings: BaseMapLayerGroups = {
 *   mode: 'exclude',
 *   names: ['buildings2D', 'buildings3D']
 * };
 *
 * // Show only terrain (no labels, no roads)
 * const terrainOnly: BaseMapLayerGroups = {
 *   mode: 'include',
 *   names: ['land', 'water']
 * };
 * ```
 *
 * @group Base Map
 */
export declare type BaseMapLayerGroups = {
    /**
     * Filter mode determining whether groups are included or excluded.
     *
     * @remarks
     * - `include`: Only the specified groups are considered, all others are ignored
     * - `exclude`: All base map groups except the specified ones are considered
     *
     * @example
     * ```typescript
     * mode: 'include'  // Whitelist approach
     * mode: 'exclude'  // Blacklist approach
     * ```
     */
    mode: 'include' | 'exclude';
    /**
     * Names of the layer groups to include or exclude.
     *
     * @remarks
     * The meaning depends on the `mode`:
     * - In `include` mode: Only these groups will be shown
     * - In `exclude` mode: These groups will be hidden, all others shown
     *
     * @example
     * ```typescript
     * // Show only these
     * names: ['roadLines', 'roadLabels', 'water']
     *
     * // Hide these
     * names: ['buildings2D', 'buildings3D', 'houseNumbers']
     * ```
     */
    names: BaseMapLayerGroupName[];
};

/**
 * Layer group visibility configuration with explicit visible state.
 *
 * Extends {@link BaseMapLayerGroups} to include a visibility flag, allowing
 * you to show or hide specific groups of base map layers.
 *
 * @example
 * ```typescript
 * // Hide all buildings
 * const config: BaseMapLayerGroupsVisibility = {
 *   mode: 'include',
 *   names: ['buildings2D', 'buildings3D'],
 *   visible: false
 * };
 *
 * // Show only roads
 * const roadsOnly: BaseMapLayerGroupsVisibility = {
 *   mode: 'include',
 *   names: ['roadLines', 'roadLabels'],
 *   visible: true
 * };
 * ```
 *
 * @group Base Map
 */
export declare type BaseMapLayerGroupsVisibility = BaseMapLayerGroups & {
    visible: boolean;
};

/**
 * Base Map Module for controlling standard map layers and their visibility.
 *
 * This module manages the fundamental map layers including background, water, land, roads,
 * buildings, labels, and other vector tile layers from the base map style.
 *
 * @remarks
 * **Managed Layers:**
 * - Background and terrain
 * - Water bodies and coastlines
 * - Country and administrative borders
 * - Buildings (2D and 3D)
 * - Road lines, labels, and shields
 * - Place labels at various zoom levels
 * - House numbers
 *
 * **Does NOT Include:**
 * - Traffic flow/incidents (use {@link TrafficFlowModule} or {@link TrafficIncidentsModule})
 * - Points of Interest/POIs (use {@link POIsModule})
 * - Hillshade/terrain shading (use {@link HillshadeModule})
 *
 * **Use Cases:**
 * - Toggle base map visibility on/off
 * - Show only specific layer groups (e.g., roads only)
 * - Create custom map appearances by hiding certain elements
 * - Build overlay maps with selective base layers
 *
 * @example
 * Basic usage:
 * ```typescript
 * // Get module with default configuration
 * const baseMap = await BaseMapModule.get(map);
 *
 * // Toggle visibility
 * baseMap.setVisible(false); // Hide all base layers
 * baseMap.setVisible(true);  // Show all base layers
 *
 * // Check current state
 * if (baseMap.isVisible()) {
 *   console.log('Base map is visible');
 * }
 * ```
 *
 * @example
 * Working with layer groups:
 * ```typescript
 * // Show only roads and borders
 * const baseMap = await BaseMapModule.get(map, {
 *   layerGroupsFilter: {
 *     mode: 'include',
 *     names: ['roadLines', 'roadLabels', 'borders']
 *   }
 * });
 *
 * // Hide buildings and labels
 * baseMap.setVisible(false, {
 *   layerGroups: {
 *     mode: 'include',
 *     names: ['buildings2D', 'buildings3D', 'placeLabels']
 *   }
 * });
 *
 * // Show only water and land
 * baseMap.setVisible(true, {
 *   layerGroups: {
 *     mode: 'include',
 *     names: ['water', 'land']
 *   }
 * });
 * ```
 *
 * @example
 * Event handling:
 * ```typescript
 * const baseMap = await BaseMapModule.get(map);
 *
 * // Listen for clicks on base map features
 * baseMap.events.on('click', (feature, lngLat) => {
 *   console.log('Clicked base map feature:', feature);
 * });
 *
 * // Remove event listeners
 * baseMap.events.off('click');
 * ```
 *
 * @see [Base Map Guide](https://docs.tomtom.com/maps-sdk-js/guides/map/base-map)
 * @see [Map Styles Guide](https://docs.tomtom.com/maps-sdk-js/guides/map/map-styles)
 *
 * @group Base Map
 */
export declare class BaseMapModule extends AbstractMapModule<BaseSourceAndLayers, BaseMapModuleConfig> {
    /**
     * Asynchronously retrieves a BaseMapModule instance for the given map.
     *
     * This is the recommended way to create a BaseMapModule. It ensures the map
     * is fully loaded before initializing the module.
     *
     * @param tomtomMap - The TomTomMap instance to attach this module to.
     * @param config - Optional configuration for module initialization.
     *
     * @returns A promise that resolves to the initialized BaseMapModule.
     *
     * @remarks
     * **Initialization:**
     * - Waits for map to be ready before creating module
     * - Validates that required sources exist in the map style
     * - Applies initial configuration if provided
     *
     * **Configuration Options:**
     * - `visible`: Initial visibility state
     * - `layerGroupsFilter`: Which layer groups to include/exclude
     * - `layerGroupsVisibility`: Fine-grained visibility per group
     *
     * @throws Error if the base map source is not found in the style
     *
     * @example
     * Default initialization:
     * ```typescript
     * const baseMap = await BaseMapModule.get(map);
     * ```
     *
     * @example
     * With configuration:
     * ```typescript
     * const baseMap = await BaseMapModule.get(map, {
     *   visible: true,
     *   layerGroupsFilter: {
     *     mode: 'exclude',
     *     names: ['buildings3D', 'houseNumbers']
     *   }
     * });
     * ```
     *
     * @example
     * Show only specific groups:
     * ```typescript
     * const baseMap = await BaseMapModule.get(map, {
     *   layerGroupsFilter: {
     *     mode: 'include',
     *     names: ['water', 'land', 'borders']
     *   },
     *   visible: true
     * });
     * ```
     */
    static get(tomtomMap: TomTomMap, config?: BaseMapModuleInitConfig): Promise<BaseMapModule>;
    private constructor();
    /**
     * @ignore
     */
    protected _initSourcesWithLayers(config: BaseMapModuleInitConfig | undefined): {
        vectorTiles: StyleSourceWithLayers<SourceSpecification, Source>;
    };
    /**
     * @ignore
     */
    protected _applyConfig(config: BaseMapModuleConfig | undefined): {
        visible?: boolean;
        layerGroupsVisibility?: BaseMapLayerGroupsVisibility;
    };
    /**
     * Checks if any base map layers are currently visible.
     *
     * @returns `true` if at least one base map layer is visible, `false` if all are hidden.
     *
     * @remarks
     * This checks the actual visibility state of layers in the map, not just the
     * module's configuration setting.
     *
     * @example
     * ```typescript
     * if (baseMap.isVisible()) {
     *   console.log('Base map is rendered');
     * } else {
     *   console.log('Base map is hidden');
     * }
     * ```
     */
    isVisible(): boolean;
    /**
     * Sets the visibility of base map layers.
     *
     * @param visible - `true` to show layers, `false` to hide them.
     * @param options - Optional settings for fine-grained control.
     * @param options.layerGroups - Target specific layer groups instead of all layers.
     *
     * @remarks
     * **Behavior:**
     * - Without `options.layerGroups`: Affects all base map layers
     * - With `options.layerGroups`: Affects only specified layer groups
     * - Changes are applied immediately if map is ready
     *
     * **Layer Groups:**
     * Available groups: `land`, `water`, `borders`, `buildings2D`, `buildings3D`,
     * `houseNumbers`, `roadLines`, `roadLabels`, `roadShields`, `placeLabels`,
     * `smallerTownLabels`, `cityLabels`, `capitalLabels`, `stateLabels`, `countryLabels`
     *
     * @example
     * Show/hide all layers:
     * ```typescript
     * baseMap.setVisible(false); // Hide everything
     * baseMap.setVisible(true);  // Show everything
     * ```
     *
     * @example
     * Control specific groups:
     * ```typescript
     * // Hide only buildings
     * baseMap.setVisible(false, {
     *   layerGroups: {
     *     mode: 'include',
     *     names: ['buildings2D', 'buildings3D']
     *   }
     * });
     *
     * // Show everything except labels
     * baseMap.setVisible(true, {
     *   layerGroups: {
     *     mode: 'exclude',
     *     names: ['placeLabels', 'cityLabels', 'countryLabels']
     *   }
     * });
     * ```
     *
     * @example
     * Toggle visibility:
     * ```typescript
     * const isVisible = baseMap.isVisible();
     * baseMap.setVisible(!isVisible); // Toggle
     * ```
     */
    setVisible(visible: boolean, options?: {
        layerGroups?: BaseMapLayerGroups;
    }): void;
    /**
     * Gets the events interface for this module to handle user interactions.
     *
     * @returns An EventsModule instance for registering event handlers.
     *
     * @remarks
     * **Supported Events:**
     * - `click`: User clicks on a base map feature
     * - `contextmenu`: User right-clicks on a feature
     * - `hover`: Mouse enters a feature
     * - `long-hover`: Mouse hovers over a feature for extended time
     *
     * **Event Handler Signature:**
     * ```typescript
     * (feature: MapGeoJSONFeature, lngLat: LngLat, allFeatures: MapGeoJSONFeature[]) => void
     * ```
     *
     * @example
     * Register click handler:
     * ```typescript
     * baseMap.events.on('click', (feature, lngLat) => {
     *   console.log('Clicked on:', feature.properties);
     *   console.log('At coordinates:', lngLat);
     * });
     * ```
     *
     * @example
     * Multiple event types:
     * ```typescript
     * // Show tooltip on hover
     * baseMap.events.on('hover', (feature) => {
     *   showTooltip(feature.properties.name);
     * });
     *
     * // Handle clicks
     * baseMap.events.on('click', (feature) => {
     *   selectFeature(feature.id);
     * });
     *
     * // Clean up
     * baseMap.events.off('hover');
     * baseMap.events.off('click');
     * ```
     */
    get events(): EventsModule<MapGeoJSONFeature>;
}

/**
 * Configuration for the BaseMapModule (initialization or runtime).
 *
 * Controls visibility and behavior of base map layer groups. Can be used both
 * during module initialization and for runtime updates.
 *
 * @remarks
 * This configuration allows fine-grained control over which base map elements
 * are displayed, enabling you to create custom map appearances for different
 * use cases.
 *
 * @example
 * ```typescript
 * // Hide specific layer groups
 * const config: BaseMapModuleConfig = {
 *   layerGroupsVisibility: {
 *     mode: 'include',
 *     names: ['buildings2D', 'buildings3D'],
 *     visible: false
 *   }
 * };
 *
 * // Show only certain groups
 * const minimalConfig: BaseMapModuleConfig = {
 *   visible: true,
 *   layerGroupsVisibility: {
 *     mode: 'include',
 *     names: ['roadLines', 'water', 'land'],
 *     visible: true
 *   }
 * };
 * ```
 *
 * @group Base Map
 */
export declare type BaseMapModuleConfig = {
    /**
     * Controls the visibility of all layers associated with this module.
     *
     * @default true
     */
    visible?: boolean;
    /**
     * Optional visibility configuration for specific layer groups.
     *
     * @remarks
     * **Important:** The layer groups specified here must be included in the
     * module (not excluded by `layerGroupsFilter` during initialization).
     *
     * Use this to control visibility of layer groups at runtime without
     * reinitializing the module.
     *
     * @example
     * ```typescript
     * // Hide all building layers
     * layerGroupsVisibility: {
     *   mode: 'include',
     *   names: ['buildings2D', 'buildings3D'],
     *   visible: false
     * }
     *
     * // Show only labels
     * layerGroupsVisibility: {
     *   mode: 'include',
     *   names: ['placeLabels', 'cityLabels', 'countryLabels'],
     *   visible: true
     * }
     * ```
     */
    layerGroupsVisibility?: BaseMapLayerGroupsVisibility;
};

/**
 * Initialization configuration for the BaseMapModule.
 *
 * Extends {@link BaseMapModuleConfig} with additional options available only
 * during module initialization.
 *
 * @remarks
 * **Initialization vs Runtime:**
 * - `layerGroupsFilter`: Only available at init - determines which groups to load
 * - `layerGroupsVisibility`: Available at init and runtime - controls visibility
 *
 * **Use Cases:**
 * - Create minimal maps with only essential layers
 * - Build custom map styles by excluding certain features
 * - Optimize performance by not loading unnecessary layers
 *
 * @example
 * ```typescript
 * // Initialize with only roads and water
 * const initConfig: BaseMapModuleInitConfig = {
 *   layerGroupsFilter: {
 *     mode: 'include',
 *     names: ['roadLines', 'roadLabels', 'water', 'land']
 *   },
 *   visible: true
 * };
 *
 * // Exclude buildings from initialization
 * const noBuildingsConfig: BaseMapModuleInitConfig = {
 *   layerGroupsFilter: {
 *     mode: 'exclude',
 *     names: ['buildings2D', 'buildings3D', 'houseNumbers']
 *   }
 * };
 *
 * // Minimal map for data overlay
 * const overlayBaseConfig: BaseMapModuleInitConfig = {
 *   layerGroupsFilter: {
 *     mode: 'include',
 *     names: ['water', 'land', 'borders']
 *   },
 *   visible: true
 * };
 * ```
 *
 * @group Base Map
 */
export declare type BaseMapModuleInitConfig = BaseMapModuleConfig & {
    /**
     * Layer groups to include/exclude during module initialization.
     *
     * @remarks
     * **One-time configuration:** This can only be set during initialization.
     * Once the module is created, you cannot change which groups are loaded,
     * only their visibility via `layerGroupsVisibility`.
     *
     * @example
     * ```typescript
     * // Load only essential layers
     * layerGroupsFilter: {
     *   mode: 'include',
     *   names: ['land', 'water', 'roadLines', 'borders']
     * }
     *
     * // Load everything except 3D buildings
     * layerGroupsFilter: {
     *   mode: 'exclude',
     *   names: ['buildings3D']
     * }
     *
     * // Minimal overlay map
     * layerGroupsFilter: {
     *   mode: 'include',
     *   names: ['water', 'land']
     * }
     * ```
     */
    layerGroupsFilter?: BaseMapLayerGroups;
};

declare type BaseSourceAndLayers = {
    vectorTiles: StyleSourceWithLayers;
};

/**
 * Builds the title of the place to display it on the map.
 * @param place The place to display.
 * @ignore
 */
export declare const buildPlaceTitle: (place: Place) => string;

/**
 * Generates the routing layers configuration for route visualization on the map.
 * @param config - Optional routing module configuration to customize layer properties.
 * @ignore
 */
export declare const buildRoutingLayers: (config?: RoutingModuleConfig) => Required<RouteLayersConfig>;

/**
 * Parameters to identify a feature by its ID or index in a given features array.
 * @group User Events
 */
export declare type ByIdOrIndex = {
    /**
     * The unique identifier of the feature.
     *
     * @remarks
     * This ID corresponds to the `id` property of the feature being targeted.
     * Cannot be used together with `index`.
     */
    id: string;
} | {
    /**
     * The index of the feature in the feature array.
     *
     * @remarks
     * Zero-based index referring to the position in the features array
     * that was passed to the module's show method.
     * Cannot be used together with `id`.
     */
    index: number;
};

/**
 * Mapping of charging stop speeds to sprite image IDs.
 * @group Routing
 */
export declare type ChargingSpeedIconMapping = Record<ChargingSpeed, string>;

/**
 * Icon display configuration for charging stops along the route.
 *
 * @group Routing
 */
export declare type ChargingStopIconConfig = {
    /**
     * Optional custom icons to be added to the map style for charging stops.
     *
     * @remarks
     * These icons can be referenced in the `mapping` configuration to customize
     * the appearance of charging stop markers based on specific criteria.
     */
    customIcons?: CustomImage[];
    /**
     * Mapping configuration, from charging stop objects to sprite image IDs.
     *
     * @remarks
     * Defines how to select the appropriate icon for each charging stop based on
     * its properties, such as charging speed or a custom mapping function.
     * Does not necessary require custom icons to be provided.
     * If not provided, default icons will be used.
     */
    mapping?: ChargingStopIconMapping;
};

/**
 * Mapping between charging stop properties and the corresponding icon sprite IDs.
 * @group Routing
 */
export declare type ChargingStopIconMapping = {
    /**
     * Determines the icon based on the charging speed of the charging connector.
     */
    basedOn: 'chargingSpeed';
    /**
     * Mapping from charging speeds to sprite image IDs.
     */
    value: ChargingSpeedIconMapping;
} | {
    /**
     * Determines the icon based on a custom function.
     */
    basedOn: 'custom';
    /**
     * The function which maps a ChargingStop to a sprite image ID.
     */
    fn: (stop: ChargingStop) => string;
};

/**
 * Display configuration for charging stops along the route.
 *
 * @remarks
 * Controls visibility, iconography, and text labels for charging stops on the map.
 *
 * @group Routing
 */
export declare type ChargingStopsConfig = {
    /**
     * Controls the overall visibility of charging stop icons and labels on the map.
     * @defaultValue true
     */
    visible?: boolean;
    /**
     * Display configuration for charging stop text labels.
     *
     * @remarks
     * Can control both content and display properties of the text shown next to charging stop icons.
     */
    text?: ChargingStopTextConfig;
    /**
     * Display configuration for charging stop icons.
     */
    icon?: ChargingStopIconConfig;
};

/**
 * Text display configuration for charging stops along the route.
 *
 * @remarks
 * Controls the visibility and content of text labels associated with charging stop markers.
 *
 * @group Routing
 */
export declare type ChargingStopTextConfig = {
    /**
     * Controls the visibility of text labels for charging stops.
     *
     * @defaultValue true
     */
    visible?: boolean;
    /**
     * Custom content/display configuration for the charging stop title.
     *
     * @remarks
     * Defines how the title text for charging stops is formatted and displayed.
     * Can include MapLibre formatted expressions for dynamic content generation.
     *
     * @see https://maplibre.org/maplibre-style-spec/types/#formatted
     */
    title?: DataDrivenPropertyValueSpecification<string>;
};

/**
 * Parameters to clean the event state from a specific feature.
 *
 * Removes event states from a feature, returning it to its normal appearance.
 * Useful for deselecting or unhighlighting features programmatically.
 *
 * @example
 * ```typescript
 * // Remove all event states from a feature
 * const options: CleanEventStateOptions = {
 *   index: 0,
 *   show: true
 * };
 *
 * // Clean without immediately rendering
 * const batchOptions: CleanEventStateOptions = {
 *   index: 5,
 *   show: false
 * };
 * ```
 *
 * @group User Events
 */
export declare type CleanEventStateOptions = ByIdOrIndex & {
    /**
     * Whether to show the feature after cleaning the event state.
     *
     * @remarks
     * Set to false only if you want to keep manipulating features before
     * showing them, which can improve performance for batch updates.
     *
     * @default true
     */
    show?: boolean;
};

/**
 * Parameters to clean event states for a collection of shown features.
 *
 * Bulk operation for removing event states from multiple features at once.
 * More efficient than cleaning features individually.
 *
 * @example
 * ```typescript
 * // Remove all event states from all features
 * const cleanAll: CleanEventStatesOptions = {};
 *
 * // Remove only click states
 * const cleanClicks: CleanEventStatesOptions = {
 *   states: ['click']
 * };
 *
 * // Remove hover states without rendering
 * const cleanHovers: CleanEventStatesOptions = {
 *   states: ['hover', 'long-hover'],
 *   show: false
 * };
 * ```
 *
 * @group User Events
 */
export declare type CleanEventStatesOptions = {
    /**
     * The event states to clean.
     *
     * @remarks
     * If not supplied, all event states will be cleaned from all features.
     *
     * @example
     * ```typescript
     * // Clean only click states
     * states: ['click']
     *
     * // Clean all hover-related states
     * states: ['hover', 'long-hover']
     *
     * // Clean everything (same as omitting)
     * states: ['click', 'contextmenu', 'hover', 'long-hover']
     * ```
     */
    states?: EventType[];
    /**
     * Whether to show the feature after cleaning the event state.
     *
     * @remarks
     * Set to false only if you want to keep manipulating features before
     * showing them, which can improve performance for batch updates.
     *
     * @default true
     */
    show?: boolean;
};

/**
 * Subtype for click events.
 *
 * @remarks
 * - `click`: Regular left-click or tap on touch devices
 * - `contextmenu`: Right-click (or long-press on touch devices)
 *
 * @example
 * ```typescript
 * const clickType: ClickEventType = 'click';
 * const rightClick: ClickEventType = 'contextmenu';
 * ```
 *
 * @group User Events
 */
export declare type ClickEventType = 'click' | 'contextmenu';

declare type ColorPaletteOptions = keyof typeof colorPalettes;

declare const colorPalettes: {
    warm: string[];
    browns: string[];
    cold: string[];
    fadedBlues: string[];
    blues: string[];
    greens: string[];
    fadedGreenToBlue: string[];
    blueToRed: string[];
    greenToYellow: string[];
    pastel: string[];
    retro: string[];
    contrastRetro: string[];
    fadedRainbow: string[];
    pastelRainbow: string[];
};

/**
 * Basic structure to define custom map icons, which end up in the map sprite.
 *
 * Allows you to provide custom images for various map icons such as
 * POIs, route waypoints, charging stations, and any other TomTom map icons,
 * replacing the default icons with your own branding or design.
 *
 * @remarks
 * Icon images can be URLs, raw SVG texts, data URIs or loaded img elements.
 * They will be loaded/transformed if necessary and added to the map style sprite for rendering.
 *
 * @example
 * ```typescript
 * // POI category icon
 * const poiIcon: CustomIcon = {
 *   id: 'RESTAURANT',
 *   image: '/icons/restaurant-marker.png',
 * };
 *
 * // Route waypoint icon
 * const waypointIcon: CustomIcon = {
 *   id: WAYPOINT_START_IMAGE_ID,
 *   image: '/icons/waypoint-start.png',
 * };
 *
 * // Charging station icon
 * const chargingIcon: CustomIcon = {
 *   id: 'my-charging-station',
 *   image: '/icons/ev-charger-low-res.png',
 *   pixelRatio: 1
 * };
 * ```
 *
 * @see https://maplibre.org/maplibre-style-spec/sprite/
 * @group Shared
 */
export declare type CustomImage<I extends string = string> = {
    /**
     * Unique identifier for the icon in the map sprite.
     *
     * This ID is used to reference the icon when styling map features.
     * The specific values depend on the context:
     * - For POI categories: Use MapStylePOICategory values (e.g., 'RESTAURANT', 'HOTEL_MOTEL')
     * - For route waypoints: Use waypoint identifiers (e.g., 'waypoint-start', 'waypoint-end')
     * - For charging stations: Use station type identifiers
     * - For custom markers: Use any unique string identifier
     */
    id: I;
    /**
     * URL or data URI of the icon image.
     *
     * @remarks
     * This property is optional. If omitted, the icon with the corresponding `id`
     * must already exist in the map's sprite. Use this property when you need to add
     * a new icon to the sprite, or provide `undefined` when referencing an existing sprite icon.
     *
     * @example
     * ```typescript
     * // Adding a new icon to the sprite
     * image: 'https://example.com/marker.png'
     *
     * // Using a data URI
     * image: 'data:image/png;base64,iVBORw0KG...'
     *
     * // Using a relative path
     * image: '/assets/icons/marker.png'
     *
     * // Referencing an existing sprite icon (no URL needed)
     * // image is omitted when the icon already exists in the sprite
     * ```
     */
    image?: string | HTMLImageElement;
    /**
     * The pixel ratio of the icon image.
     *
     * @remarks
     * This property is optional and only relevant when `image` is provided.
     * If omitted while providing an `image`, it defaults to `2`.
     * When the icon already exists in the sprite (no `image`), this property is ignored.
     *
     * Use `2` for high-DPI (Retina) displays, `1` for standard displays.
     * Higher values result in sharper icons on high-resolution screens.
     *
     * @default 2 (recommended for modern screens)
     *
     * @example
     * ```typescript
     * // For @2x resolution images
     * pixelRatio: 2
     *
     * // For standard resolution images
     * pixelRatio: 1
     * ```
     */
    pixelRatio?: number;
};

/**
 * Configuration for a custom map style.
 *
 * Allows using your own map style either via URL or direct JSON specification.
 *
 * @remarks
 * Use custom styles for:
 * - Branded map appearances
 * - Specialized use cases (indoor maps, thematic maps)
 * - Integration with custom tile servers
 *
 * @example
 * ```typescript
 * // Load from URL
 * const urlStyle: CustomStyle = {
 *   url: 'https://example.com/my-custom-style.json'
 * };
 *
 * // Direct JSON specification
 * const jsonStyle: CustomStyle = {
 *   json: {
 *     version: 8,
 *     sources: { ... },
 *     layers: [ ... ]
 *   }
 * };
 * ```
 *
 * @group Map Style
 */
export declare type CustomStyle = {
    /**
     * URL to a MapLibre/Mapbox style JSON.
     *
     * The URL should not include the API key - it will be automatically added.
     * Mutually exclusive with the `json` property.
     *
     * @example
     * ```typescript
     * url: 'https://api.tomtom.com/style/1/style/my-custom-style'
     * ```
     */
    url?: string;
    /**
     * Direct style specification as JSON.
     *
     * Provide the complete MapLibre Style Specification object.
     * Mutually exclusive with the `url` property.
     *
     * @see [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/)
     *
     * @example
     * ```typescript
     * json: {
     *   version: 8,
     *   sources: {
     *     'my-source': { type: 'vector', url: '...' }
     *   },
     *   layers: [
     *     { id: 'background', type: 'background', paint: { 'background-color': '#f0f0f0' } }
     *   ]
     * }
     * ```
     */
    json?: StyleSpecification;
};

/**
 * Configuration for the default place icon.
 * * This is the icon that is used for clicked locations and addresses without a specific category.
 *
 * @group Places
 */
export declare type DefaultPlaceIconConfig = {
    /**
     * Base style options for the SVG default icon.
     *
     * @remarks
     * Use this to set the fill color, outline color, and outline opacity for the default waypoint icon.
     *
     * Example:
     * ```typescript
     * baseStyle: {
     *   fillColor: '#007AFF',
     *   outlineColor: '#FFFFFF',
     *   outlineOpacity: 0.8
     * }
     * ```
     */
    style?: SVGIconStyleOptions;
    /**
     * Custom image for the default icon.
     *
     * @remarks
     * If provided, this image will be used instead of the default icon.
     *
     * If an SVG image is provided, the 'style' options can still apply. Otherwise, 'style' is ignored.
     */
    image?: Omit<CustomImage, 'id'>;
};

/**
 * Default routing layers configuration. Calls routingLayers with no parameters.
 *
 * @remarks
 * This configuration defines the complete visual styling for all route-related map layers,
 * including main route lines, waypoints, special road sections (ferries, tunnels, toll roads, etc.),
 * turn-by-turn guidance instructions, and route summary information.
 *
 * **Usage:**
 * - Automatically applied when initializing {@link RoutingModule} without custom layer configuration
 * - Can be used as a reference or starting point for creating custom layer configurations
 * - Individual properties can be selectively overridden while keeping defaults for others
 *
 * @see {@link buildRoutingLayers} for details.
 *
 * @see {@link RouteLayersConfig} for the configuration type definition
 * @see {@link RoutingModule.get} for initialization options
 * @see {@link RoutingModule.applyConfig} for runtime configuration updates
 *
 * @group Routing
 */
export declare const defaultRoutingLayers: Required<RouteLayersConfig>;

/**
 * Configuration for filtering traffic incidents by delay duration.
 *
 * @remarks
 * Allows filtering incidents based on whether they cause delays and the severity of those delays.
 * Useful for focusing on incidents with the most significant traffic impact.
 *
 * @group Traffic
 */
export declare type DelayFilter = {
    /**
     * Requires incidents to have an associated delay.
     *
     * @remarks
     * When `true`, incidents without delay information will be hidden from the map.
     * When `false` or omitted, incidents are shown regardless of delay data availability.
     *
     * @defaultValue `false`
     */
    mustHaveDelay?: boolean;
    /**
     * Minimum delay threshold in minutes.
     *
     * @remarks
     * Only incidents causing delays of at least this duration will be shown.
     *
     * **Behavior:**
     * - If `mustHaveDelay` is `false` or not set, this filter only applies to incidents that have delay data
     * - Incidents without delay data are still shown (unless `mustHaveDelay` is `true`)
     *
     * @example
     * ```ts
     * // Show only incidents with delays of 5 minutes or more
     * delays: { minDelayMinutes: 5 }
     * ```
     */
    minDelayMinutes?: number;
};

/**
 * Deselected route line foreground color.
 * @ignore
 */
export declare const DESELECTED_FOREGROUND_COLOR = "#ABAFB3";

/**
 * Deselected route line outline color.
 * @ignore
 */
export declare const DESELECTED_OUTLINE_COLOR = "#3C4956";

/**
 * Used for showing/hiding layer depending on layer being part of deselected route or not.
 *
 * @remarks
 * Add this to layers that depend on whether they are part of the deselected route or not.
 *
 * @example:
 * filter: DESELECTED_ROUTE_FILTER

 * @group Routing
 */
export declare const DESELECTED_ROUTE_FILTER: ExpressionSpecification;

/**
 * @ignore
 */
export declare const DESELECTED_SECONDARY_COLOR = "#727C85";

/**
 * Geometry base and display properties.
 *
 * Combines complete place information with geometry-specific display properties
 * for rendering polygon features on the map.
 *
 * @remarks
 * Used by the GeometriesModule for rendering:
 * - Search API geometry results
 * - Reachable range polygons
 * - Custom polygon overlays
 * - Administrative boundaries
 *
 * Includes both geographic/metadata and visual styling properties.
 *
 * @example
 * ```typescript
 * const geometry: DisplayGeometryProps = {
 *   type: 'Polygon',
 *   id: 'geom-123',
 *   title: 'Amsterdam',
 *   color: '#0080FF',
 *   address: {
 *     municipalitySubdivision: 'Amsterdam',
 *     countryCode: 'NL'
 *   }
 * };
 * ```
 *
 * @group Geometries
 */
export declare type DisplayGeometryProps = CommonPlaceProps & ExtraGeometryDisplayProps;

/**
 * @ignore
 */
declare type DisplayInstruction = Feature<LineString, Instruction & DisplayRouteRelatedProps>;

/**
 * @ignore
 */
declare type DisplayInstructionArrowProps = {
    lastPointBearingDegrees: number;
};

/**
 * @ignore
 */
declare type DisplayInstructionArrows = FeatureCollection<Point, Instruction & DisplayInstructionArrowProps & DisplayRouteRelatedProps>;

/**
 * @ignore
 */
declare type DisplayInstructions = FeatureCollection<LineString, Instruction & DisplayRouteRelatedProps>;

/**
 * Place base and display properties combined.
 *
 * Merges complete place information from the core API with display-specific
 * properties for rendering on the map.
 *
 * @remarks
 * This is the full type used by the PlacesModule for rendering search results,
 * POIs, and other location markers on the map. It combines:
 * - Geographic data (coordinates, address)
 * - Place metadata (POI info, opening hours, etc.)
 * - Display properties (icon, title, category)
 * - Interactive state (event handling)
 *
 * @example
 * ```typescript
 * const place: DisplayPlaceProps = {
 *   type: 'Point',
 *   position: { lon: 4.9, lat: 52.3 },
 *   address: {
 *     streetName: 'Damrak',
 *     municipalitySubdivision: 'Amsterdam',
 *     countryCode: 'NL'
 *   },
 *   poi: {
 *     name: 'Central Station',
 *     categories: ['RAILWAY_STATION']
 *   },
 *   id: 'place-123',
 *   title: 'Amsterdam Central Station',
 *   iconID: 'poi-transit',
 *   category: 'RAILWAY_STATION'
 * };
 * ```
 *
 * @group Places
 */
export declare type DisplayPlaceProps = CommonPlaceProps & PlaceDisplayProps;

/**
 * Display props focused on route lines.
 *
 * Combines complete route information with styling and event handling capabilities.
 * Used for rendering the actual route geometry on the map.
 *
 * @remarks
 * This type extends the base route properties with display-specific information
 * needed for rendering and interaction.
 *
 * @example
 * ```typescript
 * const displayRoute: DisplayRouteProps = {
 *   ...routeData,
 *   routeState: 'selected',
 *   eventState: 'hover'
 * };
 * ```
 *
 * @group Routing
 */
export declare type DisplayRouteProps = RouteProps & RouteStateProps & SupportsEvents;

/**
 * Route properties combined with styling and index information.
 *
 * Associates route data with its position in a multi-route result and its visual state.
 *
 * @remarks
 * Used internally by the routing module to track and style multiple routes.
 * The `routeIndex` corresponds to the route's position in the original routes array.
 *
 * @example
 * ```typescript
 * const routeProps: DisplayRouteRelatedProps = {
 *   routeState: 'selected',
 *   routeIndex: 0  // First route in the array
 * };
 * ```
 *
 * @group Routing
 */
export declare type DisplayRouteRelatedProps = RouteStateProps & {
    /**
     * Zero-based index of this route in the routes array.
     *
     * @remarks
     * Used to identify which route this data belongs to when displaying
     * multiple alternative routes.
     */
    routeIndex: number;
};

/**
 * GeoJSON feature collection of points with display-ready route summary props.
 *
 * Collection of all route summary bubbles for multiple routes, used when displaying
 * route alternatives with summary information.
 *
 * @remarks
 * Typically contains one summary per route, but can include multiple summaries
 * per route for detailed displays.
 *
 * @example
 * ```typescript
 * const summaries: DisplayRouteSummaries = {
 *   type: 'FeatureCollection',
 *   features: [
 *     {
 *       type: 'Feature',
 *       geometry: { type: 'Point', coordinates: [4.9, 52.3] },
 *       properties: {
 *         routeIndex: 0,
 *         routeState: 'selected',
 *         formattedDistance: '15.3 km',
 *         formattedDuration: '22 min'
 *       }
 *     },
 *     {
 *       type: 'Feature',
 *       geometry: { type: 'Point', coordinates: [4.85, 52.35] },
 *       properties: {
 *         routeIndex: 1,
 *         routeState: 'deselected',
 *         formattedDistance: '18.7 km',
 *         formattedDuration: '25 min'
 *       }
 *     }
 *   ]
 * };
 * ```
 *
 * @group Routing
 */
export declare type DisplayRouteSummaries = FeatureCollection<Point, DisplayRouteSummaryProps>;

/**
 * GeoJSON feature of a point with display-ready route summary props.
 *
 * Represents a single route summary bubble on the map, typically shown at the
 * end point or along the route path.
 *
 * @remarks
 * **Use Cases:**
 * - End-point summary bubbles
 * - Midpoint information markers
 * - Interactive route details
 *
 * @example
 * ```typescript
 * const summaryFeature: DisplayRouteSummary = {
 *   type: 'Feature',
 *   geometry: {
 *     type: 'Point',
 *     coordinates: [4.9, 52.3]
 *   },
 *   properties: {
 *     routeIndex: 0,
 *     routeState: 'selected',
 *     formattedDistance: '15.3 km',
 *     formattedDuration: '22 min'
 *   }
 * };
 * ```
 *
 * @group Routing
 */
export declare type DisplayRouteSummary = Feature<Point, DisplayRouteSummaryProps>;

/**
 * Display-ready properties for a route summary bubble.
 *
 * Contains pre-formatted strings for displaying route information in UI elements
 * such as summary cards, tooltips, or info bubbles.
 *
 * @remarks
 * **Use Cases:**
 * - Route comparison cards
 * - Summary bubbles on the map
 * - Route selection UI
 * - Mobile route panels
 *
 * All formatting (units, duration format) is handled by the SDK based on
 * the configured display settings.
 *
 * @example
 * ```typescript
 * const summary: DisplayRouteSummaryProps = {
 *   routeIndex: 0,
 *   routeState: 'selected',
 *   formattedDistance: '15.3 km',
 *   formattedDuration: '22 min',
 *   formattedTraffic: '5 min delay',
 *   magnitudeOfDelay: 'moderate'
 * };
 * ```
 *
 * @group Routing
 */
export declare type DisplayRouteSummaryProps = DisplayRouteRelatedProps & {
    /**
     * Formatted distance of the route in the chosen units.
     *
     * @remarks
     * Automatically formatted based on the display units configuration:
     * - Metric: "15.3 km" or "500 m"
     * - Imperial: "9.5 mi" or "1,640 ft"
     *
     * @example
     * ```typescript
     * formattedDistance: '15.3 km'
     * formattedDistance: '9.5 mi'
     * ```
     */
    formattedDistance?: string;
    /**
     * Formatted duration of the route.
     *
     * @remarks
     * Human-readable travel time with appropriate units:
     * - Short: "15 min"
     * - Medium: "1 h 30 min"
     * - Long: "2 h 15 min"
     *
     * Includes traffic considerations if traffic data is enabled.
     *
     * @example
     * ```typescript
     * formattedDuration: '22 min'
     * formattedDuration: '1 h 45 min'
     * ```
     */
    formattedDuration?: string;
    /**
     * Formatted traffic delay of the route.
     *
     * @remarks
     * Shows the additional time due to current traffic conditions.
     * Only present when there is a delay and traffic data is available.
     *
     * @example
     * ```typescript
     * formattedTraffic: '5 min delay'
     * formattedTraffic: '15 min delay'
     * formattedTraffic: undefined  // No delay
     * ```
     */
    formattedTraffic?: string;
    /**
     * Overall delay magnitude for the route.
     *
     * @remarks
     * Categorizes the severity of traffic delays:
     * - `minor`: Small delays (typically < 5 minutes)
     * - `moderate`: Noticeable delays (typically 5-15 minutes)
     * - `major`: Significant delays (typically > 15 minutes)
     * - `undefined`: No delay or no traffic data
     *
     * Useful for color-coding or visual indicators in UI.
     *
     * @example
     * ```typescript
     * magnitudeOfDelay: 'moderate'
     * ```
     */
    magnitudeOfDelay?: DelayMagnitude;
};

/**
 * Display-ready section properties combining base section data with route context.
 *
 * Extends section information with routing module display properties, allowing
 * sections to be rendered with proper styling and route association.
 *
 * @remarks
 * Used for rendering special route segments like ferry crossings, tolls, tunnels, etc.
 *
 * @example
 * ```typescript
 * const sectionProps: DisplaySectionProps = {
 *   ...sectionData,
 *   routeIndex: 0,
 *   routeState: 'selected'
 * };
 * ```
 *
 * @group Routing
 */
declare type DisplaySectionProps = SectionProps & DisplayRouteRelatedProps;

/**
 * Display properties for traffic-related route sections.
 *
 * Extends display section properties with traffic-specific information including
 * incident details and visual elements for rendering.
 *
 * @remarks
 * Traffic sections highlight areas of congestion, incidents, or delays along
 * the route. They include additional properties for displaying icons and titles
 * in the UI.
 *
 * @example
 * ```typescript
 * const trafficSection: DisplayTrafficSectionProps = {
 *   sectionType: 'traffic',
 *   routeIndex: 0,
 *   routeState: 'selected',
 *   simpleCategory: 'jam',
 *   magnitudeOfDelay: 'moderate',
 *   iconID: 'traffic-jam-icon',
 *   title: '5 min delay due to traffic jam'
 * };
 * ```
 *
 * @ignore
 */
declare type DisplayTrafficSectionProps = DisplaySectionProps & TrafficSectionProps & {
    /**
     * Icon ID for jam category, if any.
     */
    jamIconID?: string;
    /**
     * Icon ID for the main cause of the incident, if any (roadworks, weather-related, accident...).
     */
    causeIconID?: string;
    /**
     * Title for the traffic section.
     *
     * @remarks
     * By default, consists of the incident delay if any, but can be
     * customized to provide more detailed information.
     *
     * @example
     * ```typescript
     * title: '5 min delay'
     * title: 'Accident ahead - 10 min delay'
     * title: 'Heavy traffic'
     * ```
     */
    title?: string;
};

declare type EventHandlers = Record<string, SourceEventHandlers>;

/**
 * Event handling interface for map features.
 *
 * Provides a simple API for attaching and removing event handlers for user interactions
 * with map features such as clicks, hovers, and context menus. Each map module (POIs, Routing,
 * Places, etc.) exposes an `events` property that returns an EventsModule instance.
 *
 * @typeParam T - The feature type returned in event handlers (extends MapGeoJSONFeature)
 *
 * @remarks
 * **Supported Event Types:**
 * - `click`: User clicks/taps on a feature
 * - `contextmenu`: User right-clicks on a feature (or long-press on mobile)
 * - `hover`: Mouse enters a feature
 * - `long-hover`: Mouse hovers over feature for configured duration (300-800ms)
 *
 * **Event Handler Signature:**
 * ```typescript
 * (feature: T, lngLat: LngLat, features: T[]) => void
 * ```
 *
 * **Parameters:**
 * - `feature`: The primary feature under the cursor
 * - `lngLat`: Geographic coordinates of the event
 * - `features`: All features at this location (when multiple overlap)
 *
 * **Key Features:**
 * - Automatic cursor management (pointer on hover)
 * - Smart event handling for overlapping features
 * - Configurable hover delays
 * - Memory-safe cleanup when removing handlers
 *
 * @example
 * ```typescript
 * // POI click handler
 * const pois = map.pois();
 * pois.events.on('click', (feature, lngLat) => {
 *   console.log('Clicked POI:', feature.properties.name);
 *   console.log('Location:', lngLat);
 *   showInfoWindow(feature.properties);
 * });
 *
 * // Route waypoint hover
 * const routing = map.routing();
 * routing.events.waypoints.on('hover', (waypoint) => {
 *   showTooltip(`Waypoint ${waypoint.properties.index}`);
 * });
 *
 * // Long-hover for detailed info
 * pois.events.on('long-hover', (feature) => {
 *   loadAndShowDetailedInfo(feature.properties.id);
 * });
 *
 * // Context menu (right-click)
 * routing.events.mainLines.on('contextmenu', (route, lngLat) => {
 *   showContextMenu(lngLat, [
 *     { label: 'Add waypoint here', action: () => addWaypoint(lngLat) },
 *     { label: 'View route details', action: () => showDetails(route) }
 *   ]);
 * });
 *
 * // Remove all click handlers
 * pois.events.off('click');
 * ```
 *
 * @example
 * ```typescript
 * // Complete interaction example
 * const places = map.places();
 *
 * // Show name on hover
 * places.events.on('hover', (place) => {
 *   tooltip.show(place.properties.name);
 * });
 *
 * // Show details on click
 * places.events.on('click', (place, lngLat) => {
 *   sidebar.show({
 *     title: place.properties.name,
 *     address: place.properties.address.freeformAddress,
 *     coordinates: lngLat
 *   });
 * });
 *
 * // Cleanup on component unmount
 * onUnmount(() => {
 *   places.events.off('hover');
 *   places.events.off('click');
 * });
 * ```
 *
 * @group User Events
 */
export declare class EventsModule<T = MapGeoJSONFeature> {
    private readonly eventProxy;
    private readonly sourceWithLayers;
    constructor(eventProxy: EventsProxy, sourceWithLayers: SourceWithLayers);
    /**
     * Register an event handler for user interactions with map features.
     *
     * Attaches a callback function that will be invoked when users interact with
     * features in this module (e.g., clicking on a POI, hovering over a route).
     *
     * @param type The type of event to listen for (click, contextmenu, hover, long-hover)
     * @param handler Callback function invoked when the event occurs
     *
     * @remarks
     * **Handler Parameters:**
     * - `feature`: The primary feature that triggered the event
     * - `lngLat`: Geographic coordinates [longitude, latitude] of the event
     * - `features`: Array of all features at the event location (for overlapping features)
     *
     * **Behavior:**
     * - Only one handler per event type (calling `on()` again replaces the previous handler)
     * - Handlers are preserved across map style changes
     * - Cursor automatically changes to pointer on hover
     * - Events respect module visibility (hidden features don't trigger events)
     *
     * **Performance:**
     * - Hover events use spatial indexing for fast lookup
     * - Long-hover has configurable delay to prevent accidental triggers
     * - Event handlers should be lightweight to maintain smooth interaction
     *
     * @example
     * ```typescript
     * // Basic click handler
     * module.events.on('click', (feature, lngLat, features) => {
     *   console.log('Clicked feature:', feature.properties);
     *   console.log('Location:', lngLat);
     *   console.log('All features here:', features.length);
     * });
     *
     * // Hover with tooltip
     * module.events.on('hover', (feature) => {
     *   const name = feature.properties.name || 'Unnamed';
     *   tooltip.show(name);
     * });
     *
     * // Long-hover for detailed preview
     * module.events.on('long-hover', (feature) => {
     *   // Only triggered after hovering for 300-800ms
     *   loadPreview(feature.properties.id);
     * });
     *
     * // Right-click context menu
     * module.events.on('contextmenu', (feature, lngLat) => {
     *   event.preventDefault(); // Prevent browser context menu
     *   showCustomMenu(lngLat, feature);
     * });
     * ```
     *
     * @example
     * ```typescript
     * // Route-specific handlers
     * const routing = map.routing();
     *
     * // Handle route line clicks
     * routing.events.mainLines.on('click', (route) => {
     *   highlightRoute(route.properties.routeID);
     *   showRouteSummary(route.properties.summary);
     * });
     *
     * // Handle waypoint interactions
     * routing.events.waypoints.on('hover', (waypoint) => {
     *   const index = waypoint.properties.index;
     *   showTooltip(`Stop ${index + 1}`);
     * });
     * ```
     */
    on(type: EventType, handler: UserEventHandler<T>): void;
    /**
     * Remove all event handlers for a specific event type.
     *
     * Unregisters the callback function for the specified event type, stopping
     * further event notifications. This is important for cleanup to prevent
     * memory leaks and unwanted behavior.
     *
     * @param type The type of event to stop listening for
     *
     * @remarks
     * **Cleanup Behavior:**
     * - Removes only the specified event type (other types remain active)
     * - Resets cursor behavior for this module
     * - Safe to call multiple times (no error if no handler exists)
     * - Does not affect other modules' event handlers
     *
     * **When to Use:**
     * - Component unmounting/cleanup
     * - Switching between interaction modes
     * - Temporarily disabling interactions
     * - Replacing an existing handler (call `off()` then `on()`)
     *
     * **Best Practices:**
     * - Always clean up event handlers when component unmounts
     * - Remove handlers before removing features from the map
     * - Use framework lifecycle hooks for automatic cleanup
     *
     * @example
     * ```typescript
     * // Remove click handlers
     * module.events.off('click');
     *
     * // Remove all handlers
     * module.events.off('click');
     * module.events.off('hover');
     * module.events.off('long-hover');
     * module.events.off('contextmenu');
     * ```
     *
     * @example
     * ```typescript
     * // React component cleanup
     * useEffect(() => {
     *   const pois = map.pois();
     *
     *   pois.events.on('click', handlePoiClick);
     *   pois.events.on('hover', handlePoiHover);
     *
     *   return () => {
     *     // Cleanup on unmount
     *     pois.events.off('click');
     *     pois.events.off('hover');
     *   };
     * }, [map]);
     * ```
     *
     * @example
     * ```typescript
     * // Replace handler
     * module.events.off('click'); // Remove old handler
     * module.events.on('click', newHandler); // Add new handler
     *
     * // Disable interactions temporarily
     * const savedHandler = currentHandler;
     * module.events.off('click'); // Disable
     * // ... later ...
     * module.events.on('click', savedHandler); // Re-enable
     * ```
     */
    off(type: EventType): void;
}

/**
 * This is the place where we handle the user events on the map (mousemove/hover and click mostly).
 * To have full control on hovers and clicks when multiple overlapping layers are present, that logic must be centralized here.
 * @ignore
 */
export declare class EventsProxy extends AbstractEventProxy {
    private readonly map;
    private readonly mapCanvas;
    private enabled;
    private hoveringLngLat?;
    private hoveringPoint?;
    private hoveringFeature?;
    private hoveringFeatures?;
    private hoveringSourceWithLayers?;
    private longHoverTimeoutHandlerID?;
    private firstDelayedHoverSinceMapMove;
    private lastClickedFeature?;
    private lastClickedSourceWithLayers?;
    private lastCursorStyle;
    private readonly config;
    private readonly defaultZoomLevel;
    constructor(map: Map_2, config?: MapEventsConfig);
    private listenToEvents;
    enable(enabled: boolean): void;
    private toPaddedBounds;
    private isEnabled;
    private getRenderedFeatures;
    private clearLongHoverTimeout;
    private restartLongHoverTimeout;
    private handleLongHoverTimeout;
    private onMouseStart;
    private onMouseOut;
    private onMouseDown;
    private onMouseUp;
    private onMouseMove;
    private updateCursor;
    private onMapClick;
}

/**
 * Type of user event supported by the SDK beyond basic MapLibre support.
 *
 * @remarks
 * The SDK extends MapLibre's basic event handling with additional event types
 * that are commonly needed for interactive map features.
 *
 * @example
 * ```typescript
 * const eventType: EventType = 'click';
 * const hoverEvent: EventType = 'long-hover';
 * ```
 *
 * @group User Events
 */
export declare type EventType = ClickEventType | HoverEventType;

/**
 * Extra properties to display color and title for a geometry on the map.
 *
 * Provides customization options for rendering polygon geometries, including
 * visual styling and labeling.
 *
 * @remarks
 * **Use Cases:**
 * - Search result boundaries (e.g., city limits, postal codes)
 * - Reachable range polygons
 * - Delivery zones
 * - Custom area highlights
 *
 * These properties override default styling and allow per-feature customization.
 *
 * @example
 * ```typescript
 * const geometryProps: ExtraGeometryDisplayProps = {
 *   title: 'Amsterdam City Center',
 *   color: '#FF5733',
 *   eventState: 'click'
 * };
 *
 * // With custom properties
 * const customProps: ExtraGeometryDisplayProps = {
 *   title: 'Delivery Zone A',
 *   color: '#00FF00',
 *   zoneId: 'zone-a',
 *   capacity: 100
 * };
 * ```
 *
 * @group Geometries
 */
export declare type ExtraGeometryDisplayProps = {
    /**
     * Display title for the geometry.
     *
     * @remarks
     * Optional text label displayed at the center of the polygon.
     * If not provided, no label will be shown.
     *
     * **Common Uses:**
     * - Area names (e.g., "Downtown", "Zone A")
     * - Statistics (e.g., "30 min reachable")
     * - Custom labels
     *
     * @example
     * ```typescript
     * title: 'Amsterdam City Center'
     * title: 'Zone A'
     * title: '30 min driving range'
     * title: undefined  // No label
     * ```
     */
    title?: string;
    /**
     * Fill color for the geometry.
     *
     * @remarks
     * Overrides the default fill color from the module configuration.
     * Accepts any valid CSS color value.
     *
     * **Color Formats:**
     * - Hex: '#FF5733'
     * - RGB: 'rgb(255, 87, 51)'
     * - RGBA: 'rgba(255, 87, 51, 0.5)'
     * - Named: 'red', 'blue', 'green'
     *
     * @example
     * ```typescript
     * color: '#FF5733'
     * color: 'rgb(0, 128, 255)'
     * color: 'rgba(255, 0, 0, 0.5)'
     * color: 'red'
     * ```
     */
    color?: string;
} & SupportsEvents & Anything;

/**
 * A POI classification or group that can be filtered.
 *
 * Can be either a specific POI category (like RESTAURANT, HOTEL_MOTEL) or a
 * broader category group (like FOOD_DRINKS_GROUP, SHOPPING_GROUP) that contains
 * multiple related categories.
 *
 * @remarks
 * **Category vs Group:**
 * - Category: Specific POI type (e.g., RESTAURANT, GAS_STATION)
 * - Group: Collection of related categories (e.g., FOOD_DRINKS_GROUP includes restaurants, cafes, bars)
 *
 * Using groups is more convenient when you want to filter multiple related categories at once.
 *
 * @example
 * ```typescript
 * // Individual category
 * const category: FilterablePOICategory = 'RESTAURANT';
 *
 * // Category group
 * const group: FilterablePOICategory = 'FOOD_DRINKS_GROUP';
 *
 * // Mix of both
 * const categories: FilterablePOICategory[] = ['RESTAURANT', 'SHOPPING_GROUP'];
 * ```
 *
 * @group POIs
 */
export declare type FilterablePOICategory = MapStylePOICategory | POICategoryGroup;

/**
 * @ignore
 * @param loadedMap
 * @param sourceIDs
 */
export declare const filterLayersBySources: (loadedMap: Map_2, sourceIDs: string[]) => LayerSpecWithSource[];

/**
 * Filter mode determining whether to include or exclude specified values.
 *
 * @remarks
 * Controls how the values list is interpreted:
 * - `all_except`: Show everything except the specified values (exclusion mode)
 * - `only`: Show only the specified values, hide everything else (inclusion mode)
 *
 * @example
 * ```typescript
 * // Exclusion mode
 * const mode: FilterShowMode = 'all_except';
 *
 * // Inclusion mode
 * const mode: FilterShowMode = 'only';
 * ```
 *
 * @group Shared
 */
export declare type FilterShowMode = 'all_except' | 'only';

/**
 * @ignore
 */
export declare type FilterSyntaxVersion = 'expression' | 'legacy';

/**
 * @group Routing
 */
export declare const FINISH_INDEX = "finish";

/**
 * Configuration for traffic flow visualization module.
 *
 * @remarks
 * Controls the display of real-time traffic flow data on road segments,
 * including styling and filtering options.
 *
 * @group Traffic Flow
 */
export declare type FlowConfig = {
    /**
     * Controls the visibility of the traffic flow layers.
     *
     * @default false
     */
    visible?: boolean;
    /**
     * Filter configuration for traffic flow data.
     *
     * @remarks
     * Controls which road segments display traffic flow information
     * based on road category and closure status.
     */
    filters?: TrafficFlowFilters;
};

/**
 * @ignore
 */
export declare class GeoJSONSourceWithLayers<T extends FeatureCollection = FeatureCollection> extends AddedSourceWithLayers<GeoJSONSourceSpecification, GeoJSONSource> {
    shownFeatures: T;
    constructor(map: Map_2, sourceId: string, layerSpecs: ToBeAddedLayerSpecWithoutSource[], addLayersToMap?: boolean);
    show(featureCollection: T): void;
    clear(): void;
    private findFeature;
    putEventState(options: PutEventStateOptions): void;
    cleanEventState(options: CleanEventStateOptions): void;
    cleanEventStates(options?: CleanEventStatesOptions): void;
}

/**
 * Geometries Module for displaying polygon areas with custom styling on the map.
 *
 * This module enables visualization of geographic areas (polygons) with customizable
 * colors, borders, and labels. Ideal for displaying search results, administrative
 * boundaries, service areas, or any polygon-based geographic data.
 *
 * @remarks
 * **Features:**
 * - Display single or multiple polygon geometries
 * - Customizable fill colors and opacity
 * - Configurable borders (color, width, opacity)
 * - Optional text labels for geometries
 * - Support for data-driven styling via MapLibre expressions
 * - Layer ordering control
 * - Event handling for user interactions
 *
 * **Data Format:**
 * - Accepts GeoJSON Polygon and MultiPolygon features
 * - Supports FeatureCollection for multiple geometries
 * - Compatible with TomTom Search API geometry results
 *
 * **Styling:**
 * - Use predefined color palettes or custom colors
 * - Apply MapLibre expressions for dynamic styling
 * - Per-feature styling via feature properties
 *
 * @example
 * Basic usage:
 * ```typescript
 * import { GeometriesModule } from '@tomtom-international/maps-sdk-js/map';
 *
 * // Initialize module
 * const geometries = await GeometriesModule.get(map);
 *
 * // Display a polygon
 * await geometries.show({
 *   type: 'Feature',
 *   geometry: {
 *     type: 'Polygon',
 *     coordinates: [[[4.88, 52.37], [4.89, 52.37], [4.89, 52.38], [4.88, 52.38], [4.88, 52.37]]]
 *   },
 *   properties: {
 *     title: 'Area of Interest'
 *   }
 * });
 * ```
 *
 * @example
 * Custom styling:
 * ```typescript
 * const geometries = await GeometriesModule.get(map, {
 *   colorConfig: {
 *     fillColor: '#FF5733',
 *     fillOpacity: 0.3
 *   },
 *   lineConfig: {
 *     lineColor: '#C70039',
 *     lineWidth: 3
 *   },
 *   textConfig: {
 *     textField: ['get', 'name']
 *   }
 * });
 *
 * await geometries.show(polygonFeatures);
 * ```
 *
 * @example
 * Multiple geometries with different colors:
 * ```typescript
 * await geometries.show({
 *   type: 'FeatureCollection',
 *   features: [
 *     {
 *       type: 'Feature',
 *       geometry: { type: 'Polygon', coordinates: [...] },
 *       properties: { color: '#FF0000', title: 'Red Zone' }
 *     },
 *     {
 *       type: 'Feature',
 *       geometry: { type: 'Polygon', coordinates: [...] },
 *       properties: { color: '#00FF00', title: 'Green Zone' }
 *     }
 *   ]
 * });
 * ```
 *
 * @example
 * Event handling:
 * ```typescript
 * geometries.events.on('click', (feature, lngLat) => {
 *   console.log('Clicked geometry:', feature.properties.title);
 *   console.log('At coordinates:', lngLat);
 * });
 *
 * geometries.events.on('hover', (feature) => {
 *   showTooltip(feature.properties.title);
 * });
 * ```
 *
 * @see [Geometries Guide](https://docs.tomtom.com/maps-sdk-js/guides/map/geometries)
 *
 * @group Geometries
 */
export declare class GeometriesModule extends AbstractMapModule<GeometrySourcesWithLayers, GeometriesModuleConfig> {
    private static lastInstanceIndex;
    private titleLayerSpecs;
    private geometryFillLayerSpecs;
    private geometryOutlineLayerSpecs;
    private sourceID;
    private fillLayerID;
    private outlineLayerID;
    private titleSourceID;
    private titleLayerID;
    /**
     * Make sure the map is ready before create an instance of the module and any other interaction with the map
     * @param tomtomMap The TomTomMap instance.
     * @param config  The module optional configuration
     * @returns {Promise} Returns a promise with a new instance of this module
     *
     * @remarks
     * **Configuration Options:**
     * - `colorConfig`: Fill color and opacity settings
     * - `lineConfig`: Border/outline styling
     * - `textConfig`: Label display configuration
     * - `beforeLayerConfig`: Layer ordering (place above/below other layers)
     *
     * **Multiple Instances:**
     * You can create multiple GeometriesModule instances on the same map,
     * each managing different sets of geometries with different styles.
     *
     * @example
     * Default initialization:
     * ```typescript
     * const geometries = await GeometriesModule.get(map);
     * ```
     *
     * @example
     * With custom styling:
     * ```typescript
     * const geometries = await GeometriesModule.get(map, {
     *   colorConfig: {
     *     fillColor: 'blue',
     *     fillOpacity: 0.25
     *   },
     *   lineConfig: {
     *     lineColor: 'darkblue',
     *     lineWidth: 2,
     *     lineOpacity: 0.8
     *   },
     *   textConfig: {
     *     textField: ['get', 'title']
     *   },
     *   beforeLayerConfig: 'top'
     * });
     * ```
     *
     * @example
     * Data-driven styling:
     * ```typescript
     * const geometries = await GeometriesModule.get(map, {
     *   colorConfig: {
     *     // Color based on feature properties
     *     fillColor: [
     *       'match',
     *       ['get', 'type'],
     *       'residential', '#FFEB3B',
     *       'commercial', '#2196F3',
     *       'industrial', '#9E9E9E',
     *       '#E0E0E0' // default
     *     ],
     *     fillOpacity: 0.4
     *   }
     * });
     * ```
     */
    static get(tomtomMap: TomTomMap, config?: GeometriesModuleConfig): Promise<GeometriesModule>;
    private constructor();
    /**
     * @ignore
     */
    protected _initSourcesWithLayers(config?: GeometriesModuleConfig, restore?: boolean): GeometrySourcesWithLayers;
    /**
     * @ignore
     */
    protected _applyConfig(config: GeometriesModuleConfig | undefined): GeometriesModuleConfig | undefined;
    private moveBeforeLayerID;
    /**
     * Positions the geometry layers relative to other map layers.
     *
     * @param layerConfig - Layer positioning configuration.
     * Can be `'top'` to place above all layers, or a specific layer ID.
     *
     * @remarks
     * **Use Cases:**
     * - Place geometries above base map but below labels
     * - Ensure geometries appear above/below specific features
     * - Control visual hierarchy of multiple data layers
     *
     * **Available Layer IDs:**
     * Use predefined layer IDs from `mapStyleLayerIDs` or custom layer IDs.
     *
     * @example
     * ```typescript
     * import { mapStyleLayerIDs } from '@tomtom-international/maps-sdk-js/map';
     *
     * // Place below labels
     * geometries.moveBeforeLayer(mapStyleLayerIDs.lowestLabel);
     *
     * // Place on top
     * geometries.moveBeforeLayer('top');
     * ```
     */
    moveBeforeLayer(layerConfig: GeometryBeforeLayerConfig): void;
    /**
     * Updates the text/label configuration for displayed geometries.
     *
     * @param textConfig - New text configuration settings.
     *
     * @remarks
     * **Configuration:**
     * - `textField`: MapLibre expression for label text content
     * - Supports dynamic text based on feature properties
     * - Changes apply to currently shown and future geometries
     *
     * @example
     * ```typescript
     * // Show feature property as label
     * geometries.applyTextConfig({
     *   textField: ['get', 'name']
     * });
     *
     * // Conditional labels
     * geometries.applyTextConfig({
     *   textField: [
     *     'case',
     *     ['has', 'label'],
     *     ['get', 'label'],
     *     ['get', 'title']
     *   ]
     * });
     * ```
     */
    applyTextConfig(textConfig: GeometryTextConfig): void;
    private updateLayerAndData;
    /**
     * @ignore
     */
    protected restoreDataAndConfigImpl(): void;
    /**
     * Displays the given polygon geometries on the map.
     *
     * @param geometries - Polygon features to display. Can be a single Feature,
     * array of Features, or a FeatureCollection.
     *
     * @remarks
     * **Behavior:**
     * - Replaces any previously shown geometries
     * - Applies current module styling configuration
     * - Waits for module to be ready before displaying
     * - Automatically handles both Polygon and MultiPolygon types
     *
     * **Feature Properties:**
     * - `title`: Used for labels if text config is set
     * - `color`: Override fill color per feature
     * - Custom properties accessible in styling expressions
     *
     * @example
     * Single polygon:
     * ```typescript
     * await geometries.show({
     *   type: 'Feature',
     *   geometry: {
     *     type: 'Polygon',
     *     coordinates: [[[4.88, 52.37], [4.89, 52.37], [4.89, 52.38], [4.88, 52.37]]]
     *   },
     *   properties: {
     *     title: 'Amsterdam Center',
     *     color: '#FF5733'
     *   }
     * });
     * ```
     *
     * @example
     * Multiple polygons:
     * ```typescript
     * await geometries.show({
     *   type: 'FeatureCollection',
     *   features: [
     *     { type: 'Feature', geometry: {...}, properties: {...} },
     *     { type: 'Feature', geometry: {...}, properties: {...} }
     *   ]
     * });
     * ```
     *
     * @example
     * From search API response:
     * ```typescript
     * import { search } from '@tomtom-international/maps-sdk-js/services';
     *
     * const result = await search.geometrySearch({
     *   query: 'Amsterdam',
     *   geometryList: [{ type: 'CIRCLE', position: [52.37, 4.89], radius: 5000 }]
     * });
     *
     * if (result.results[0].dataSources?.geometry) {
     *   await geometries.show(result.results[0].dataSources.geometry);
     * }
     * ```
     */
    show(geometries: PolygonFeatures): Promise<void>;
    /**
     * Removes all geometries from the map.
     *
     * @remarks
     * - Clears both geometry layers and labels
     * - Does not reset styling configuration
     * - Module remains initialized and ready for new data
     *
     * @example
     * ```typescript
     * // Clear displayed geometries
     * await geometries.clear();
     *
     * // Show new geometries
     * await geometries.show(newGeometries);
     * ```
     */
    clear(): Promise<void>;
    /**
     * Gets the events interface for handling user interactions with geometries.
     *
     * @returns An EventsModule instance for registering event handlers.
     *
     * @remarks
     * **Supported Events:**
     * - `click`: User clicks on a geometry
     * - `contextmenu`: User right-clicks on a geometry
     * - `hover`: Mouse enters a geometry
     * - `long-hover`: Mouse hovers over geometry for extended time
     *
     * **Event Features:**
     * - Receive the original feature data passed to `show()`
     * - Access feature properties and geometry
     * - Get click/hover coordinates
     *
     * @example
     * Basic event handling:
     * ```typescript
     * geometries.events.on('click', (feature, lngLat) => {
     *   console.log('Clicked:', feature.properties);
     *   console.log('Location:', lngLat);
     * });
     * ```
     *
     * @example
     * Multiple handlers:
     * ```typescript
     * // Highlight on hover
     * geometries.events.on('hover', (feature) => {
     *   highlightGeometry(feature.id);
     * });
     *
     * // Show details on click
     * geometries.events.on('click', (feature) => {
     *   showDetailPanel(feature.properties);
     * });
     *
     * // Context menu
     * geometries.events.on('contextmenu', (feature, lngLat) => {
     *   showContextMenu(lngLat, feature);
     * });
     * ```
     */
    get events(): EventsModule<MapGeoJSONFeature>;
}

/**
 * Configuration options for the GeometriesModule.
 *
 * Controls the visual appearance and positioning of polygon geometries displayed on the map.
 *
 * @example
 * ```typescript
 * // Basic styling
 * const config: GeometriesModuleConfig = {
 *   colorConfig: {
 *     fillColor: '#FF5733',
 *     fillOpacity: 0.3
 *   },
 *   lineConfig: {
 *     lineColor: '#C70039',
 *     lineWidth: 2
 *   }
 * };
 *
 * // With labels and positioning
 * const advancedConfig: GeometriesModuleConfig = {
 *   colorConfig: {
 *     fillColor: 'blue',
 *     fillOpacity: 0.25
 *   },
 *   lineConfig: {
 *     lineColor: 'darkblue',
 *     lineWidth: 3
 *   },
 *   textConfig: {
 *     textField: ['get', 'name']
 *   },
 *   beforeLayerConfig: 'lowestLabel'  // Below map labels
 * };
 *
 * // Data-driven styling
 * const dynamicConfig: GeometriesModuleConfig = {
 *   colorConfig: {
 *     fillColor: ['match', ['get', 'category'], 'park', '#4CAF50', 'water', '#2196F3', '#9E9E9E'],
 *     fillOpacity: 0.4
 *   },
 *   lineConfig: {
 *     lineColor: '#000000',
 *     lineWidth: ['case', ['get', 'highlighted'], 4, 2]
 *   },
 *   textConfig: {
 *     textField: ['concat', ['get', 'name'], '\n', ['get', 'area'], ' km']
 *   }
 * };
 * ```
 *
 * @group Geometries
 */
export declare type GeometriesModuleConfig = {
    /**
     * Fill color and opacity configuration.
     *
     * Controls the interior color and transparency of polygon geometries.
     */
    colorConfig?: GeometryColorConfig;
    /**
     * Text label configuration.
     *
     * Controls labels displayed at geometry center points.
     */
    textConfig?: GeometryTextConfig;
    /**
     * Border/outline configuration.
     *
     * Controls the outline appearance of polygon geometries.
     */
    lineConfig?: GeometryLineConfig;
    /**
     * Layer positioning configuration.
     *
     * Controls where geometry layers appear in the map's layer stack.
     * Use `'top'` to place above all layers, or specify a layer ID to place
     * below that layer.
     *
     * @example
     * ```typescript
     * // On top of everything
     * beforeLayerConfig: 'top'
     *
     * // Below map labels
     * beforeLayerConfig: 'lowestLabel'
     *
     * // Below POI layer
     * beforeLayerConfig: 'POI'
     * ```
     */
    beforeLayerConfig?: GeometryBeforeLayerConfig;
};

/**
 * @ignore
 */
export declare const GEOMETRY_COLOR_PROP = "color";

/**
 * @ignore
 */
export declare const GEOMETRY_TITLE_PROP = "title";

/**
 * Layer positioning configuration for geometries.
 *
 * Controls where geometry layers are placed in the map's layer stack.
 *
 * @remarks
 * Use this to ensure geometries appear above or below other map features like
 * labels, roads, or other data layers.
 *
 * @example
 * ```typescript
 * // Place on top of all layers
 * const beforeLayer: GeometryBeforeLayerConfig = 'top';
 *
 * // Place below labels
 * const beforeLayer: GeometryBeforeLayerConfig = 'lowestLabel';
 * ```
 *
 * @group Geometries
 */
export declare type GeometryBeforeLayerConfig = 'top' | MapStyleLayerID;

/**
 * Color configuration for geometry fill styling.
 *
 * Controls the fill color and opacity of polygon geometries displayed on the map.
 *
 * @example
 * ```typescript
 * // Solid color with opacity
 * const colorConfig: GeometryColorConfig = {
 *   fillColor: '#FF5733',
 *   fillOpacity: 0.3
 * };
 *
 * // Using color palette
 * const paletteConfig: GeometryColorConfig = {
 *   fillColor: 'red',  // Color palette name
 *   fillOpacity: 0.25
 * };
 *
 * // Data-driven color based on properties
 * const dynamicConfig: GeometryColorConfig = {
 *   fillColor: ['match', ['get', 'type'], 'residential', '#FFEB3B', 'commercial', '#2196F3', '#E0E0E0'],
 *   fillOpacity: 0.4
 * };
 * ```
 *
 * @group Geometries
 */
export declare type GeometryColorConfig = {
    /**
     * Fill color for the geometry.
     *
     * @remarks
     * Can be:
     * - Hex color string (e.g., `'#FF5733'`)
     * - Color palette name (e.g., `'red'`, `'blue'`)
     * - MapLibre expression for data-driven styling
     *
     * @default '#0080FF'
     *
     * @example
     * ```typescript
     * // Hex color
     * fillColor: '#FF5733'
     *
     * // Palette name
     * fillColor: 'red'
     *
     * // MapLibre expression
     * fillColor: ['get', 'color']
     *
     * // Conditional coloring
     * fillColor: ['case', ['>', ['get', 'area'], 10000], '#FF0000', '#00FF00']
     * ```
     */
    fillColor?: ColorPaletteOptions | DataDrivenPropertyValueSpecification<string>;
    /**
     * Opacity of the fill color.
     *
     * @remarks
     * Value between 0 (fully transparent) and 1 (fully opaque).
     *
     * @default 0.3
     *
     * @example
     * ```typescript
     * fillOpacity: 0.5  // 50% transparent
     *
     * // Data-driven opacity
     * fillOpacity: ['interpolate', ['linear'], ['get', 'importance'], 1, 0.8, 10, 0.3]
     * ```
     */
    fillOpacity?: DataDrivenPropertyValueSpecification<number>;
};

/**
 * Line/border configuration for geometries.
 *
 * Controls the outline appearance of polygon geometries.
 *
 * @example
 * ```typescript
 * // Basic border
 * const lineConfig: GeometryLineConfig = {
 *   lineColor: '#333333',
 *   lineWidth: 2,
 *   lineOpacity: 0.8
 * };
 *
 * // Data-driven border
 * const dynamicLine: GeometryLineConfig = {
 *   lineColor: ['get', 'borderColor'],
 *   lineWidth: ['case', ['get', 'selected'], 4, 2],
 *   lineOpacity: 1
 * };
 * ```
 *
 * @group Geometries
 */
export declare type GeometryLineConfig = {
    /**
     * Color of the geometry border/outline.
     *
     * @default '#0080FF'
     *
     * @example
     * ```typescript
     * lineColor: '#333333'
     * lineColor: ['get', 'borderColor']
     * ```
     */
    lineColor?: DataDrivenPropertyValueSpecification<string>;
    /**
     * Opacity of the border line.
     *
     * @remarks
     * Value between 0 (fully transparent) and 1 (fully opaque).
     *
     * @default 1
     *
     * @example
     * ```typescript
     * lineOpacity: 0.8
     * ```
     */
    lineOpacity?: DataDrivenPropertyValueSpecification<number>;
    /**
     * Width of the border line in pixels.
     *
     * @default 2
     *
     * @example
     * ```typescript
     * lineWidth: 3
     *
     * // Highlight selected geometries
     * lineWidth: ['case', ['get', 'selected'], 4, 2]
     * ```
     */
    lineWidth?: DataDrivenPropertyValueSpecification<number>;
};

/**
 * IDs of sources and layers from a geometry module.
 */
declare type GeometrySourcesWithLayers = {
    geometry: GeoJSONSourceWithLayers<PolygonFeatures>;
    geometryLabel: GeoJSONSourceWithLayers<FeatureCollection<Point>>;
};

/**
 * Text label configuration for geometries.
 *
 * Controls text labels displayed at the center of polygon geometries.
 *
 * @example
 * ```typescript
 * // Simple text field
 * const textConfig: GeometryTextConfig = {
 *   textField: ['get', 'name']
 * };
 *
 * // Conditional text
 * const conditionalText: GeometryTextConfig = {
 *   textField: ['case', ['has', 'title'], ['get', 'title'], ['get', 'id']]
 * };
 * ```
 *
 * @group Geometries
 */
export declare type GeometryTextConfig = {
    /**
     * Text content to display as label.
     *
     * @remarks
     * Must be a MapLibre expression that evaluates to a string.
     * Labels are positioned at the geometry's center point.
     *
     * @example
     * ```typescript
     * // Display feature property
     * textField: ['get', 'name']
     *
     * // Concatenate properties
     * textField: ['concat', ['get', 'name'], ' (', ['get', 'area'], ' km)']
     *
     * // Conditional text
     * textField: ['case', ['has', 'label'], ['get', 'label'], '']
     * ```
     */
    textField: DataDrivenPropertyValueSpecification<string>;
};

/**
 * Gets the map style sprite image ID to display on the map for the give place.
 * @ignore
 */
export declare const getIconIDForPlace: (place: Place, instanceIndex: number, config?: PlacesModuleConfig) => string;

/**
 * Maps a Place category to the poi layer one, so the latter's style can apply it.
 * @ignore
 */
export declare const getPOILayerCategoryForPlace: (place: Place) => string | undefined;

/**
 * Gets the specified filtered categories icon IDs to be used in map filtering.
 * @param categories list of filtered categories.
 * @ignore
 */
export declare const getStyleCategories: (categories: FilterablePOICategory[]) => string[];

/**
 * Configuration for adding custom layers to a map module based on its controlled source data.
 *
 * @group Shared
 */
export declare type HasAdditionalLayersConfig = {
    /**
     * Additional custom layers to be added alongside the predefined ones.
     *
     * @remarks
     * Allows for further customization by specifying extra layers that
     * complement the standard route visualization layers.
     *
     * Use these if you want to add extra visuals to a specific module part, be it lines, symbols, or any MapLibre supported layer.
     *
     * You can define 'beforeID' in the additional layers to place them under predefined ones (or other of your additional layers).
     */
    additional?: Record<string, ToBeAddedLayerSpecTemplate<SymbolLayerSpecification | LineLayerSpecification | CircleLayerSpecification>>;
};

/**
 * @ignore
 */
export declare type HasBeforeID = {
    /**
     * The ID of an existing layer to insert the new layer before,
     * resulting in the new layer appearing visually beneath the existing layer.
     * If this argument is not specified, the layer will be appended to the end of the layers array
     * and appear visually above all other layers.
     * @see Map.addLayer
     */
    beforeID?: string;
};

/**
 * Source identifier for hillshade terrain visualization.
 *
 * @remarks
 * References the raster source that provides terrain shading to visualize
 * elevation and topography on the map.
 *
 * @group Hillshade
 */
export declare const HILLSHADE_SOURCE_ID = "hillshade";

/**
 * Map module for displaying terrain shading (hillshade).
 *
 * The HillshadeModule adds realistic terrain depth perception to the map by rendering
 * shadow and highlight effects based on elevation data. This enhances the 3D appearance
 * of mountainous and hilly terrain.
 *
 * @remarks
 * **Features:**
 * - Realistic terrain shading
 * - Uses vector tile elevation data
 * - Lightweight performance impact
 * - Seamlessly integrates with other map layers
 * - Toggle visibility on/off
 *
 * **Common Use Cases:**
 * - Outdoor recreation maps (hiking, skiing)
 * - Geographic/topographic applications
 * - Environmental visualization
 * - Landscape planning tools
 *
 * @example
 * ```typescript
 * // Create the module with hillshade visible
 * const hillshade = await HillshadeModule.getInstance(map, {
 *   visible: true
 * });
 *
 * // Toggle visibility
 * hillshade.setVisible(false);
 *
 * // Listen to events
 * hillshade.events.on('click', (feature, lngLat) => {
 *   console.log('Clicked hillshade at:', lngLat);
 * });
 * ```
 *
 * @see [Hillshade Guide](https://docs.tomtom.com/maps-sdk-js/guides/map/hillshade)
 *
 * @group Hillshade
 */
export declare class HillshadeModule extends AbstractMapModule<HillshadeSourcesWithLayers, HillshadeModuleConfig> {
    /**
     * Retrieves a HillshadeModule instance for the given map.
     *
     * @param map - The TomTomMap instance to attach this module to.
     * @param config - Optional configuration for initialization and visibility.
     *
     * @returns A promise that resolves to the initialized HillshadeModule.
     *
     * @remarks
     * **Configuration:**
     * - `visible`: Initial visibility state
     * - `ensureAddedToStyle`: Auto-add hillshade to style if missing
     *
     * **Style Requirement:**
     * - Hillshade must be included in the map style or added via `ensureAddedToStyle`
     * - Some styles may not support hillshade (e.g., satellite)
     *
     * @throws Error if hillshade source is not in style and `ensureAddedToStyle` is false
     *
     * @example
     * Default initialization:
     * ```typescript
     * const hillshade = await HillshadeModule.get(map);
     * ```
     *
     * @example
     * Auto-add to style if missing:
     * ```typescript
     * const hillshade = await HillshadeModule.get(map, {
     *   visible: true
     * });
     * ```
     *
     * @example
     * Start hidden:
     * ```typescript
     * const hillshade = await HillshadeModule.get(map, {
     *   visible: false
     * });
     * ```
     */
    static get(map: TomTomMap, config?: HillshadeModuleConfig): Promise<HillshadeModule>;
    private constructor();
    /**
     * @ignore
     */
    protected _initSourcesWithLayers(): {
        hillshade: StyleSourceWithLayers<SourceSpecification, Source>;
    };
    /**
     * @ignore
     */
    protected _applyConfig(config: HillshadeModuleConfig | undefined): HillshadeModuleConfig | undefined;
    /**
     * Sets the visibility of the hillshade layer.
     *
     * @param visible - `true` to show hillshade, `false` to hide it.
     *
     * @remarks
     * Changes are applied immediately if the map is ready.
     *
     * @example
     * ```typescript
     * hillshade.setVisible(true);  // Show terrain shading
     * hillshade.setVisible(false); // Hide terrain shading
     * ```
     */
    setVisible(visible: boolean): void;
    /**
     * Checks if the hillshade layer is currently visible.
     *
     * @returns `true` if visible, `false` if hidden.
     *
     * @example
     * ```typescript
     * if (hillshade.isVisible()) {
     *   console.log('Terrain shading is active');
     * }
     * ```
     */
    isVisible(): boolean;
    /**
     * Gets the events interface for handling user interactions with hillshade.
     *
     * @returns An EventsModule instance for registering event handlers.
     *
     * @remarks
     * **Supported Events:**
     * - `click`: User clicks on the hillshade layer
     * - `contextmenu`: User right-clicks
     * - `hover`: Mouse enters hillshade area
     * - `long-hover`: Extended hover
     *
     * @example
     * ```typescript
     * hillshade.events.on('click', (feature, lngLat) => {
     *   console.log('Clicked terrain at:', lngLat);
     * });
     * ```
     */
    get events(): EventsModule<MapGeoJSONFeature>;
}

/**
 * Configuration options for the HillshadeModule.
 *
 * Controls the appearance and visibility of terrain shading on the map.
 *
 * @remarks
 * The HillshadeModule uses vector tile elevation data to create shadow/highlight
 * effects that enhance the 3D perception of terrain features like mountains and valleys.
 *
 * **Configuration Options:**
 * - `visible`: Whether the hillshade layer is shown or hidden
 *
 * **Visual Effect:**
 * - Creates realistic terrain depth perception
 * - Lightweight performance impact
 * - Works alongside other map layers
 *
 * @example
 * ```typescript
 * // Show hillshade
 * const config: HillshadeModuleConfig = {
 *   visible: true
 * };
 *
 * // Hide hillshade initially
 * const hiddenConfig: HillshadeModuleConfig = {
 *   visible: false
 * };
 * ```
 *
 * @group Hillshade
 */
export declare type HillshadeModuleConfig = {
    /**
     * Controls the visibility of the hillshade layers.
     *
     * @default false
     */
    visible?: boolean;
};

/**
 * IDs of sources and layers for hillshade module.
 */
declare type HillshadeSourcesWithLayers = {
    hillshade: StyleSourceWithLayers;
};

/**
 * Subtype for hover events with timing distinction.
 *
 * @remarks
 * - `hover`: Immediate hover when cursor enters a feature
 * - `long-hover`: Triggered after hovering for a configured duration (typically 300-800ms)
 *
 * Long-hover is useful for showing detailed tooltips or previews without
 * cluttering the UI during quick mouse movements.
 *
 * @example
 * ```typescript
 * const quickHover: HoverEventType = 'hover';
 * const sustainedHover: HoverEventType = 'long-hover';
 * ```
 *
 * @group User Events
 */
export declare type HoverEventType = 'hover' | 'long-hover';

/**
 * @ignore
 */
export declare const imageIDWithInstanceSuffix: (baseID: string, instanceIndex: number) => string;

/**
 * Available traffic incident category identifiers.
 *
 * @remarks
 * These categories classify different types of traffic incidents that can be displayed on the map.
 *
 * @group Traffic Incidents
 */
export declare const incidentCategories: readonly ["unknown", "accident", "fog", "dangerous_conditions", "rain", "ice", "jam", "lane_closed", "road_closed", "road_works", "wind", "flooding", "broken_down_vehicle"];

/**
 * @ignore
 */
export declare const incidentCategoriesMapping: Record<IncidentCategory, number>;

/**
 * Traffic incident category type.
 *
 * @remarks
 * Represents the type of traffic incident affecting road conditions.
 * Used for filtering and categorizing incidents displayed on the map.
 *
 * Available categories:
 * - `unknown` - Unclassified incident
 * - `accident` - Vehicle collision or crash
 * - `fog` - Low visibility due to fog
 * - `dangerous_conditions` - Hazardous road conditions
 * - `rain` - Heavy rain affecting traffic
 * - `ice` - Icy road conditions
 * - `jam` - Traffic congestion or standstill
 * - `lane_closed` - One or more lanes unavailable
 * - `road_closed` - Complete road closure
 * - `road_works` - Construction or maintenance
 * - `wind` - Strong winds affecting traffic
 * - `flooding` - Water on roadway
 * - `broken_down_vehicle` - Disabled vehicle blocking traffic
 *
 * @group Traffic Incidents
 */
export declare type IncidentCategory = (typeof incidentCategories)[number];

/**
 * Common configuration for traffic incident visualization components.
 *
 * @remarks
 * Provides shared styling and filtering options used by both incident lines and icons.
 * Extends base style module configuration with traffic incident-specific filters.
 *
 * @group Traffic Incidents
 */
export declare type IncidentsCommonConfig = {
    /**
     * Controls the visibility of the traffic incident layers.
     *
     * @default false
     */
    visible?: boolean;
    /**
     * Filter configuration for traffic incidents.
     *
     * @remarks
     * Controls which incidents are displayed based on category, severity, delay, and road type.
     */
    filters?: TrafficIncidentsFilters;
};

/**
 * Configuration for traffic incidents module.
 *
 * @remarks
 * Provides complete configuration for displaying traffic incidents on the map,
 * including separate styling for incident lines and icons.
 *
 * @group Traffic Incidents
 */
export declare type IncidentsConfig = IncidentsCommonConfig & {
    /**
     * Configuration specific to incident icon display.
     *
     * @remarks
     * Allows separate styling and filtering for incident marker icons,
     * independent of the incident line styling.
     */
    icons?: IncidentsCommonConfig;
};

/**
 * @ignore
 */
export declare const INDEX_TYPE = "indexType";

/**
 * Function signature to filter layers.
 * @ignore
 */
export declare type LayerSpecFilter = (layerSpec: LayerSpecification) => boolean;

/**
 * TomTom Maps SDK layer specifications template, without ID nor source, to be still initialized in some map module.
 * @ignore
 */
export declare type LayerSpecTemplate<L extends LayerSpecification> = Omit<L, 'id' | 'source'>;

/**
 * Layer specification that supports a data source.
 * @ignore
 */
export declare type LayerSpecWithSource = Exclude<LayerSpecification, BackgroundLayerSpecification>;

/**
 * Indicator of a light or dark theme.
 * * Can be used to classify a map style as light or dark, or to apply light or dark configurations to map modules if they support it.
 *
 * @group Map Style
 */
export declare type LightDark = 'light' | 'dark';

/**
 * @ignore
 */
export declare const MAJOR_DELAY_COLOR = "#AD0000";

/**
 * @ignore
 */
declare const mapDisplayPoiCategoryMappings: Partial<Record<POICategory, string>>;

/**
 * Configuration options for map user event handling.
 *
 * Controls how user interactions (clicks, hovers) are detected and processed,
 * including precision modes, cursor styles, and timing behaviors.
 *
 * @remarks
 * These settings affect all interactive map modules (places, POIs, routes, etc.).
 * Fine-tuning these values can improve user experience based on your use case.
 *
 * @example
 * ```typescript
 * // Default configuration for desktop
 * const config: MapEventsConfig = {
 *   precisionMode: 'box',
 *   paddingBoxPx: 5,
 *   cursorOnHover: 'pointer',
 *   longHoverDelayOnStillMapMS: 300
 * };
 *
 * // Mobile-optimized with larger hit area
 * const mobileConfig: MapEventsConfig = {
 *   precisionMode: 'box',
 *   paddingBoxPx: 15,  // Larger touch targets
 *   longHoverDelayAfterMapMoveMS: 1000
 * };
 *
 * // Precise picking for dense data
 * const preciseConfig: MapEventsConfig = {
 *   precisionMode: 'point',  // Exact pixel matching
 *   cursorOnHover: 'crosshair'
 * };
 * ```
 *
 * @group Map
 */
export declare type MapEventsConfig = {
    /**
     * Defines the event coordinates precision mode.
     *
     * @remarks
     * **Modes:**
     * - `box`: Features are queried within a padding box around the event point (default)
     * - `point`: Features are queried at the exact event point (most precise)
     * - `point-then-box`: Try point first, then fall back to box if nothing found
     *
     * **Use Cases:**
     * - `box`: Best for general use, easier to click small features
     * - `point`: Precise picking for dense overlapping features
     * - `point-then-box`: Balance between precision and usability
     *
     * @default 'box'
     *
     * @example
     * ```typescript
     * // Easier interaction with padding
     * precisionMode: 'box'
     *
     * // Exact pixel matching
     * precisionMode: 'point'
     *
     * // Adaptive approach
     * precisionMode: 'point-then-box'
     * ```
     */
    precisionMode?: 'box' | 'point' | 'point-then-box';
    /**
     * Optional padding box to be inserted around the event point, in pixels.
     *
     * @remarks
     * Ignored if `precisionMode` is set to `"point"`.
     *
     * **Guidelines:**
     * - Desktop: 5-10px for comfortable clicking
     * - Mobile/touch: 10-20px for finger-friendly targets
     * - Dense data: 3-5px to avoid unintended selections
     *
     * @default 5
     *
     * @example
     * ```typescript
     * // Standard desktop
     * paddingBoxPx: 5
     *
     * // Mobile-friendly
     * paddingBoxPx: 15
     *
     * // Precise selection
     * paddingBoxPx: 2
     * ```
     */
    paddingBoxPx?: number;
    /**
     * Optional configuration to show custom cursor when hovering over interactive features.
     *
     * @remarks
     * Accepts any valid CSS cursor value.
     *
     * @default 'pointer'
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor | MDN cursor documentation}
     *
     * @example
     * ```typescript
     * // Default pointer
     * cursorOnHover: 'pointer'
     *
     * // Crosshair for precise selection
     * cursorOnHover: 'crosshair'
     *
     * // Help cursor for info bubbles
     * cursorOnHover: 'help'
     *
     * // Custom cursor image
     * cursorOnHover: 'url(/cursors/custom.png), pointer'
     * ```
     */
    cursorOnHover?: string;
    /**
     * Optional configuration to show custom cursor when clicking (mouse down).
     *
     * @remarks
     * Accepts any valid CSS cursor value. Provides visual feedback during the
     * click action.
     *
     * @default 'grabbing'
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor | MDN cursor documentation}
     *
     * @example
     * ```typescript
     * // Grabbing hand
     * cursorOnMouseDown: 'grabbing'
     *
     * // Move cursor
     * cursorOnMouseDown: 'move'
     *
     * // Custom cursor
     * cursorOnMouseDown: 'url(/cursors/drag.png), grabbing'
     * ```
     */
    cursorOnMouseDown?: string;
    /**
     * Optional configuration to show custom cursor on the map canvas.
     *
     * @remarks
     * Accepts any valid CSS cursor value. This is the default cursor shown
     * when not interacting with any features.
     *
     * @default 'default'
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor | MDN cursor documentation}
     *
     * @example
     * ```typescript
     * // Standard arrow
     * cursorOnMap: 'default'
     *
     * // Open hand for draggable map
     * cursorOnMap: 'grab'
     *
     * // Crosshair for measurement tools
     * cursorOnMap: 'crosshair'
     * ```
     */
    cursorOnMap?: string;
    /**
     * Delay to trigger a long-hover event when map has just moved (milliseconds).
     *
     * @remarks
     * Right after the map has moved, the first long-hover waits longer to prevent
     * unwanted hovers while panning the map. This improves UX by not showing
     * tooltips immediately after map movement.
     *
     * Should be higher than `longHoverDelayOnStillMapMS`.
     *
     * @default 800
     *
     * @example
     * ```typescript
     * // Default delay after map movement
     * longHoverDelayAfterMapMoveMS: 800
     *
     * // Faster for responsive UI
     * longHoverDelayAfterMapMoveMS: 500
     *
     * // Longer to avoid accidental triggers
     * longHoverDelayAfterMapMoveMS: 1200
     * ```
     */
    longHoverDelayAfterMapMoveMS?: number;
    /**
     * Delay to trigger a long-hover event when the map was still since the last long hover (milliseconds).
     *
     * @remarks
     * Once the map is stationary and the user is actively exploring, subsequent
     * long-hovers trigger faster for a more responsive experience.
     *
     * Should be lower than `longHoverDelayAfterMapMoveMS`.
     *
     * @default 300
     *
     * @example
     * ```typescript
     * // Default quick hover
     * longHoverDelayOnStillMapMS: 300
     *
     * // Instant hover
     * longHoverDelayOnStillMapMS: 100
     *
     * // Slower for less frequent updates
     * longHoverDelayOnStillMapMS: 500
     * ```
     */
    longHoverDelayOnStillMapMS?: number;
};

/**
 * Type representing valid font faces available in the TomTom map style.
 *
 * @remarks
 * Use this type to ensure type-safe font selection when working with text layers.
 * Restricts values to only the fonts available in the map style.
 *
 * @example
 * ```typescript
 * import type { MapFont } from '@tomtom-international/maps-sdk-js/map';
 *
 * function createTextLayer(font: MapFont) {
 *   return {
 *     type: 'symbol',
 *     layout: {
 *       'text-font': [font],
 *       'text-field': ['get', 'name']
 *     }
 *   };
 * }
 *
 * // Type-safe: only accepts valid map fonts
 * const layer = createTextLayer('Noto-Bold');
 * ```
 *
 * @group Map Style
 */
export declare type MapFont = (typeof mapFonts)[number];

/**
 * Array of all available font faces in the TomTom map style.
 *
 * @remarks
 * Contains all font variants available in the map style. Useful for font selection
 * or validation when creating custom layers.
 *
 * @example
 * ```typescript
 * import { mapFonts } from '@tomtom-international/maps-sdk-js/map';
 *
 * // Check if a font is available
 * if (mapFonts.includes('Noto-Bold')) {
 *   // Use the font
 * }
 *
 * // Use as fallback list
 * const textLayer = {
 *   type: 'symbol',
 *   layout: {
 *     'text-font': [...mapFonts]
 *   }
 * };
 * ```
 *
 * @group Map Style
 */
declare const mapFonts: readonly ["Noto-Regular", "NotoSans-MediumItalic", "Noto-Bold", "Noto-Medium"];

/**
 * MapLibre-specific options for advanced map configuration.
 *
 * Extends MapLibre GL JS MapOptions, excluding style and attribution control
 * which are handled by the TomTom SDK.
 *
 * @remarks
 * Includes options for:
 * - Initial viewport (center, zoom, bearing, pitch)
 * - Interaction controls (zoom, rotation, drag)
 * - Rendering options (antialiasing, terrain)
 * - Localization and accessibility
 *
 * @see [MapLibre MapOptions](https://maplibre.org/maplibre-gl-js-docs/api/map/)
 *
 * @group Map
 */
export declare type MapLibreOptions = Omit<MapOptions, 'style' | 'attributionControl'>;

/**
 * Whether a map module is based on a map style or on added GeoJSON data.
 * @ignore
 */
declare type MapModuleSource = 'style' | 'geojson';

/**
 * Known layer ID from the TomTom map style.
 *
 * @remarks
 * These are predefined layer IDs that exist in the TomTom vector map style.
 * Use these constants when you need to position custom layers relative to
 * standard map layers (e.g., placing a layer below labels).
 *
 * **Available Layer IDs include:**
 * - Label layers (e.g., `'lowestLabel'`, `'POI'`)
 * - Road layers (e.g., `'Road'`, `'Motorway'`)
 * - Building layers (e.g., `'Building'`)
 * - And many more defined in the style
 *
 * @example
 * ```typescript
 * // Add a custom layer below POI labels
 * const beforeLayer: MapStyleLayerID = 'POI';
 * map.addLayer({
 *   id: 'my-custom-layer',
 *   type: 'fill',
 *   source: 'my-source'
 * }, beforeLayer);
 *
 * // Position geometry below all labels
 * const geometryConfig = {
 *   beforeLayerConfig: 'lowestLabel' as MapStyleLayerID
 * };
 * ```
 *
 * @see {@link mapStyleLayerIDs} for the complete list of available layer IDs
 *
 * @group Shared
 */
export declare type MapStyleLayerID = keyof typeof mapStyleLayerIDs;

/**
 * Key layer IDs from the vector map style for positioning custom layers.
 *
 * @remarks
 * This constant provides reference layer IDs from TomTom's vector map styles that are used
 * as anchors when positioning custom layers in the map's layer stack. By referencing these
 * layer IDs, SDK modules and custom implementations can control where their layers appear
 * in the rendering order (visual stacking).
 *
 * **Understanding Layer Order:**
 *
 * "Lowest" refers to position in the layer stack, not physical elevation. Layers are rendered
 * from bottom to top - layers lower in the stack are drawn first and appear underneath layers
 * higher in the stack. When you add a layer "before" a reference layer, it's inserted lower
 * in the stack and will be drawn underneath that reference layer.
 *
 * **How SDK Modules Use These IDs:**
 *
 * **RoutingModule** - Positions route visualizations below labels for readability:
 * ```typescript
 * // Routes appear below labels but above the base map
 * const routing = await RoutingModule.get(map);
 * // Uses mapStyleLayerIDs.lowestLabel by default
 * ```
 *
 * **GeometriesModule** - Configurable layer positioning for polygon areas:
 * ```typescript
 * // Default: below labels
 * const geometries = await GeometriesModule.get(map);
 *
 * // Custom: below buildings to show at ground level
 * const geometries = await GeometriesModule.get(map, {
 *   beforeLayerConfig: 'lowestBuilding'
 * });
 *
 * // On top of everything
 * const geometries = await GeometriesModule.get(map, {
 *   beforeLayerConfig: 'top'
 * });
 * ```
 *
 * **Custom Layer Implementation:**
 * ```typescript
 * // Add a highlight layer below labels
 * map.addLayer({
 *   id: 'search-results',
 *   type: 'fill',
 *   source: 'results-source',
 *   paint: { 'fill-color': '#ffcc00', 'fill-opacity': 0.4 }
 * }, mapStyleLayerIDs.lowestLabel);
 * ```
 *
 * **Style Persistence:**
 *
 * These layer IDs remain consistent across TomTom map style changes (e.g., switching from
 * 'standardLight' to 'standardDark'). The SDK automatically repositions module layers using
 * the corresponding reference layers in the new style, maintaining the intended visual hierarchy.
 *
 * **Important Notes:**
 * - `lowestBuilding` is not available in the Satellite style
 * - If a reference layer doesn't exist, custom layers will be added on top of the style
 * - Both RoutingModule and GeometriesModule default to `lowestLabel` for optimal visibility
 *
 * @see {@link GeometryBeforeLayerConfig} for GeometriesModule layer positioning options
 * @see {@link RouteLayersConfig} for RoutingModule layer configuration
 *
 * @group Map Style
 */
export declare const mapStyleLayerIDs: {
    /**
     * Country name label layer.
     *
     * @remarks
     * Lower in the stack than most labels. Use to position elements below country
     * labels but above other map features.
     */
    readonly country: "Places - Country name";
    /**
     * The lowest layer for place labels.
     *
     * @remarks
     * Lower in the stack than city labels. Use to position content below all place
     * name labels while keeping it visible above geographic features.
     */
    readonly lowestPlaceLabel: "Places - Village / Hamlet";
    /**
     * Points of Interest layer.
     *
     * @remarks
     * Use to position custom content in the layer stack relative to POI icons and labels.
     */
    readonly poi: "POI";
    /**
     * The lowest labels layer in the stack.
     *
     * @remarks
     * **Most commonly used reference layer.** Positioning layers before this ensures
     * content appears below all text labels, maintaining map readability while keeping
     * visualizations prominent.
     *
     * **Default for SDK modules:**
     * - RoutingModule uses this for route lines and waypoints
     * - GeometriesModule uses this as the default for polygon fills and borders
     *
     * This provides optimal balance between visibility and not obscuring map labels.
     */
    readonly lowestLabel: "Borders - Treaty label";
    /**
     * The lowest road line layer in the stack.
     *
     * @remarks
     * Represents tunnel railway outlines. Use to position content below the road network,
     * useful for showing base layers or features that should appear beneath transportation
     * infrastructure.
     */
    readonly lowestRoadLine: "Tunnel - Railway outline";
    /**
     * The lowest building layer in the stack.
     *
     * @remarks
     * Use to position content below 3D building extrusions while keeping it above
     * flat map features like roads and terrain.
     *
     * **Note:** Not available in the Satellite style.
     */
    readonly lowestBuilding: "Buildings - Underground";
};

/**
 * Map style POI category type.
 *
 * @remarks
 * Represents all available POI (Point of Interest) categories used in the map style.
 * These categories correspond to Search API classification codes and are used for
 * filtering, styling, and displaying POI icons on the map.
 *
 * Each category maps to a specific icon sprite and can be used with custom icon configurations.
 *
 * @example
 * ```ts
 * const category: MapStylePOICategory = 'RESTAURANT';
 * ```
 *
 * @see {@link POICategoryGroup} - For grouped collections of related categories
 *
 * @group POIs
 */
export declare type MapStylePOICategory = keyof typeof mapDisplayPoiCategoryMappings;

/**
 * @group Routing
 */
export declare const MIDDLE_INDEX = "middle";

/**
 * @ignore
 */
export declare const MINOR_DELAY_LABEL_COLOR = "#f58240";

/**
 * @ignore
 */
export declare const MODERATE_DELAY_COLOR = "#FB2D09";

/**
 * @ignore
 */
export declare type MultiSyntaxFilter = {
    /**
     * Filter expression following the new expression syntax.
     */
    expression: ExpressionFilterSpecification;
    /**
     * Filter expression following the legacy syntax.
     */
    legacy: LegacyFilterSpecification;
};

/**
 * Properties to display a place on the map.
 *
 * Extends basic place information with display-specific properties needed
 * for rendering markers, icons, and labels on the map.
 *
 * @remarks
 * **Use Cases:**
 * - Search result markers
 * - POI markers
 * - Custom location pins
 * - EV charging station markers
 *
 * These properties control how the place appears visually on the map,
 * including its icon, label, and interactive states.
 *
 * @example
 * ```typescript
 * const locationProps: LocationDisplayProps = {
 *   id: 'place-123',
 *   title: 'Central Station',
 *   iconID: 'poi-transit',
 *   category: 'RAILWAY_STATION',
 *   eventState: 'hover'
 * };
 * ```
 *
 * @group Places
 */
export declare type PlaceDisplayProps = {
    /**
     * Unique identifier for the place feature.
     *
     * @remarks
     * Typically SDK features have IDs at the GeoJSON Feature root level, as per specification.
     * However, MapLibre does not reuse the given feature ID. Either we generate it on the fly
     * or use the one from properties via promotedId value.
     * We must generate "id" property based on the feature id on the fly in "prepareForDisplay" functions.
     *
     * Used for:
     * - Feature identification in events
     * - State management
     * - Data updates
     *
     * @example
     * ```typescript
     * id: 'place-123'
     * id: 'poi-456'
     * id: 1234  // Numeric IDs also supported
     * ```
     */
    id: string | number;
    /**
     * Display title for the place on the map.
     *
     * @remarks
     * Optional text label shown near the place marker. If not provided,
     * no text label will be displayed.
     *
     * **Common Sources:**
     * - POI name (e.g., "Starbucks")
     * - Address (e.g., "123 Main Street")
     * - Custom label (e.g., "Meeting Point")
     *
     * @example
     * ```typescript
     * title: 'Amsterdam Central Station'
     * title: 'Starbucks'
     * title: '123 Main Street'
     * title: undefined  // No label
     * ```
     */
    title?: string;
    /**
     * Icon ID referencing the map style sprite.
     *
     * @remarks
     * References an icon image in the map's sprite sheet. The icon must exist
     * in the map style or be added programmatically.
     *
     * **Icon Types:**
     * - Built-in POI icons (e.g., 'poi-restaurant', 'poi-hotel')
     * - Custom icons added to the sprite
     * - Pin/marker icons (e.g., 'pin-red', 'pin-blue')
     *
     * @example
     * ```typescript
     * iconID: 'poi-restaurant'
     * iconID: 'pin-red'
     * iconID: 'custom-marker'
     * ```
     */
    iconID: string;
    /**
     * Map-style-compatible display category, mostly applicable for base-map places.
     *
     * @remarks
     * Used to match the place with a POI category in the map style, enabling
     * category-specific styling and filtering.
     *
     * **Common Categories:**
     * - RESTAURANT
     * - HOTEL_MOTEL
     * - GAS_STATION
     * - PARKING_GARAGE
     * - SHOPPING
     *
     * Optional - only needed when using base-map styling or category-based filtering.
     *
     * @example
     * ```typescript
     * category: 'RESTAURANT'
     * category: 'HOTEL_MOTEL'
     * category: 'EV_CHARGING_STATION'
     * category: undefined  // No category association
     * ```
     */
    category?: string;
} & SupportsEvents & Anything;

/**
 * Configuration for place marker icons.
 *
 * Controls the visual appearance of place markers including custom icons.
 *
 * @example
 * ```typescript
 * // Custom icons for specific categories
 * const iconConfig: PlaceIconConfig = {
 *   categoryIcons: [
 *     { category: 'RESTAURANT', image: '/icons/food.png', pixelRatio: 2 },
 *     { category: 'HOTEL_MOTEL', image: '/icons/hotel.png', pixelRatio: 2 }
 *   ]
 * };
 * ```
 *
 * @group Places
 */
export declare type PlaceIconConfig = {
    /**
     * Configuration for the default place icon.
     * * The default icon is the one used for clicked locations and addresses without a specific category, or via custom mapping.
     */
    default?: DefaultPlaceIconConfig;
    /**
     * Array of custom icons for specific place categories.
     *
     * When provided, places matching these categories will use the custom icons
     * instead of the default style.
     */
    categoryIcons?: CustomImage<MapStylePOICategory>[];
    /**
     * Custom mapping function to generate the icon ID for a given place.
     *
     * @remarks
     * If provided, this function sets the iconID property on the place.
     * This allows for full control on how to determine which icon to use for each place based on its properties.
     *
     * @param place The place to generate the icon ID for.
     */
    mapping?: (place: Place) => string;
};

/**
 * @group Places
 */
export declare type PlaceLayerName = keyof PlaceLayersConfig;

/**
 * Configuration for custom place layer styling with MapLibre specifications.
 *
 * @remarks
 * Provides fine-grained control over place marker layers, allowing customization
 * of both the main place markers and highlighted/selected place markers.
 *
 * The layer IDs are derived from the PlacesModule instance prefix plus the key suffix:
 * - `main`: The primary layer for displaying all places
 * - `selected`: The layer for displaying highlighted/clicked places (rendered on top)
 *
 * All fields are optional. When a field is not provided, the default styling will be used.
 *
 * @example
 * ```typescript
 * const config: PlacesModuleConfig = {
 *   layers: {
 *     main: {
 *       layout: {
 *         'icon-size': 1.2,
 *         'text-size': 14
 *       },
 *       paint: {
 *         'text-color': '#333'
 *       }
 *     },
 *     selected: {
 *       layout: {
 *         'icon-size': 1.5,
 *         'text-allow-overlap': true
 *       },
 *       paint: {
 *         'text-color': '#3f9cd9'
 *       }
 *     }
 *   }
 * };
 * ```
 *
 * @group Places
 */
export declare type PlaceLayersConfig = {
    /**
     * Main place marker layer specification.
     *
     * @remarks
     * Controls the visual appearance of all place markers on the map.
     * This layer renders places that are not in a highlighted/selected state.
     */
    main?: Partial<ToBeAddedLayerSpecTemplate<SymbolLayerSpecification>>;
    /**
     * Selected place marker layer specification.
     *
     * @remarks
     * Controls the visual appearance of places when they are highlighted or selected
     * (e.g., on hover or click events). This layer is rendered on top of the main layer
     * to ensure selected places are always visible.
     *
     * This layer reacts to 'hover' and 'click' event states.
     */
    selected?: Partial<ToBeAddedLayerSpecTemplate<SymbolLayerSpecification>>;
} & HasAdditionalLayersConfig;

/**
 * Source identifier prefix for places (geocoding results) features.
 *
 * @remarks
 * Combined with a unique identifier to create source IDs for place markers
 * displayed via the Places module.
 *
 * @group Places
 */
export declare const PLACES_SOURCE_PREFIX_ID = "places";

/**
 * Map module for displaying and managing place markers.
 *
 * The PlacesModule provides functionality to display location markers (pins) on the map
 * for points of interest, search results, or custom locations. It supports various marker
 * styles, custom icons, text labels, and interactive events.
 *
 * @remarks
 * **Features:**
 * - Multiple marker styles (pin, circle, POI-like)
 * - Custom icons per POI category
 * - Text labels with styling options
 * - Data-driven styling via MapLibre expressions
 * - Interactive events (click, hover, etc.)
 * - Support for custom feature properties
 *
 * **Marker Styles:**
 * - `pin`: Traditional teardrop-shaped map pins
 * - `circle`: Simple circular markers
 * - `base-map`: Mimics built-in POI layer styling
 *
 * **Common Use Cases:**
 * - Search result visualization
 * - Custom location markers
 * - Store locators
 * - Delivery/pickup points
 * - Saved locations display
 *
 * @example
 * ```typescript
 * // Create places module with pin markers
 * const places = await PlacesModule.get(map, {
 *   icon: {
 *     categoryIcons: []
 *   },
 *   text: {
 *     field: (place) => place.properties.poi?.name || 'Unknown'
 *   },
 *   theme: 'pin'
 * });
 *
 * // Display places from search
 * await places.show(searchResults);
 *
 * // Handle clicks
 * places.events.on('click', (feature) => {
 *   console.log('Clicked:', feature.properties);
 * });
 *
 * places.events.on('hover', (feature) => {
 *   showTooltip(feature.properties.poi?.name);
 * });
 * ```
 *
 * @see [Places Guide](https://docs.tomtom.com/maps-sdk-js/guides/map/places)
 *
 * @group Places
 */
export declare class PlacesModule extends AbstractMapModule<PlacesSourcesAndLayers, PlacesModuleConfig> {
    private static lastInstanceIndex;
    private layerSpecs;
    private sourceID;
    private layerIDPrefix;
    /**
     * The index of this instance, to generate unique source and layer IDs.
     * * Starts with 0 and each instance increments it by one.
     * @private
     */
    private instanceIndex;
    private defaultPlaceIconID;
    /**
     * Make sure the map is ready before create an instance of the module and any other interaction with the map
     * @param tomtomMap The TomTomMap instance.
     * @param config  The module optional configuration
     * @returns {Promise} Returns a promise with a new instance of this module
     */
    static get(tomtomMap: TomTomMap, config?: PlacesModuleConfig): Promise<PlacesModule>;
    private constructor();
    /**
     * @ignore
     */
    protected _initSourcesWithLayers(config?: PlacesModuleConfig, restore?: boolean): PlacesSourcesAndLayers;
    private buildLayerSpecs;
    /**
     * @ignore
     */
    protected _applyConfig(config: PlacesModuleConfig | undefined): PlacesModuleConfig | undefined;
    /**
     * @ignore
     */
    protected restoreDataAndConfigImpl(): void;
    /**
     * Updates the visual theme for displayed places.
     *
     * @param theme - The theme style to apply to place markers.
     *
     * @remarks
     * **Available Themes:**
     * - `pin`: Traditional teardrop-shaped map pins
     * - `circle`: Simple circular markers
     * - `base-map`: Mimics the map's built-in POI layer style with category icons
     *
     * Changes apply immediately to all currently shown places. Other configuration
     * properties (icon config, text config) remain unchanged.
     *
     * @example
     * ```typescript
     * // Switch to pin markers
     * places.applyTheme('pin');
     *
     * // Use simple circles
     * places.applyTheme('circle');
     *
     * // Match map's POI style (ideal to blend in)
     * places.applyTheme('base-map');
     * ```
     */
    applyTheme(theme: PlacesTheme): void;
    /**
     * Updates the icon configuration for displayed places.
     *
     * @param iconConfig - New icon configuration settings.
     *
     * @remarks
     * - Changes apply immediately to currently shown places
     * - Custom icons are loaded if not already in style
     * - Other configuration properties remain unchanged
     *
     * @example
     * ```typescript
     * places.applyIconConfig({
     *   categoryIcons: [
     *     { category: 'RESTAURANT', id: 'restaurant-icon', image: '/icons/food.png' }
     *   ]
     * });
     * ```
     */
    applyIconConfig(iconConfig: PlaceIconConfig): void;
    /**
     * Updates the text/label configuration for displayed places.
     *
     * @param textConfig - New text configuration settings.
     *
     * @remarks
     * Supports both functions and MapLibre expressions for dynamic text.
     *
     * @example
     * ```typescript
     * // Use function
     * places.applyTextConfig({
     *   field: (place) => place.properties.poi?.name || 'Unknown'
     * });
     *
     * // Use MapLibre expression
     * places.applyTextConfig({
     *   field: ['get', 'title'],
     *   size: 14,
     *   color: '#333'
     * });
     * ```
     */
    applyTextConfig(textConfig: PlaceTextConfig): void;
    private applyConfigPart;
    /**
     * Applies additional feature properties to displayed places.
     *
     * @param extraFeatureProps - Object mapping property names to values or functions.
     *
     * @remarks
     * Useful for adding computed properties or metadata for styling/filtering.
     *
     * @example
     * ```typescript
     * places.applyExtraFeatureProps({
     *   category: (place) => place.properties.poi?.categories?.[0],
     *   rating: (place) => place.properties.poi?.rating || 0,
     *   isOpen: true
     * });
     * ```
     */
    applyExtraFeatureProps(extraFeatureProps: {
        [key: string]: any;
    }): void;
    private updateLayersAndData;
    private setupImages;
    private updateData;
    /**
     * Displays the given places on the map.
     *
     * @param places - Place data to display. Can be a single Place, array of Places,
     * or a Places FeatureCollection.
     *
     * @remarks
     * **Behavior:**
     * - Replaces any previously shown places
     * - Applies current module styling configuration
     * - Automatically generates labels if text config is set
     * - Waits for module to be ready before displaying
     *
     * **Data Sources:**
     * - TomTom Search API results
     * - Custom place objects matching the Place interface
     * - GeoJSON Point features
     *
     * @example
     * Display search results:
     * ```typescript
     * import { search } from '@tomtom-international/maps-sdk-js/services';
     *
     * const results = await search.search({ query: 'coffee' });
     * await places.show(results.results);
     * ```
     *
     * @example
     * Display single place:
     * ```typescript
     * await places.show({
     *   type: 'Feature',
     *   geometry: { type: 'Point', coordinates: [4.9041, 52.3676] },
     *   properties: {
     *     address: { freeformAddress: 'Amsterdam' },
     *     poi: { name: 'Amsterdam Central' }
     *   }
     * });
     * ```
     *
     * @example
     * Display multiple places:
     * ```typescript
     * await places.show([place1, place2, place3]);
     * ```
     */
    show(places: Place_2 | Place_2[] | Places): Promise<void>;
    /**
     * Removes all places from the map.
     *
     * @remarks
     * - Clears all displayed places
     * - Does not reset styling configuration
     * - Module remains initialized and ready for new data
     *
     * @example
     * ```typescript
     * await places.clear();
     * ```
     */
    clear(): Promise<void>;
    /**
     * Programmatically sets an event state on a specific place.
     *
     * @param options - Configuration for the event state to apply.
     *
     * @remarks
     * Use this to make places appear clicked or hovered programmatically.
     *
     * @example
     * ```typescript
     * // Make first place appear clicked
     * places.putEventState({
     *   index: 0,
     *   state: 'click',
     *   mode: 'put'
     * });
     * ```
     */
    putEventState(options: PutEventStateOptions): void;
    /**
     * Removes an event state from a specific place.
     *
     * @param options - Configuration for which event state to remove.
     *
     * @example
     * ```typescript
     * places.cleanEventState({ index: 0 });
     * ```
     */
    cleanEventState(options: CleanEventStateOptions): void;
    /**
     * Removes event states from multiple places.
     *
     * @param options - Optional filter for which states to remove.
     *
     * @example
     * ```typescript
     * // Remove all event states
     * places.cleanEventStates();
     *
     * // Remove only hover states
     * places.cleanEventStates({ states: ['hover'] });
     * ```
     */
    cleanEventStates(options?: CleanEventStatesOptions): void;
    /**
     * Create the events on/off for this module
     * @returns An instance of EventsModule
     */
    get events(): EventsModule<Place_2<DisplayPlaceProps>>;
}

/**
 * Configuration options for the PlacesModule.
 *
 * Controls the appearance and behavior of place markers and labels displayed on the map.
 *
 * @example
 * ```typescript
 * // Basic configuration
 * const config: PlacesModuleConfig = {
 *   icon: {
 *     style: 'pin'
 *   },
 *   text: {
 *     field: (place) => place.properties.poi?.name || 'Unknown',
 *     size: 12
 *   }
 * };
 *
 * // Advanced configuration with custom properties
 * const config: PlacesModuleConfig = {
 *   icon: {
 *     style: 'base-map',
 *     categoryIcons: [
 *       { category: 'RESTAURANT', image: '/icons/restaurant.png' }
 *     ]
 *   },
 *   text: {
 *     field: ['get', 'title'],
 *     size: 14,
 *     color: '#333',
 *     haloColor: '#fff',
 *     haloWidth: 2
 *   },
 *   extraFeatureProps: {
 *     category: (place) => place.properties.poi?.categories?.[0],
 *     hasParking: (place) => place.properties.poi?.name?.includes('parking')
 *   }
 * };
 * ```
 *
 * @group Places
 */
export declare type PlacesModuleConfig = {
    /**
     * Base style for all places.
     *
     * @remarks
     * Can be overwritten by more advanced icon configurations.
     *
     * @default 'pin'
     */
    theme?: PlacesTheme;
    /**
     * Icon appearance configuration.
     *
     * Controls marker style and custom icons for different place categories.
     */
    icon?: PlaceIconConfig;
    /**
     * Text label configuration.
     *
     * Controls label content, styling, and positioning.
     */
    text?: PlaceTextConfig;
    /**
     * Custom layer styling configuration.
     *
     * @remarks
     * * Overrides the default layer styling with custom specifications.
     * * You must provide complete layer specifications for any layers you wish to customize.
     * * You can still reuse the default configurations if you want incremental changes. See: buildPlacesLayerSpecs.
     * * Any layer not specified will continue to use its default styling.
     * * Use this only if you need fine MapLibre control on how places are displayed.
     */
    layers?: PlaceLayersConfig;
    /**
     * Additional properties to compute for each place feature.
     *
     * These properties are added to the feature and can be used in styling expressions
     * or event handlers. Values can be static or computed from place data.
     *
     * @remarks
     * Useful for:
     * - Adding computed flags for conditional styling via 'layers' config.
     * - Extracting nested properties for easier access
     * - Adding business logic properties
     *
     * @example
     * ```typescript
     * extraFeatureProps: {
     *   // Static property
     *   source: 'search-results',
     *
     *   // Computed property
     *   category: (place) => place.properties.poi?.categories?.[0],
     *   rating: (place) => place.properties.poi?.rating || 0,
     *   hasOpeningHours: (place) => !!place.properties.poi?.openingHours,
     *
     *   // Complex computation
     *   distanceFromCenter: (place) => {
     *     const coords = place.geometry.coordinates;
     *     return Math.sqrt(Math.pow(coords[0] - 4.9, 2) + Math.pow(coords[1] - 52.3, 2));
     *   }
     * }
     * ```
     */
    extraFeatureProps?: {
        [key: string]: ((place: Place) => any) | any;
    };
};

declare type PlacesSourcesAndLayers = {
    /**
     * Places source id with corresponding layers ids.
     */
    places: GeoJSONSourceWithLayers<Places<DisplayPlaceProps>>;
};

/**
 * Icon style options for displaying places on the map.
 *
 * @remarks
 * **Available Styles:**
 * - `pin`: Traditional map pin markers (teardrop shape)
 * - `circle`: Simple circular markers
 * - `base-map`: Mimics the map's built-in POI layer style with category icons
 *
 * @group Places
 */
export declare type PlacesTheme = 'pin' | 'circle' | 'base-map';

/**
 * Configuration for place text labels.
 *
 * Controls how text labels are displayed next to place markers, including
 * content, styling, and positioning.
 *
 * @remarks
 * All text properties support both functions (for dynamic values) and MapLibre
 * expressions (for data-driven styling).
 *
 * @example
 * ```typescript
 * // Simple text from place name
 * const textConfig: PlaceTextConfig = {
 *   field: (place) => place.properties.poi?.name || place.properties.address.freeformAddress
 * };
 *
 * // Using MapLibre expression with styling
 * const textConfig: PlaceTextConfig = {
 *   field: ['get', 'title'],
 *   size: 14,
 *   color: '#333',
 *   haloColor: '#fff',
 *   haloWidth: 2
 * };
 * ```
 *
 * @group Places
 */
export declare type PlaceTextConfig = {
    /**
     * Text content for the label.
     *
     * Can be a function that extracts text from the place properties (data-based),
     * or a MapLibre expression for data-driven content (data-driven layer-based).
     *
     * @example
     * ```typescript
     * // Function
     * title: (place) => place.properties.poi?.name || 'Unknown'
     *
     * // MapLibre expression
     * title: ['get', 'title']
     *
     * // Conditional expression
     * title: ['case', ['has', 'name'], ['get', 'name'], ['get', 'address']]
     * ```
     *
     * @see https://maplibre.org/maplibre-style-spec/types/#formatted
     */
    title?: ((place: Place) => string) | DataDrivenPropertyValueSpecification<string>;
    /**
     * Font size in pixels.
     *
     * @default 12
     *
     * @example
     * ```typescript
     * size: 14
     *
     * // Data-driven size based on importance
     * size: ['interpolate', ['linear'], ['get', 'priority'], 1, 16, 10, 10]
     * ```
     */
    size?: DataDrivenPropertyValueSpecification<number>;
    /**
     * Text color.
     *
     * @default '#000000'
     *
     * @example
     * ```typescript
     * color: '#333333'
     *
     * // Category-based colors
     * color: ['match', ['get', 'category'], 'RESTAURANT', '#D32F2F', '#1976D2']
     * ```
     */
    color?: DataDrivenPropertyValueSpecification<string>;
    /**
     * Font face(s) to use for the text.
     *
     * @example
     * ```typescript
     * font: ['Open Sans Bold', 'Arial Unicode MS Bold']
     * ```
     */
    font?: DataDrivenPropertyValueSpecification<Array<MapFont>>;
    /**
     * Text halo (outline) color for better readability.
     *
     * @default '#FFFFFF'
     *
     * @example
     * ```typescript
     * haloColor: '#fff'
     * ```
     */
    haloColor?: DataDrivenPropertyValueSpecification<string>;
    /**
     * Text halo (outline) width in pixels.
     *
     * @default 1
     *
     * @example
     * ```typescript
     * haloWidth: 2  // Thicker outline for better contrast
     * ```
     */
    haloWidth?: DataDrivenPropertyValueSpecification<number>;
    /**
     * Text offset from the icon in ems [x, y].
     *
     * Positive x moves right, positive y moves down.
     *
     * @default [0, 0]
     *
     * @example
     * ```typescript
     * offset: [0, 1.5]  // Position text below icon
     *
     * offset: [1, 0]  // Position text to the right
     * ```
     */
    offset?: DataDrivenPropertyValueSpecification<[number, number]>;
};

/**
 * Waypoint or placeholder for route planning.
 *
 * Represents a point along a route, which can be a full waypoint with position
 * and properties, or `null` for placeholder positions (e.g., unset waypoints in
 * a multi-stop route planner UI).
 *
 * @remarks
 * **Use Cases:**
 * - Route planning interfaces with add/remove waypoint functionality
 * - Multi-stop delivery route optimization
 * - Placeholder slots in waypoint arrays
 * - Optional intermediate stops
 *
 * **Waypoint Types:**
 * - `WaypointLike`: Full waypoint with coordinates and optional properties
 * - `null`: Placeholder for unset or removed waypoints
 *
 * @example
 * ```typescript
 * // Array of waypoints with some unset
 * const waypoints: PlanningWaypoint[] = [
 *   { type: 'Feature', geometry: { type: 'Point', coordinates: [4.9, 52.3] } },
 *   null,  // Empty slot for user to add waypoint
 *   { type: 'Feature', geometry: { type: 'Point', coordinates: [4.5, 51.9] } }
 * ];
 *
 * // Filter out null waypoints before routing
 * const validWaypoints = waypoints.filter(w => w !== null);
 * ```
 *
 * @group Routing
 */
export declare type PlanningWaypoint = WaypointLike | null;

/**
 * Source identifier for POI (Point of Interest) vector tiles.
 *
 * @remarks
 * Used to reference the POI layer in the map style, which contains
 * business locations, landmarks, and other points of interest.
 *
 * @group POIs
 */
export declare const POI_SOURCE_ID = "vectorTiles";

/**
 * POI category group type.
 *
 * @remarks
 * Represents predefined groups of related POI categories for convenient filtering.
 * Each group contains multiple {@link MapStylePOICategory} values that share a common theme.
 *
 * Using category groups simplifies filtering by allowing you to show or hide
 * multiple related POI types with a single filter value.
 *
 * **Available groups:**
 * - `FOOD_DRINKS_GROUP` - Restaurants, cafes, fast food, wineries, etc.
 * - `SHOPPING_GROUP` - Stores, malls, markets, supermarkets, etc.
 * - `TRANSPORTATION_GROUP` - Airports, train stations, bus stops, ferry terminals, etc.
 * - `HEALTH_GROUP` - Hospitals, clinics, pharmacies, doctors, dentists, etc.
 * - `PARKING_GROUP` - Parking garages and open parking areas
 * - `HOLIDAY_TOURISM_GROUP` - Tourist attractions, museums, beaches, scenic views, etc.
 * - `EV_CHARGING_STATIONS_GROUP` - Electric vehicle charging stations
 * - `GAS_STATIONS_GROUP` - Gas and petrol stations
 * - `ACCOMMODATION_GROUP` - Hotels, motels, camping grounds, etc.
 * - `ENTERTAINMENT_GROUP` - Cinemas, theaters, nightlife, casinos, etc.
 * - `SPORTS_LEISURE_GROUP` - Stadiums, sports centers, swimming pools, golf courses, etc.
 * - `EDUCATION_GROUP` - Schools, universities, libraries, cultural centers
 * - `GOVERNMENT_GROUP` - Government offices, courthouses, embassies, police, fire stations
 *
 * @example
 * Filter to show only food-related POIs:
 * ```ts
 * poisModule.configure({
 *   categoryFilter: {
 *     mode: 'show',
 *     values: ['FOOD_DRINKS_GROUP']
 *   }
 * });
 * ```
 *
 * @example
 * Hide parking and gas stations:
 * ```ts
 * poisModule.configure({
 *   categoryFilter: {
 *     mode: 'hide',
 *     values: ['PARKING_GROUP', 'GAS_STATIONS_GROUP']
 *   }
 * });
 * ```
 *
 * @example
 * Combine multiple groups for tourism use case:
 * ```ts
 * const tourismFilter = {
 *   mode: 'show',
 *   values: [
 *     'HOLIDAY_TOURISM_GROUP',
 *     'ACCOMMODATION_GROUP',
 *     'FOOD_DRINKS_GROUP',
 *     'ENTERTAINMENT_GROUP'
 *   ]
 * };
 * ```
 *
 * @see {@link poiCategoryGroups} - The object containing all group definitions
 * @see {@link MapStylePOICategory} - For individual POI categories
 *
 * @group POIs
 */
export declare type POICategoryGroup = keyof typeof poiCategoryGroups;

/**
 * Predefined groups of related POI categories for convenient filtering.
 *
 * @remarks
 * This object maps group names to arrays of {@link MapStylePOICategory} values.
 * Each group contains POI categories that share a common theme or purpose,
 * making it easier to filter multiple related POI types with a single identifier.
 *
 * **Available Groups:**
 * - `FOOD_DRINKS_GROUP` - Dining and beverage establishments (restaurants, cafes, pubs, etc.)
 * - `SHOPPING_GROUP` - Retail stores and shopping centers (shops, markets, supermarkets, etc.)
 * - `TRANSPORTATION_GROUP` - Transportation hubs and stops (airports, stations, terminals, etc.)
 * - `HEALTH_GROUP` - Healthcare facilities and services (hospitals, clinics, pharmacies, etc.)
 * - `PARKING_GROUP` - Parking facilities (garages and open parking areas)
 * - `HOLIDAY_TOURISM_GROUP` - Tourist attractions and recreational sites (museums, parks, beaches, etc.)
 * - `EV_CHARGING_STATIONS_GROUP` - Electric vehicle charging locations
 * - `GAS_STATIONS_GROUP` - Fuel stations for traditional vehicles
 * - `ACCOMMODATION_GROUP` - Lodging facilities (hotels, motels, camping grounds, etc.)
 * - `ENTERTAINMENT_GROUP` - Entertainment venues (cinemas, theaters, nightlife, casinos, etc.)
 * - `SPORTS_LEISURE_GROUP` - Sports and leisure facilities (stadiums, gyms, pools, golf courses, etc.)
 * - `EDUCATION_GROUP` - Educational institutions (schools, universities, libraries, etc.)
 * - `GOVERNMENT_GROUP` - Government and public safety facilities (offices, courts, embassies, police, fire stations)
 *
 * @example
 * Filter to show only food-related POIs:
 * ```ts
 * import { poiCategoryGroups } from '@tomtom-international/maps-sdk-js/map';
 *
 * const foodCategories = poiCategoryGroups.FOOD_DRINKS_GROUP;
 * console.log(foodCategories);
 * // ['RESTAURANT', 'FAST_FOOD', 'CAFE_PUB', 'PUB', 'WINERY', ...]
 * ```
 *
 * @example
 * Use with POI module filtering:
 * ```ts
 * poisModule.configure({
 *   categoryFilter: {
 *     mode: 'show',
 *     values: ['FOOD_DRINKS_GROUP', 'ENTERTAINMENT_GROUP']
 *   }
 * });
 * ```
 *
 * @see {@link POICategoryGroup} - Type representing all available group names
 * @see {@link MapStylePOICategory} - Individual POI category identifiers
 *
 * @group POIs
 */
export declare const poiCategoryGroups: Record<string, MapStylePOICategory[]>;

/**
 * Layer IDs for POIs on the map.
 * @ignore
 */
export declare const poiLayerIDs: string[];

/**
 * POIs Module for controlling Points of Interest displayed in the map style.
 *
 * This module manages the built-in POI layer from the vector map, allowing you to
 * show/hide POIs and filter them by category. POIs are already part of the map style
 * and include businesses, landmarks, and other points of interest.
 *
 * @remarks
 * **Features:**
 * - Toggle POI visibility on/off
 * - Filter by POI categories or category groups
 * - Event handling for POI interactions
 * - Based on vector tile data in the map style
 *
 * **POI Categories:**
 * - Individual categories (e.g., RESTAURANT, HOTEL_MOTEL, PARKING_GARAGE)
 * - Category groups (e.g., FOOD_DRINKS_GROUP, SHOPPING_GROUP, TRANSPORTATION_GROUP)
 *
 * **Difference from PlacesModule:**
 * - POIsModule: Controls existing POIs in the map style
 * - PlacesModule: Displays custom place data from Search API or other sources
 *
 * @example
 * Basic usage:
 * ```typescript
 * import { POIsModule } from '@tomtom-international/maps-sdk-js/map';
 *
 * // Get module
 * const pois = await POIsModule.get(map);
 *
 * // Toggle visibility
 * pois.setVisible(false);
 * pois.setVisible(true);
 * ```
 *
 * @example
 * Filter specific categories:
 * ```typescript
 * // Show only restaurants and hotels
 * pois.filterCategories({
 *   show: 'only',
 *   values: ['RESTAURANT', 'HOTEL_MOTEL']
 * });
 *
 * // Hide parking garages
 * pois.filterCategories({
 *   show: 'all_except',
 *   values: ['PARKING_GARAGE', 'OPEN_PARKING_AREA']
 * });
 * ```
 *
 * @example
 * Filter using category groups:
 * ```typescript
 * // Show only food and shopping POIs
 * pois.filterCategories({
 *   show: 'only',
 *   values: ['FOOD_DRINKS_GROUP', 'SHOPPING_GROUP']
 * });
 *
 * // Hide transportation POIs
 * pois.filterCategories({
 *   show: 'all_except',
 *   values: ['TRANSPORTATION_GROUP']
 * });
 * ```
 *
 * @example
 * Event handling:
 * ```typescript
 * pois.events.on('click', (feature, lngLat) => {
 *   console.log('Clicked POI:', feature.properties.name);
 *   console.log('Category:', feature.properties.category);
 * });
 * ```
 *
 * @see [POIs Guide](https://docs.tomtom.com/maps-sdk-js/guides/map/pois)
 *
 * @group POIs
 */
export declare class POIsModule extends AbstractMapModule<PoIsSourcesAndLayers, POIsModuleConfig> {
    private categoriesFilter?;
    private originalFilter?;
    /**
     * Retrieves a POIsModule instance for the given map.
     *
     * @param map - The TomTomMap instance to attach this module to.
     * @param config - Optional initial configuration for visibility and filters.
     *
     * @returns A promise that resolves to the initialized POIsModule.
     *
     * @remarks
     * **Configuration:**
     * - `visible`: Initial visibility state
     * - `filters.categories`: Category filter to apply on initialization
     *
     * @throws Error if the POI source is not found in the map style
     *
     * @example
     * Default initialization:
     * ```typescript
     * const pois = await POIsModule.get(map);
     * ```
     *
     * @example
     * With initial filter:
     * ```typescript
     * const pois = await POIsModule.get(map, {
     *   visible: true,
     *   filters: {
     *     categories: {
     *       show: 'only',
     *       values: ['RESTAURANT', 'CAFE_PUB']
     *     }
     *   }
     * });
     * ```
     */
    static get(map: TomTomMap, config?: POIsModuleConfig): Promise<POIsModule>;
    private constructor();
    /**
     * @ignore
     */
    protected _initSourcesWithLayers(): {
        poi: StyleSourceWithLayers<SourceSpecification, Source>;
    };
    /**
     * @ignore
     */
    protected _applyConfig(config: POIsModuleConfig | undefined): POIsModuleConfig | undefined;
    /**
     * Checks if POI layers are currently visible.
     *
     * @returns `true` if at least one POI layer is visible, `false` if all are hidden.
     *
     * @example
     * ```typescript
     * if (pois.isVisible()) {
     *   console.log('POIs are displayed');
     * }
     * ```
     */
    isVisible(): boolean;
    /**
     * Sets the visibility of POI layers.
     *
     * @param visible - `true` to show POIs, `false` to hide them.
     *
     * @remarks
     * Changes are applied immediately if the map is ready.
     *
     * @example
     * ```typescript
     * pois.setVisible(false); // Hide all POIs
     * pois.setVisible(true);  // Show all POIs
     * ```
     */
    setVisible(visible: boolean): void;
    /**
     * Filters POIs by category or category group.
     *
     * @param categoriesFilter - Filter configuration specifying which categories to show/hide.
     * Pass `undefined` to reset to default (show all).
     *
     * @remarks
     * **Filter Modes:**
     * - `only`: Show only the specified categories, hide all others
     * - `all_except`: Show all categories except the specified ones
     *
     * **Category Types:**
     * - Individual categories (e.g., 'RESTAURANT', 'HOTEL_MOTEL')
     * - Category groups (e.g., 'FOOD_DRINKS_GROUP', 'SHOPPING_GROUP')
     *
     * **Available Category Groups:**
     * - FOOD_DRINKS_GROUP
     * - SHOPPING_GROUP
     * - TRANSPORTATION_GROUP
     * - HEALTH_GROUP
     * - PARKING_GROUP
     * - HOLIDAY_TOURISM_GROUP
     * - EV_CHARGING_STATIONS_GROUP
     * - GAS_STATIONS_GROUP
     * - ACCOMMODATION_GROUP
     * - ENTERTAINMENT_GROUP
     * - SPORTS_LEISURE_GROUP
     * - EDUCATION_GROUP
     * - GOVERNMENT_GROUP
     *
     * @example
     * Show only restaurants:
     * ```typescript
     * pois.filterCategories({
     *   show: 'only',
     *   values: ['RESTAURANT']
     * });
     * ```
     *
     * @example
     * Hide parking:
     * ```typescript
     * pois.filterCategories({
     *   show: 'all_except',
     *   values: ['PARKING_GROUP']
     * });
     * ```
     *
     * @example
     * Reset filter (show all):
     * ```typescript
     * pois.filterCategories(undefined);
     * ```
     */
    filterCategories(categoriesFilter?: ValuesFilter<FilterablePOICategory> | undefined): void;
    /**
     * Gets the events interface for handling user interactions with POIs.
     *
     * @returns An EventsModule instance for registering event handlers.
     *
     * @remarks
     * **Supported Events:**
     * - `click`: User clicks on a POI
     * - `contextmenu`: User right-clicks on a POI
     * - `hover`: Mouse enters a POI
     * - `long-hover`: Mouse hovers over POI for extended time
     *
     * **Event Feature Properties:**
     * - `id`: Unique POI identifier
     * - `name`: POI name in native language
     * - `category`: POI category
     * - `iconID`: Icon sprite ID
     * - `group`: Category group
     * - `priority`: Importance level (lower = more important)
     *
     * @example
     * ```typescript
     * pois.events.on('click', (feature, lngLat) => {
     *   console.log('POI:', feature.properties.name);
     *   console.log('Category:', feature.properties.category);
     *   console.log('ID:', feature.properties.id);
     * });
     *
     * pois.events.on('hover', (feature) => {
     *   showTooltip(feature.properties.name);
     * });
     * ```
     */
    get events(): EventsModule<POIsModuleFeature>;
}

/**
 * Configuration options for the POIsModule.
 *
 * Controls visibility and filtering of Points of Interest displayed in the map style.
 *
 * @remarks
 * POIs are part of the base map vector tiles and include businesses, landmarks,
 * and other points of interest. This configuration allows you to control which
 * categories are visible.
 *
 * @example
 * ```typescript
 * // Show only restaurants
 * const config: POIsModuleConfig = {
 *   visible: true,
 *   filters: {
 *     categories: {
 *       show: 'only',
 *       values: ['RESTAURANT']
 *     }
 *   }
 * };
 *
 * // Hide parking-related POIs
 * const noParkingConfig: POIsModuleConfig = {
 *   filters: {
 *     categories: {
 *       show: 'all_except',
 *       values: ['PARKING_GROUP']
 *     }
 *   }
 * };
 *
 * // Show only food and shopping
 * const limitedConfig: POIsModuleConfig = {
 *   filters: {
 *     categories: {
 *       show: 'only',
 *       values: ['FOOD_DRINKS_GROUP', 'SHOPPING_GROUP']
 *     }
 *   }
 * };
 * ```
 *
 * @group POIs
 */
export declare type POIsModuleConfig = {
    /**
     * Controls the visibility of the POI layers.
     *
     * @default true
     */
    visible?: boolean;
    /**
     * Optional filters for controlling which POI categories are displayed.
     *
     * @remarks
     * If omitted, all POI categories are displayed by default.
     */
    filters?: {
        /**
         * Category filter configuration.
         *
         * @remarks
         * By default, all categories are included in the map.
         * - Use `all_except` show mode to hide some categories/groups
         * - Use `only` mode to show only specific categories/groups and hide everything else
         *
         * @example
         * ```typescript
         * // Show only restaurants and hotels
         * categories: {
         *   show: 'only',
         *   values: ['RESTAURANT', 'HOTEL_MOTEL']
         * }
         *
         * // Hide parking
         * categories: {
         *   show: 'all_except',
         *   values: ['PARKING_GARAGE', 'OPEN_PARKING_AREA']
         * }
         *
         * // Show only food-related POIs
         * categories: {
         *   show: 'only',
         *   values: ['FOOD_DRINKS_GROUP']
         * }
         * ```
         */
        categories: ValuesFilter<FilterablePOICategory>;
    };
};

/**
 * A GeoJSON feature representing a POI from the vector tile map.
 *
 * Contains properties specific to Points of Interest including unique identifiers,
 * names, categories, and styling information.
 *
 * @remarks
 * These features are returned when interacting with POI layers through events
 * (click, hover, etc.) on the POIsModule.
 *
 * @example
 * ```typescript
 * poisModule.events.on('click', (feature: POIsModuleFeature) => {
 *   console.log('POI Name:', feature.properties.name);
 *   console.log('Category:', feature.properties.category);
 *   console.log('POI ID:', feature.properties.id);
 * });
 * ```
 *
 * @group POIs
 */
export declare type POIsModuleFeature = Omit<MapGeoJSONFeature, 'properties'> & {
    /**
     * POI-specific properties from the vector tile.
     */
    properties: {
        /**
         * A unique Point of Interest identifier.
         *
         * @remarks
         * This ID can be used across other TomTom services to fetch additional
         * information about the POI (e.g., via Place by ID service).
         *
         * @example '528009002822995'
         */
        id: string;
        /**
         * Feature name in the native language.
         *
         * @remarks
         * Displayed in NGT (Neutral Ground Truth) language, which is the native
         * language of each country respectively.
         *
         * @example 'Starbucks'
         */
        name: string;
        /**
         * POI category identifier.
         *
         * @remarks
         * Used for styling and filtering purposes. Maps to a specific POI type
         * (e.g., RESTAURANT, HOTEL_MOTEL).
         *
         * @example 'RESTAURANT'
         */
        category: string;
        /**
         * Sprite image ID for this POI's icon.
         *
         * @remarks
         * References an image within the map style's sprite sheet used to
         * render the POI icon on the map.
         *
         * @example 'restaurant-15'
         */
        iconID: string;
        /**
         * Broad category group this POI belongs to.
         *
         * @remarks
         * Groups similar categories together for easier filtering and styling
         * (e.g., 'Food & Drink', 'Shopping', 'Transportation').
         *
         * @example 'Food & Drink'
         */
        group: string;
        /**
         * Display priority of the POI.
         *
         * @remarks
         * Lower values indicate higher importance. Used by the map renderer to
         * determine which POIs to show when space is limited.
         *
         * @example 1 // High priority, 10 // Low priority
         */
        priority: number;
    };
};

/**
 * IDs of sources and layers for places of interest module.
 */
declare type PoIsSourcesAndLayers = {
    /**
     * Places of interest with corresponding layer ids.
     * TODO: technically source ID is vectorTiles if POIs stay included in base map for Orbis
     */
    poi: StyleSourceWithLayers;
};

/**
 * prepare places features to be displayed on map by adding needed  properties for title, icon and style
 * @ignore
 */
export declare const preparePlacesForDisplay: (placesInput: Place | Place[] | Places_2, instanceIndex: number, config?: PlacesModuleConfig) => Places_2<DisplayPlaceProps>;

/**
 * Parameters to update the event state of a feature programmatically.
 *
 * Allows you to manually set event states on features, useful for:
 * - Programmatic selection/highlighting
 * - Keyboard navigation
 * - External state synchronization
 * - Testing and automation
 *
 * @example
 * ```typescript
 * // Select a feature programmatically
 * const options: PutEventStateOptions = {
 *   index: 0,
 *   state: 'click',
 *   mode: 'put',  // Remove click state from other features
 *   show: true
 * };
 *
 * // Add hover state without affecting others
 * const hoverOptions: PutEventStateOptions = {
 *   index: 2,
 *   state: 'hover',
 *   mode: 'add',  // Keep other hover states
 *   show: true
 * };
 * ```
 *
 * @group User Events
 */
export declare type PutEventStateOptions = ByIdOrIndex & {
    /**
     * The event state to set.
     *
     * @remarks
     * Can be any supported event type: 'click', 'contextmenu', 'hover', or 'long-hover'.
     */
    state: EventType;
    /**
     * Whether to replace or add to existing event states.
     *
     * @remarks
     * - `put`: Set the event state on this feature and remove it from all others (default)
     * - `add`: Set the event state on this feature while preserving states on other features
     *
     * @default 'put'
     *
     * @example
     * ```typescript
     * // Exclusive selection (only one can be clicked at a time)
     * mode: 'put'
     *
     * // Multiple selection (keep existing selections)
     * mode: 'add'
     * ```
     */
    mode?: 'put' | 'add';
    /**
     * Whether to show the feature after updating the event state.
     *
     * @remarks
     * Set to false only if you want to make multiple state changes before
     * rendering, which can improve performance for batch updates.
     *
     * @default true
     *
     * @example
     * ```typescript
     * // Update and render immediately
     * show: true
     *
     * // Update without rendering (for batch operations)
     * show: false
     * ```
     */
    show?: boolean;
};

/**
 * Available road hierarchy category identifiers.
 *
 * @remarks
 * These categories represent different levels in the road network hierarchy,
 * from major highways to local streets.
 *
 * @group Traffic
 */
export declare const roadCategories: readonly ["motorway", "trunk", "primary", "secondary", "tertiary", "street"];

/**
 * Road hierarchy category type.
 *
 * @remarks
 * Classifies roads by their importance and capacity in the transportation network.
 * Used for filtering traffic data display based on road significance.
 *
 * Road hierarchy (from highest to lowest):
 * - `motorway` - High-capacity highways with restricted access
 * - `trunk` - Major inter-city roads
 * - `primary` - Primary through routes
 * - `secondary` - Secondary through routes
 * - `tertiary` - Connecting roads (see {@link TertiaryRoadCategory})
 * - `street` - Local streets (see {@link StreetRoadCategory})
 *
 * @group Traffic
 */
export declare type RoadCategory = (typeof roadCategories)[number];

/**
 * Main route line foreground color.
 * @ignore
 */
export declare const ROUTE_LINE_FOREGROUND_COLOR = "#36A8F0";

/**
 * Main route line width based on zoom level.
 * @ignore
 */
export declare const ROUTE_LINE_FOREGROUND_WIDTH: ExpressionSpecification;

/**
 * Main route outline color.
 */
export declare const ROUTE_LINE_OUTLINE_COLOR = "#105287";

/**
 * Detailed configuration for the visual appearance of route layers on the map with the MapLibre specification.
 *
 * @remarks
 * Provides fine-grained control over all route visualization layers, including
 * main route lines, waypoints, route sections (ferry, tunnel, toll roads, etc.),
 * turn-by-turn guidance instructions, and route summaries.
 *
 * All fields are optional. When a field is not provided, the default styling will be used.
 *
 * @group Routing
 */
export declare type RouteLayersConfig = {
    /**
     * Main route line layer specifications.
     *
     * @remarks
     * Defines the visual styling for the primary route path displayed on the map.
     * Can include both line and symbol layers for enhanced visualization.
     */
    mainLines?: {
        /**
         * Styling for the primary, selected route line.
         *
         * @remarks
         * Controls the visual appearance of the active route's line (color, width, dash pattern, etc.).
         */
        routeLine?: Partial<ToBeAddedLayerSpecTemplate<LineLayerSpecification>>;
        /**
         * Styling for the outline (stroke) around the primary route line.
         *
         * @remarks
         * Typically used to create contrast between the route and map background.
         */
        routeOutline?: Partial<ToBeAddedLayerSpecTemplate<LineLayerSpecification>>;
        /**
         * Styling for the deselected (inactive) route line.
         *
         * @remarks
         * Used when multiple routes are shown and some are visually de-emphasized.
         */
        routeDeselectedLine?: Partial<ToBeAddedLayerSpecTemplate<LineLayerSpecification>>;
        /**
         * Styling for the outline around the deselected route line.
         *
         * @remarks
         * Matches `routeDeselectedLine` but provides an outer stroke for visibility.
         */
        routeDeselectedOutline?: Partial<ToBeAddedLayerSpecTemplate<LineLayerSpecification>>;
        /**
         * Symbol layer that renders directional arrows along the main route.
         *
         * @remarks
         * Arrows can help indicate travel direction along routes with complex geometry.
         */
        routeLineArrows?: Partial<ToBeAddedLayerSpecTemplate<SymbolLayerSpecification>>;
    } & HasAdditionalLayersConfig;
    /**
     * Waypoint layer specifications.
     *
     * @remarks
     * Controls the appearance of waypoint icons (origin, destination, and intermediate stops)
     * and their labels along the route.
     */
    waypoints?: {
        /**
         * Symbol layer for waypoint icons (origin, destination, stops).
         *
         * @remarks
         * Customize icons, sizes, and placement for waypoints using this layer.
         */
        routeWaypointSymbol?: Partial<ToBeAddedLayerSpecTemplate<SymbolLayerSpecification>>;
        /**
         * Symbol layer for waypoint labels displayed next to waypoint icons.
         *
         * @remarks
         * Controls label text, font, and offset for waypoint annotations.
         */
        routeWaypointLabel?: Partial<ToBeAddedLayerSpecTemplate<SymbolLayerSpecification>>;
    } & HasAdditionalLayersConfig;
    /**
     * Electric vehicle charging station section layers.
     *
     * @remarks
     * Marks charging stop locations along routes calculated for electric vehicles.
     *
     * Charging stops are individual points which are originally extracted from leg sections.
     */
    chargingStops?: {
        /**
         * Symbol layer for rendering charging stop icons on the map.
         *
         * @remarks
         * Use this layer to control icon image, size, and placement for charging stops.
         */
        routeChargingStopSymbol?: Partial<ToBeAddedLayerSpecTemplate<SymbolLayerSpecification>>;
    } & HasAdditionalLayersConfig;
    /**
     * Layer specifications for specialized route sections.
     *
     * @remarks
     * Each section is a subset of the route path.
     *
     * Different types of road sections along the route can be styled individually
     * to highlight specific characteristics or conditions.
     */
    sections?: {
        /**
         * Ferry crossing section layers.
         *
         * @remarks
         * Styles the portions of the route that involve ferry transportation.
         */
        ferry?: {
            /**
             * Symbol layer used to mark ferry boarding/alighting points.
             *
             * @remarks
             * Typically used for icons at terminals or specific waypoints along the ferry section.
             */
            routeFerrySymbol?: Partial<ToBeAddedLayerSpecTemplate<SymbolLayerSpecification>>;
            /**
             * Line layer used to style the ferry crossing path.
             *
             * @remarks
             * Often drawn differently (e.g., dashed or patterned) to indicate ferry travel.
             */
            routeFerryLine?: Partial<ToBeAddedLayerSpecTemplate<LineLayerSpecification>>;
        } & HasAdditionalLayersConfig;
        /**
         * Traffic incident section layers.
         *
         * @remarks
         * Highlights route segments affected by traffic incidents or disruptions.
         */
        incident?: {
            /**
             * Symbol layer used to mark the start of a jam on the route.
             *
             * @remarks
             * Focuses on displaying jams with delays.
             */
            routeIncidentJamSymbol?: Partial<ToBeAddedLayerSpecTemplate<SymbolLayerSpecification>>;
            /**
             * Symbol layer used to mark the cause of the start of an incident on the route.
             *
             * @remarks
             * Can display icons for accidents, roadworks, weather, or other incidents.
             */
            routeIncidentCauseSymbol?: Partial<ToBeAddedLayerSpecTemplate<SymbolLayerSpecification>>;
            /**
             * Line layer used to draw the incident's background/highlight.
             *
             * @remarks
             * Provides a contrasting background line to make incident segments stand out.
             */
            routeIncidentBackgroundLine?: Partial<ToBeAddedLayerSpecTemplate<LineLayerSpecification>>;
            /**
             * Line layer used to draw dashed styling for incident segments.
             *
             * @remarks
             * Useful for indicating partial closures or advisory segments.
             */
            routeIncidentDashedLine?: Partial<ToBeAddedLayerSpecTemplate<LineLayerSpecification>>;
        } & HasAdditionalLayersConfig;
        /**
         * Toll road section layers.
         *
         * @remarks
         * Identifies route segments that require toll payments.
         */
        tollRoad?: {
            /**
             * Symbol layer for marking toll booths or toll segments.
             *
             * @remarks
             * Use for icons or markers indicating toll-related points along the route.
             */
            routeTollRoadSymbol?: Partial<ToBeAddedLayerSpecTemplate<SymbolLayerSpecification>>;
            /**
             * Line layer used to outline toll road segments.
             *
             * @remarks
             * Typically styled to visually differentiate toll segments from regular roads.
             */
            routeTollRoadOutline?: Partial<ToBeAddedLayerSpecTemplate<LineLayerSpecification>>;
        } & HasAdditionalLayersConfig;
        /**
         * Tunnel section layers.
         *
         * @remarks
         * Highlights route segments that pass through tunnels.
         */
        tunnel?: {
            /**
             * Line layer used to style tunnel segments along the route.
             *
             * @remarks
             * Often drawn with a distinct color or transparency to denote tunnels.
             */
            routeTunnelLine?: Partial<ToBeAddedLayerSpecTemplate<LineLayerSpecification>>;
        } & HasAdditionalLayersConfig;
        /**
         * Vehicle-restricted section layers.
         *
         * @remarks
         * Indicates route segments with vehicle access restrictions.
         */
        vehicleRestricted?: {
            /**
             * Background line layer for vehicle-restricted segments.
             *
             * @remarks
             * Provides a base styling to make restriction segments visible.
             */
            routeVehicleRestrictedBackgroundLine?: Partial<ToBeAddedLayerSpecTemplate<LineLayerSpecification>>;
            /**
             * Foreground line layer for vehicle-restricted segments.
             *
             * @remarks
             * Drawn on top of the background to emphasize the restriction area.
             */
            routeVehicleRestrictedForegroundLine?: Partial<ToBeAddedLayerSpecTemplate<LineLayerSpecification>>;
        } & HasAdditionalLayersConfig;
    };
    /**
     * Turn-by-turn instruction line layers.
     *
     * @remarks
     * Visual representation of individual maneuver segments in the guidance instructions.
     */
    instructionLines?: {
        /**
         * Line layer for the outline around instruction segments.
         *
         * @remarks
         * Used to make instruction segments readable over complex map backgrounds.
         */
        routeInstructionOutline?: Partial<ToBeAddedLayerSpecTemplate<LineLayerSpecification>>;
        /**
         * Line layer for the instruction segment itself.
         *
         * @remarks
         * Represents the precise geometry of the maneuver for which an instruction is shown.
         */
        routeInstructionLine?: Partial<ToBeAddedLayerSpecTemplate<LineLayerSpecification>>;
    } & HasAdditionalLayersConfig;
    /**
     * Turn-by-turn instruction arrow layers.
     *
     * @remarks
     * Directional arrows indicating the direction of travel for each maneuver.
     */
    instructionArrows?: {
        /**
         * Symbol layer for instruction/direction arrows placed along maneuver segments.
         *
         * @remarks
         * Controls arrow icon, rotation, and placement relative to the instruction geometry.
         */
        routeInstructionArrowSymbol?: Partial<ToBeAddedLayerSpecTemplate<SymbolLayerSpecification>>;
    } & HasAdditionalLayersConfig;
    /**
     * Route summary information bubble layers.
     *
     * @remarks
     * Displays summary information (e.g., total distance, estimated time) for the route.
     */
    summaryBubbles?: {
        /**
         * Symbol layer for the route summary bubble icon and label.
         *
         * @remarks
         * Use this layer to style the small summary popups or badges shown on the route.
         */
        routeSummaryBubbleSymbol?: Partial<ToBeAddedLayerSpecTemplate<SymbolLayerSpecification>>;
    } & HasAdditionalLayersConfig;
};

/**
 * GeoJSON feature representing a route section of a certain type.
 *
 * Represents a specific segment of a route with special characteristics
 * (e.g., ferry, toll road, tunnel, traffic incident, EV charging stop).
 *
 * @typeParam S - The section properties type, defaults to DisplaySectionProps
 *
 * @remarks
 * **Common Section Types:**
 * - Ferry crossings
 * - Toll roads
 * - Tunnels
 * - Traffic incidents
 * - Vehicle restrictions
 * - EV charging stops
 *
 * Each section has a start and end point along the route, represented as
 * a LineString geometry.
 *
 * @example
 * ```typescript
 * // Ferry section
 * const ferrySection: RouteSection = {
 *   type: 'Feature',
 *   geometry: {
 *     type: 'LineString',
 *     coordinates: [[4.9, 52.3], [4.95, 52.35]]
 *   },
 *   properties: {
 *     sectionType: 'ferry',
 *     routeIndex: 0,
 *     routeState: 'selected'
 *   }
 * };
 *
 * // Toll road section
 * const tollSection: RouteSection = {
 *   type: 'Feature',
 *   geometry: {
 *     type: 'LineString',
 *     coordinates: [[5.1, 52.4], [5.2, 52.5]]
 *   },
 *   properties: {
 *     sectionType: 'tollRoad',
 *     routeIndex: 0,
 *     routeState: 'selected'
 *   }
 * };
 * ```
 *
 * @group Routing
 */
declare type RouteSection<S extends DisplaySectionProps = DisplaySectionProps> = Feature<LineString, S>;

/**
 * GeoJSON feature collection representing route sections of a certain type.
 *
 * Collection of all sections of a specific type (e.g., all ferry crossings,
 * all toll roads) across one or more routes.
 *
 * @typeParam S - The section properties type, defaults to DisplaySectionProps
 *
 * @remarks
 * Used to group and render similar section types together, allowing for
 * consistent styling and filtering.
 *
 * @example
 * ```typescript
 * // Collection of all ferry sections
 * const ferrySections: RouteSections = {
 *   type: 'FeatureCollection',
 *   features: [
 *     {
 *       type: 'Feature',
 *       geometry: { type: 'LineString', coordinates: [[4.9, 52.3], [4.95, 52.35]] },
 *       properties: { sectionType: 'ferry', routeIndex: 0, routeState: 'selected' }
 *     },
 *     {
 *       type: 'Feature',
 *       geometry: { type: 'LineString', coordinates: [[5.0, 52.4], [5.05, 52.45]] },
 *       properties: { sectionType: 'ferry', routeIndex: 1, routeState: 'deselected' }
 *     }
 *   ]
 * };
 * ```
 *
 * @group Routing
 */
declare type RouteSections<S extends DisplaySectionProps = DisplaySectionProps> = FeatureCollection<LineString, S>;

/**
 * Specific props relating to a displayed route's visual style.
 *
 * Controls whether a route appears selected (highlighted) or deselected (dimmed).
 * The SDK manages these styles automatically based on user interaction.
 *
 * @remarks
 * **Style States:**
 * - `selected`: Primary route with full color saturation and emphasis
 * - `deselected`: Alternative routes shown dimmed/grayed out
 *
 * @example
 * ```typescript
 * // Main selected route
 * const selectedStyle: RouteStateProps = {
 *   routeState: 'selected'
 * };
 *
 * // Alternative route
 * const alternativeStyle: RouteStateProps = {
 *   routeState: 'deselected'
 * };
 * ```
 *
 * @group Routing
 */
export declare type RouteStateProps = {
    /**
     * Visual state-related style of the route.
     *
     * @remarks
     * Determines the state in which the route is rendered on the map:
     * - `selected`: Full color, more prominent (typically the chosen route)
     * - `deselected`: Reduced opacity, less prominent (alternative routes)
     */
    routeState: 'selected' | 'deselected';
};

/**
 * Generic styling for route visualization.
 *
 * @remarks
 * * Provides high-level theming options for route appearance.
 * * Can be overwritten by more specific layer styling configurations.
 *
 * @group Routing
 */
export declare type RouteTheme = {
    /**
     * The overall main color for the route waypoints and main lines.
     * * Use this to quickly theme the route appearance to match your application style.
     *
     * @remarks
     * * Can be overwritten by more specific configuration options which target color of specific layers.
     *
     * Available options:
     * - Any valid CSS color string (e.g., `"#FF0000"`, `"rgb(255,0,0)"`, `"red"`, etc.)
     */
    mainColor?: string;
};

/**
 * Map module for displaying and managing route visualizations.
 *
 * The RoutingModule provides comprehensive functionality for displaying routes on the map,
 * including route lines, alternative routes, turn-by-turn guidance, and interactive waypoints.
 * It integrates seamlessly with the TomTom Routing API.
 *
 * @remarks
 * **Features:**
 * - Display route lines with customizable styling
 * - Show alternative routes with different styling
 * - Interactive waypoint markers (drag, add, remove)
 * - Turn-by-turn guidance instructions
 * - Route section highlighting
 * - Distance and duration information
 * - Support for multiple routes simultaneously
 *
 * **Common Use Cases:**
 * - Turn-by-turn navigation displays
 * - Route planning and comparison
 * - Multi-stop route optimization
 * - Interactive route editing
 * - Fleet management route visualization
 *
 * @example
 * ```typescript
 * // Create the module
 * const routing = await RoutingModule.getInstance(map, {
 *   displayUnits: {
 *     distance: { type: 'metric' }
 *   }
 * });
 *
 * // Calculate and display a route
 * const result = await calculateRoute({
 *   key: 'your-api-key',
 *   locations: [
 *     [4.9041, 52.3676],  // Amsterdam
 *     [4.4777, 51.9244]   // Rotterdam
 *   ],
 *   routeOptions: {
 *     travelMode: 'car',
 *     routeType: 'fastest'
 *   }
 * });
 *
 * await routing.showRoutes(result);
 * ```
 *
 * @see [Routing Guide](https://docs.tomtom.com/maps-sdk-js/guides/map/routing)
 *
 * @group Routing
 */
export declare class RoutingModule extends AbstractMapModule<RoutingSourcesWithLayers, RoutingModuleConfig> {
    private layersSpecs;
    /**
     * Make sure the map is ready before create an instance of the module and any other interaction with the map
     * @param tomtomMap The TomTomMap instance.
     * @param config  The module optional configuration
     * @returns {Promise} Returns a promise with a new instance of this module
     *
     * @remarks
     * **Configuration Options:**
     * - `displayUnits`: Distance units (metric/imperial)
     * - `waypointsSource`: Waypoint entry point options
     * - `layers`: Complete layer styling configuration
     *
     * **Default Styling:**
     * If no custom layers are provided, uses {@link defaultRoutingLayers}.
     *
     * @example
     * Default initialization:
     * ```typescript
     * const routing = await RoutingModule.get(map);
     * ```
     *
     * @example
     * With custom configuration:
     * ```typescript
     * const routing = await RoutingModule.get(map, {
     *   displayUnits: 'imperial',
     *   waypointsSource: {
     *     entryPoints: 'main-when-available'
     *   }
     * });
     * ```
     */
    static get(tomtomMap: TomTomMap, config?: RoutingModuleConfig): Promise<RoutingModule>;
    private constructor();
    private createSourcesWithLayers;
    /**
     * @ignore
     */
    protected _initSourcesWithLayers(config?: RoutingModuleConfig): RoutingSourcesWithLayers;
    /**
     * @ignore
     */
    protected _applyConfig(config?: RoutingModuleConfig): RoutingModuleConfig;
    /**
     * @ignore
     */
    protected restoreDataAndConfigImpl(): Promise<void>;
    private addImageIfNotExisting;
    /**
     * Displays the given routes on the map.
     *
     * @param routes - Route data from Routing API or custom routes.
     * @param options - Optional configuration for route selection and display.
     * @param options.selectedIndex - Index of the route to display as selected (default: 0).
     *
     * @remarks
     * **Behavior:**
     * - Replaces any previously shown routes
     * - Shows all route-related features: lines, sections, summaries, guidance
     * - First route is selected by default (appears more prominent)
     * - Waypoints are NOT shown automatically (use {@link showWaypoints})
     *
     * **Route Features:**
     * - Main route lines (selected and deselected styles)
     * - Traffic sections with delays
     * - Ferry, tunnel, and toll sections
     * - EV charging stations (for EV routes)
     * - Turn-by-turn instruction lines and arrows
     * - Summary bubbles with distance/time/traffic info
     *
     * @example
     * Show single route:
     * ```typescript
     * await routing.showRoutes(response.routes);
     * ```
     *
     * @example
     * Show multiple routes with specific selection:
     * ```typescript
     * await routing.showRoutes(response.routes, { selectedIndex: 1 });
     * ```
     *
     * @example
     * Complete routing workflow:
     * ```typescript
     * import { routing as routingAPI } from '@tomtom-international/maps-sdk-js/services';
     *
     * // Calculate route
     * const response = await routingAPI.calculateRoute({
     *   locations: [[4.9, 52.4], [4.5, 51.9]],
     *   traffic: true,
     *   travelMode: 'car'
     * });
     *
     * // Display on map
     * const routing = await RoutingModule.get(map);
     * await routing.showRoutes(response.routes);
     * await routing.showWaypoints(response.routes[0].legs[0].points);
     * ```
     */
    showRoutes(routes: Routes_2, options?: ShowRoutesOptions): Promise<void>;
    /**
     * Clears any previously shown routes from the map.
     *
     * @remarks
     * - Clears all route-related layers (lines, sections, guidance, summaries)
     * - Does NOT clear waypoints (use {@link clearWaypoints})
     * - Module remains initialized and ready for new routes
     *
     * @example
     * ```typescript
     * await routing.clearRoutes();
     * ```
     */
    clearRoutes(): Promise<void>;
    /**
     * Changes which route appears as selected.
     *
     * @param index - Zero-based index of the route to select.
     *
     * @remarks
     * **Visual Changes:**
     * - Selected route appears more prominent (thicker, brighter)
     * - Previously selected route becomes deselected style
     * - Updates all route-related features (sections, guidance)
     *
     * **Requirements:**
     * - Route must already be displayed via {@link showRoutes}
     * - Index must be within range of displayed routes
     *
     * @example
     * ```typescript
     * // Show multiple routes
     * await routing.showRoutes(routes);
     *
     * // User clicks alternative route
     * await routing.selectRoute(1);
     *
     * // Switch back to first route
     * await routing.selectRoute(0);
     * ```
     */
    selectRoute(index: number): Promise<void>;
    /**
     * Shows the given waypoints on the map.
     * @param waypoints The waypoint-like inputs to show.
     */
    showWaypoints(waypoints: PlanningWaypoint[] | Waypoints_2): Promise<void>;
    /**
     * Clears any previously shown waypoints from the map.
     * * If nothing was shown before, nothing happens.
     */
    clearWaypoints(): Promise<void>;
    /**
     * Create the events on/off for this module
     * @returns An instance of EventsModule
     */
    get events(): {
        mainLines: EventsModule<Route<DisplayRouteProps>>;
        waypoints: EventsModule<Waypoint<WaypointDisplayProps>>;
        chargingStops: EventsModule<RouteSection>;
        summaryBubbles: EventsModule<DisplayRouteSummary>;
        incidents: EventsModule<RouteSections<DisplayTrafficSectionProps>>;
        vehicleRestricted: EventsModule<RouteSection>;
        ferries: EventsModule<RouteSection>;
        tollRoads: EventsModule<RouteSection>;
        tunnels: EventsModule<RouteSection>;
        instructionLines: EventsModule<DisplayInstruction>;
    };
    /**
     * Returns the map style layer under which route lines are rendered.
     * * Useful if you want to render extra layers just above the route ones but not on top of everything else.
     * * It might differ depending on the loaded style/version.
     */
    getLayerToRenderLinesUnder(): string;
}

/**
 * Configuration options for the routing module.
 *
 * @remarks
 * Provides customization options for route visualization and behavior,
 * including display units, waypoint handling, and layer styling.
 *
 * @group Routing
 */
export declare type RoutingModuleConfig = {
    /**
     * Units for displaying distances in route summaries and instructions.
     *
     * @remarks
     * Overrides the global configuration setting for display units.
     * Affects distance values shown in route summaries and turn-by-turn instructions.
     *
     * Available options:
     * - `metric` - Kilometers and meters
     * - `imperial` - Miles and feet
     *
     * @defaultValue `"metric"`
     */
    displayUnits?: DisplayUnits;
    /**
     * Main styling configuration for the route visualization.
     *
     * @remarks
     * * Provides high-level styling options that affect the overall appearance of the route,
     * such as the primary color used for route lines and waypoints.
     * * Can be overwritten by more specific layer styling configurations.
     */
    theme?: RouteTheme;
    /**
     * Configuration for the waypoints source and layers to display them on the map.
     *
     * @remarks
     * Controls how waypoint source data and/or layer configs are processed to rendering them the map.
     */
    waypoints?: WaypointsConfig;
    /**
     * Configuration for the charging stops source and layers to display them on the map.
     *
     * @remarks
     * Controls how charging stops source data and/or layer configs are processed to rendering them the map.
     */
    chargingStops?: ChargingStopsConfig;
    /**
     * Custom layer styling configuration.
     *
     * @remarks
     * * Overrides the default layer styling with custom specifications.
     * * You must provide complete layer specifications for any layers you wish to customize.
     * * You can still reuse the default configurations if you want incremental changes. See: defaultRoutingLayers.
     * * Any layer not specified will continue to use its default styling.
     * * Use this only if you need fine MapLibre control on how some parts of the route are displayed.
     */
    layers?: RouteLayersConfig;
};

/**
 * @ignore
 */
declare type RoutingSourcesWithLayers = {
    mainLines: GeoJSONSourceWithLayers<Routes<DisplayRouteProps>>;
    waypoints: GeoJSONSourceWithLayers<Waypoints<WaypointDisplayProps>>;
    vehicleRestricted: GeoJSONSourceWithLayers<RouteSections>;
    incidents: GeoJSONSourceWithLayers<RouteSections<DisplayTrafficSectionProps>>;
    ferries: GeoJSONSourceWithLayers<RouteSections>;
    chargingStops: GeoJSONSourceWithLayers<Waypoints>;
    tollRoads: GeoJSONSourceWithLayers<RouteSections>;
    tunnels: GeoJSONSourceWithLayers<RouteSections>;
    instructionLines: GeoJSONSourceWithLayers<DisplayInstructions>;
    instructionArrows: GeoJSONSourceWithLayers<DisplayInstructionArrows>;
    summaryBubbles: GeoJSONSourceWithLayers<DisplayRouteSummaries>;
};

/**
 * Used for showing/hiding layer depending on layer being part of selected route or not.
 *
 * @remarks
 * Add this to layers that depend on whether they are part of the selected route or not.
 *
 * @example:
 * filter: SELECTED_ROUTE_FILTER

 * @group Routing
 */
export declare const SELECTED_ROUTE_FILTER: ExpressionSpecification;

/**
 * Optional parameters when showing routes on the map.
 *
 * Controls which route is initially selected when displaying multiple route
 * alternatives on the map.
 *
 * @remarks
 * When multiple routes are displayed (e.g., fastest vs shortest), one route
 * is typically shown as "selected" (highlighted) while others are "deselected"
 * (dimmed). This type controls which route gets the selected state.
 *
 * @example
 * ```typescript
 * // Show first route as selected (default)
 * const options: ShowRoutesOptions = {
 *   selectedIndex: 0
 * };
 *
 * // Show second route as selected
 * const altOptions: ShowRoutesOptions = {
 *   selectedIndex: 1
 * };
 *
 * // Use default (first route selected)
 * const defaultOptions: ShowRoutesOptions = {};
 * ```
 *
 * @group Routing
 */
declare type ShowRoutesOptions = {
    /**
     * The index of the route within the array of routes to show as selected.
     *
     * @remarks
     * Zero-based index corresponding to the position in the routes array.
     * The selected route is displayed with full color and prominence,
     * while other routes are dimmed to indicate they are alternatives.
     *
     * @default 0 (the first route is shown as selected)
     *
     * @example
     * ```typescript
     * selectedIndex: 0  // First route (usually fastest)
     * selectedIndex: 1  // Second route (usually alternative)
     * selectedIndex: 2  // Third route
     * ```
     */
    selectedIndex?: number;
};

declare type SourceEventHandlers = Partial<Record<EventType, SourceEventTypeHandler[]>>;

declare type SourceEventTypeHandler = {
    sourceWithLayers: SourceWithLayers;
    layerIDs: string[];
    fn: UserEventHandler<any>;
};

/**
 * @ignore
 */
export declare type SourcesWithLayers = {
    [name: string]: SourceWithLayers;
};

/**
 * Contains the IDs of a source and its related layers.
 *
 * @remarks
 * This type provides a convenient way to reference a MapLibre source and all its associated
 * layers. Using these IDs, you can customize the source and layers directly through the
 * MapLibre API.
 *
 * **Common Use Cases:**
 * - Accessing layers for custom styling
 * - Modifying layer properties at runtime
 * - Removing or updating data sources
 * - Debugging layer hierarchies
 *
 * @example
 * ```typescript
 * // Get source and layer IDs from a module
 * const { sourceID, layerIDs } = routeModule.getSourceWithLayerIDs();
 *
 * // Update layer paint properties
 * for (const layerID of layerIDs) {
 *   map.setPaintProperty(layerID, 'line-opacity', 0.5);
 * }
 *
 * // Remove all layers and source
 * layerIDs.forEach(id => map.removeLayer(id));
 * map.removeSource(sourceID);
 * ```
 *
 * @group Shared
 */
export declare type SourceWithLayerIDs = {
    /**
     * The unique identifier of the MapLibre data source.
     *
     * @remarks
     * Use this ID to access or modify the source via MapLibre's source API.
     *
     * @example
     * ```typescript
     * const source = map.getSource(sourceID);
     * ```
     */
    sourceID: string;
    /**
     * Array of layer IDs associated with this source.
     *
     * @remarks
     * All layers in this array use the same source. The order typically represents
     * the rendering order, but check the actual map style for definitive ordering.
     *
     * @example
     * ```typescript
     * // Hide all layers from this source
     * layerIDs.forEach(id => {
     *   map.setLayoutProperty(id, 'visibility', 'none');
     * });
     * ```
     */
    layerIDs: string[];
};

/**
 * TomTom Maps SDK layer specifications template, without ID nor source, to be still initialized in some map module.
 * @ignore
 */
export declare type SourceWithLayers = StyleSourceWithLayers | GeoJSONSourceWithLayers;

/**
 * Configuration for a TomTom standard map style.
 *
 * Provides options to customize which modules are included and which style version to use.
 *
 * @example
 * ```typescript
 * // Standard style with all default modules
 * const style: StandardStyle = {
 *   id: 'standardLight'
 * };
 *
 * // Exclude traffic modules
 * const styleNoTraffic: StandardStyle = {
 *   id: 'standardLight',
 *   include: ['hillshade']  // Only include hillshade, exclude traffic
 * };
 *
 * // Use specific style version
 * const versionedStyle: StandardStyle = {
 *   id: 'standardDark',
 *   version: '1.0.0'
 * };
 * ```
 *
 * @group Map Style
 */
export declare type StandardStyle = {
    /**
     * Standard style identifier.
     *
     * Determines the visual appearance of the map.
     */
    id?: StandardStyleID;
    /**
     * Modules to include when loading the style.
     * * Use this to selectively enable only needed modules for better performance.
     *
     * If not specified, all available modules are included by default.
     * If an empty array is provided, no optional modules will be included.
     *
     * @default All available modules
     *
     * @remarks
     * Available modules:
     * - `trafficIncidents`: Real-time traffic incidents (accidents, closures)
     * - `trafficFlow`: Real-time traffic flow visualization
     * - `hillshade`: Terrain elevation shading
     *
     * @example
     * ```typescript
     * // Include only traffic modules
     * include: ['trafficIncidents', 'trafficFlow']
     *
     * // Include only hillshade
     * include: ['hillshade']
     *
     * // Include no optional modules
     * include: []
     * ```
     */
    include?: StyleModule[];
    /**
     * Style version to load.
     *
     * Allows pinning to a specific style version for consistency.
     * If not specified, uses the latest SDK-supported version.
     *
     * @default Latest SDK-supported version
     *
     * @example
     * ```typescript
     * version: '1.0.0'
     * ```
     */
    version?: string;
};

/**
 * Identifier for a TomTom-hosted standard map style.
 *
 * Standard styles are officially maintained by TomTom and provide consistent,
 * professionally designed map appearances.
 *
 * @remarks
 * Available styles:
 * - `standardLight`: Default light theme with full detail
 * - `standardDark`: Dark theme for low-light environments
 * - `drivingLight`: Optimized for in-car navigation (light)
 * - `drivingDark`: Optimized for in-car navigation (dark)
 * - `monoLight`: Minimalist monochrome light theme
 * - `monoDark`: Minimalist monochrome dark theme
 * - `satellite`: Satellite imagery basemap
 *
 * @example
 * ```typescript
 * const styleId: StandardStyleID = 'standardLight';
 * ```
 *
 * @group Map Style
 */
export declare type StandardStyleID = (typeof standardStyleIDs)[number];

/**
 * Array of all available standard style identifiers.
 *
 * This constant provides the complete list of TomTom-hosted standard map styles
 * that can be used when initializing a map. It serves as the source of truth for
 * valid style IDs and is used to derive the {@link StandardStyleID} type.
 *
 * @remarks
 * Use this array when you need to:
 * - Iterate over all available styles (e.g., building a style picker UI)
 * - Validate if a style ID is a standard style
 * - Display available options to users
 *
 * The array is defined as `const` with `as const` assertion to ensure type safety
 * and prevent modifications at runtime.
 *
 * @example
 * ```typescript
 * import { standardStyleIDs } from '@tomtom-org/maps-sdk/map';
 *
 * // Build a dropdown menu with all standard styles
 * const styleSelector = document.getElementById('style-selector');
 * standardStyleIDs.forEach((styleId) => {
 *   const option = new Option(styleId);
 *   styleSelector.add(option);
 * });
 *
 * // Check if a style ID is valid
 * const isValidStyle = (id: string): boolean => {
 *   return standardStyleIDs.includes(id as any);
 * };
 * ```
 *
 * @see {@link StandardStyleID} - The type derived from this array
 *
 * @group Map Style
 */
export declare const standardStyleIDs: readonly ["standardLight", "standardDark", "drivingLight", "drivingDark", "monoLight", "monoDark", "satellite"];

/**
 * @group Routing
 */
export declare const START_INDEX = "start";

/**
 * @ignore
 */
export declare const STOP_DISPLAY_INDEX = "stopDisplayIndex";

/**
 * Available street road sub-category identifiers.
 *
 * @remarks
 * Provides finer granularity for classifying local streets.
 *
 * @group Traffic
 */
export declare const streetRoadCategories: readonly ["local", "minor_local"];

/**
 * Street road sub-category type.
 *
 * @remarks
 * Further classifies local streets into specific sub-types for more granular filtering.
 *
 * Sub-categories:
 * - `local` - Standard local streets
 * - `minor_local` - Minor residential streets
 *
 * @group Traffic
 */
export declare type StreetRoadCategory = (typeof streetRoadCategories)[number];

/**
 * Handler interface for responding to map style changes.
 *
 * @remarks
 * This interface defines callbacks that are invoked when the map style changes via {@link TomTomMap.setStyle}.
 * Use this to perform cleanup or reinitialization of custom map features when styles are switched.
 *
 * **Lifecycle:**
 * 1. `onStyleAboutToChange` - Called before the new style is applied
 * 2. Style change occurs
 * 3. `onStyleChanged` - Called after the new style has been fully loaded
 *
 * **Common Use Cases:**
 * - Saving and restoring custom layers or sources
 * - Reinitializing map modules after style changes
 * - Updating UI components based on the new style
 * - Cleaning up resources tied to the previous style
 *
 * @example
 * ```typescript
 * const styleHandler: StyleChangeHandler = {
 *   onStyleAboutToChange: () => {
 *     console.log('Style changing - saving state...');
 *     // Save custom layer data
 *   },
 *   onStyleChanged: () => {
 *     console.log('Style changed - restoring state...');
 *     // Restore custom layers
 *   }
 * };
 *
 * map.addStyleChangeHandler(styleHandler);
 * ```
 *
 * @see {@link TomTomMap.addStyleChangeHandler}
 * @see {@link TomTomMap.setStyle}
 *
 * @group Map Style
 */
export declare type StyleChangeHandler = {
    /**
     * Callback invoked immediately before a style change begins.
     *
     * @remarks
     * Use this to perform cleanup or save state before the current style is removed.
     * This method can be synchronous or asynchronous.
     *
     * @returns void or a Promise that resolves when preparation is complete
     */
    onStyleAboutToChange: () => void | Promise<void>;
    /**
     * Callback invoked after a new style has been fully loaded.
     *
     * @remarks
     * Use this to restore state, reinitialize layers, or perform other setup
     * that depends on the new style being ready. This method can be synchronous or asynchronous.
     *
     * @returns void or a Promise that resolves when reinitialization is complete
     */
    onStyleChanged: () => void | Promise<void>;
};

/**
 * Map style specification for initialization.
 *
 * Defines which map style to load and how it should be configured.
 * Supports standard TomTom styles or custom styles.
 *
 * @remarks
 * Three input formats:
 * 1. **Simple ID**: Just pass a standard style ID string
 * 2. **Standard style object**: Use a TomTom style with custom configuration
 * 3. **Custom style object**: Load your own style from URL or JSON
 *
 * @example
 * ```typescript
 * // 1. Simple standard style
 * style: 'standardLight'
 *
 * // 2. Standard style with configuration
 * style: {
 *   type: 'standard',
 *   id: 'standardLight',
 *   include: ['trafficFlow', 'hillshade']
 * }
 *
 * // 3. Custom style from URL
 * style: {
 *   type: 'custom',
 *   url: 'https://example.com/style.json'
 * }
 *
 * // 4. Custom style from JSON
 * style: {
 *   type: 'custom',
 *   json: { version: 8, sources: {...}, layers: [...] }
 * }
 * ```
 *
 * @group Map Style
 */
export declare type StyleInput = StandardStyleID | (StandardStyle & {
    type: 'standard';
}) | (CustomStyle & {
    type: 'custom';
});

/**
 * Optional map modules that can be included with a style.
 *
 * @remarks
 * - `trafficIncidents`: Shows real-time traffic incidents on the map
 * - `trafficFlow`: Shows real-time traffic flow with color-coded speeds
 * - `hillshade`: Adds terrain elevation shading for topographic context
 *
 * @group Map Style
 */
export declare type StyleModule = (typeof styleModules)[number];

/**
 * Array of all available style modules.
 *
 * @group Map Style
 */
export declare const styleModules: readonly ["trafficIncidents", "trafficFlow", "hillshade"];

/**
 * Source with layers which are coming from the downloaded TT map style.
 * * Examples are parts of the base map, traffic, pois, and hillshade.
 * @ignore
 */
export declare class StyleSourceWithLayers<SOURCE_SPEC extends SourceSpecification = SourceSpecification, RUNTIME_SOURCE extends Source = Source> extends AbstractSourceWithLayers<SourceSpecification, RUNTIME_SOURCE> {
    constructor(map: Map_2, runtimeSource: RUNTIME_SOURCE, filter?: LayerSpecFilter);
}

/**
 * Properties part for an object that can have event state.
 *
 * Features with this type can store their current event state (click, hover, etc.),
 * which is used for styling and interaction handling.
 *
 * @remarks
 * This is typically mixed into feature properties to track interactive states.
 * The SDK automatically manages these states based on user interactions.
 *
 * @example
 * ```typescript
 * // Feature with click state
 * const featureProps: SupportsEvents = {
 *   eventState: 'click'
 * };
 *
 * // Feature with hover state
 * const hoveredProps: SupportsEvents = {
 *   eventState: 'hover'
 * };
 *
 * // Feature with no event state
 * const normalProps: SupportsEvents = {};
 * ```
 *
 * @group User Events
 */
export declare type SupportsEvents = {
    /**
     * Current event state of the feature.
     *
     * @remarks
     * - `undefined`: No active event state (normal appearance)
     * - Event type: Active state that affects styling and behavior
     *
     * This property is automatically managed by the SDK based on user
     * interactions and programmatic state changes.
     */
    eventState?: EventType;
};

/**
 * Options to style SDK SVG icons with custom colors and opacity.
 *
 * @example
 * ```typescript
 * const style: SVGIconStyleOptions = {
 *   fillColor: '#00FF00',
 *   outlineColor: '#000000',
 *   outlineOpacity: 0.5
 * };
 * ```
 * @group Shared
 */
export declare type SVGIconStyleOptions = {
    /**
     * The fill color to apply to the SVG icon (e.g., '#FF0000' or 'red').
     */
    fillColor?: string;
    /**
     * The outline (stroke) color to apply to the SVG icon.
     */
    outlineColor?: string;
    /**
     * The opacity of the outline, from 0 (transparent) to 1 (opaque).
     */
    outlineOpacity?: number;
};

/**
 * @ignore
 */
export declare type SymbolLayerSpecWithoutSource = Omit<SymbolLayerSpecification, 'source'>;

/**
 * Available tertiary road sub-category identifiers.
 *
 * @remarks
 * Provides finer granularity for classifying tertiary roads.
 *
 * @group Traffic
 */
export declare const tertiaryRoadCategories: readonly ["connecting", "major_local"];

/**
 * Tertiary road sub-category type.
 *
 * @remarks
 * Further classifies tertiary roads into specific sub-types for more granular filtering.
 *
 * Sub-categories:
 * - `connecting` - Roads connecting different areas
 * - `major_local` - Major roads within local areas
 *
 * @group Traffic
 */
export declare type TertiaryRoadCategory = (typeof tertiaryRoadCategories)[number];

/**
 * Layer to be added to the existing style, and may include extra config such as the ID of the layer to add it under.
 * * e.g. GeoJSON layers.
 * @ignore
 */
export declare type ToBeAddedLayerSpec<L extends LayerSpecification = LayerSpecification> = L & HasBeforeID;

/**
 * Layer specification with optional positioning for custom layer ordering.
 *
 * @typeParam L - The MapLibre layer specification type (defaults to any LayerSpecification)
 *
 * @remarks
 * This type allows you to define layers with precise control over their
 * rendering order in the map's layer stack. Each layer can optionally specify
 * another layer to be positioned before/under from.
 *
 * **Layer Ordering:**
 * - Layers are rendered in order from bottom to top
 * - Use `beforeID` to insert a layer before (below) an existing layer. The provided ID will be above (so the current layer will be under 'beforeID').
 * - Omit `beforeID` to place the layer on top of all existing layers
 *
 * @group Shared
 */
export declare type ToBeAddedLayerSpecTemplate<L extends LayerSpecification = LayerSpecification> = LayerSpecTemplate<L> & HasBeforeID;

/**
 * TomTom Maps SDK layer specifications do not come with the source ID initialized yet.
 * @ignore
 */
export declare type ToBeAddedLayerSpecWithoutSource<L extends LayerSpecification = LayerSpecification> = Omit<ToBeAddedLayerSpec<L>, 'source'>;

/**
 * @ignore
 */
export declare const toMapDisplayPOICategory: (category: POICategory) => string;

/**
 * Main TomTom Map class for displaying interactive maps in web applications.
 *
 * This is the entry point for rendering TomTom maps. It wraps MapLibre GL JS and provides
 * a simplified, enhanced API for common mapping tasks.
 *
 * @remarks
 * **Key Features:**
 * - Built on MapLibre GL JS for high-performance rendering
 * - Seamless style switching without map reload
 * - Integrated event handling system
 * - Multi-language support with dynamic switching
 * - Compatible with TomTom map modules (traffic, POIs, routing, etc.)
 *
 * **Architecture:**
 * - Exposes the underlying MapLibre Map instance via {@link mapLibreMap}
 * - Manages map lifecycle and style transitions
 * - Coordinates with map modules for data visualization
 *
 * @example
 * Basic map initialization:
 * ```typescript
 * import { TomTomMap } from '@tomtom-international/maps-sdk-js/map';
 *
 * const map = new TomTomMap(
 *   {
 *     container: 'map',
 *     center: [4.9041, 52.3676],
 *     zoom: 10
 *   },
 *   {
 *     key: 'YOUR_API_KEY',
 *     style: 'standardLight'
 *   }
 * );
 * ```
 *
 * @example
 * With modules and configuration:
 * ```typescript
 * const map = new TomTomMap(
 *   { container: 'map', center: [-74.006, 40.7128], zoom: 12 },
 *   {
 *     key: 'YOUR_API_KEY',
 *     style: {
 *       type: 'standard',
 *       id: 'standardDark',
 *       include: ['trafficFlow', 'trafficIncidents']
 *     },
 *     language: 'en-US',
 *     eventsConfig: {
 *       precisionMode: 'point-then-box',
 *       cursorOnHover: 'pointer'
 *     }
 *   }
 * );
 *
 * // Access MapLibre functionality directly
 * map.mapLibreMap.on('load', () => {
 *   console.log('Map loaded');
 * });
 * ```
 *
 * @group Map
 */
export declare class TomTomMap {
    /**
     * Indicates whether the map style has been fully loaded and is ready for interaction.
     *
     * @remarks
     * - `true` when the style is loaded and modules can be safely initialized
     * - `false` during map construction or style changes
     * - Check this before performing style-dependent operations
     *
     * @example
     * ```typescript
     * if (map.mapReady) {
     *   // Safe to initialize modules
     *   const trafficModule = await TrafficFlowModule.get(map);
     * }
     * ```
     */
    mapReady: boolean;
    /**
     * The underlying MapLibre GL JS Map instance.
     *
     * @remarks
     * **When to Use:**
     * - Access advanced MapLibre functionality not exposed by TomTomMap
     * - Add custom layers, sources, or controls
     * - Listen to MapLibre-specific events
     * - Integrate third-party MapLibre plugins
     *
     * **Important:**
     * - Available immediately after TomTomMap construction
     * - Direct modifications may affect SDK module behavior
     * - Coordinate with SDK modules to avoid conflicts
     *
     * @example
     * Add custom layer:
     * ```typescript
     * map.mapLibreMap.addLayer({
     *   id: 'custom-layer',
     *   type: 'circle',
     *   source: 'my-data',
     *   paint: {
     *     'circle-radius': 6,
     *     'circle-color': '#ff0000'
     *   }
     * });
     * ```
     *
     * @example
     * Listen to events:
     * ```typescript
     * map.mapLibreMap.on('moveend', () => {
     *   console.log('Camera position:', map.mapLibreMap.getCenter());
     * });
     * ```
     *
     * @see {@link https://maplibre.org/maplibre-gl-js-docs/api/map/ | MapLibre Map Documentation}
     */
    readonly mapLibreMap: Map_2;
    /**
     * @ignore
     */
    readonly _eventsProxy: EventsProxy;
    /**
     * @ignore
     */
    _params: TomTomMapParams;
    styleLightDarkTheme: LightDark;
    private readonly styleChangeHandlers;
    /**
     * Constructs a new TomTom Map instance and attaches it to a DOM element.
     *
     * @param mapLibreOptions - MapLibre map configuration for viewport, controls, and rendering.
     * Includes properties like `container`, `center`, `zoom`, `bearing`, `pitch`, etc.
     * See {@link MapLibreOptions} for all available options.
     *
     * @param mapParams - TomTom-specific parameters including API key, style, and events.
     * Can be partially specified here if already set via global configuration.
     * See {@link TomTomMapParams} for all available parameters.
     *
     * @remarks
     * **Initialization Process:**
     * 1. Merges `mapParams` with global configuration
     * 2. Creates underlying MapLibre map instance
     * 3. Loads specified style asynchronously
     * 4. Sets `mapReady` to `true` when complete
     *
     * **Configuration Priority:**
     * - Parameters passed here override global configuration
     * - Allows per-map customization while sharing common settings
     *
     * @example
     * Minimal initialization:
     * ```typescript
     * const map = new TomTomMap(
     *   { container: 'map', center: [0, 0], zoom: 2 },
     *   { key: 'YOUR_API_KEY' }
     * );
     * ```
     *
     * @example
     * Full configuration:
     * ```typescript
     * const map = new TomTomMap(
     *   {
     *     container: 'map',
     *     center: [-122.4194, 37.7749],
     *     zoom: 13,
     *     pitch: 45,
     *     bearing: -17.6,
     *     antialias: true,
     *     maxZoom: 18,
     *     minZoom: 8
     *   },
     *   {
     *     key: 'YOUR_API_KEY',
     *     style: {
     *       type: 'standard',
     *       id: 'standardLight',
     *       include: ['trafficFlow', 'hillshade']
     *     },
     *     language: 'en-US',
     *     eventsConfig: {
     *       precisionMode: 'point-then-box',
     *       paddingBoxPx: 10
     *     }
     *   }
     * );
     * ```
     *
     * @throws Will log errors if RTL text plugin fails to load (non-blocking)
     *
     * @see {@link MapLibreOptions}
     * @see {@link TomTomMapParams}
     * @see {@link https://maplibre.org/maplibre-gl-js-docs/api/map/ | MapLibre Map Parameters}
     * @see [Map Quickstart Guide](https://docs.tomtom.com/maps-sdk-js/guides/map/quickstart)
     * @see [Map Styles Guide](https://docs.tomtom.com/maps-sdk-js/guides/map/map-styles)
     * @see [User Events Guide](https://docs.tomtom.com/maps-sdk-js/guides/map/user-events)
     */
    constructor(mapLibreOptions: MapLibreOptions, mapParams?: Partial<TomTomMapParams>);
    private loadRTLTextPlugin;
    /**
     * Dynamically loads the MapLibre CSS stylesheet from CDN.
     */
    private ensureMapLibreCSSLoaded;
    /**
     * Changes the map style dynamically without reloading the entire map.
     *
     * @param style - The new style to apply. Can be a string ID or a detailed style configuration.
     * @param options - Configuration options for the style change behavior.
     * @param options.keepState - Whether to preserve SDK-rendered items and configurations when changing styles.
     * When `true` (default), maintains traffic layers, routes, markers, and other SDK features.
     * When `false`, performs a clean style switch without preserving previous state.
     *
     * @remarks
     * **Behavior:**
     * - Temporarily sets {@link mapReady} to `false` during the transition
     * - Triggers all registered {@link StyleChangeHandler} callbacks
     * - Resets {@link mapReady} to `true` when the new style is fully loaded
     *
     * **State Preservation (keepState: true):**
     * - Merges style parts from the previous style with the new one
     * - Maintains SDK module layers (traffic, routes, POIs, etc.)
     * - Preserves language settings
     *
     * **Clean Switch (keepState: false):**
     * - Applies the new style without merging previous configuration
     * - Removes all SDK module layers
     * - Useful for complete style resets
     *
     * @example
     * Simple style change:
     * ```typescript
     * // Switch to dark mode
     * map.setStyle('standardDark');
     * ```
     *
     * @example
     * Style change with detailed configuration:
     * ```typescript
     * map.setStyle({
     *   type: 'standard',
     *   id: 'standardLight',
     *   include: ['trafficFlow', 'hillshade']
     * });
     * ```
     *
     * @example
     * Clean style switch without state preservation:
     * ```typescript
     * // Complete reset - removes all SDK layers and modules
     * map.setStyle('standardDark', { keepState: false });
     * ```
     *
     * @example
     * With style change handlers:
     * ```typescript
     * map.addStyleChangeHandler({
     *   onStyleAboutToChange: () => {
     *     console.log('Preparing for style change...');
     *   },
     *   onStyleChanged: () => {
     *     console.log('New style applied!');
     *   }
     * });
     *
     * map.setStyle('standardDark');
     * ```
     *
     * @see {@link TomTomMapParams.style} - For setting style during initialization
     * @see {@link StyleChangeHandler} - For handling style change events
     * @see {@link getStyle} - For retrieving the current style
     * @see [Map Styles Guide](https://docs.tomtom.com/maps-sdk-js/guides/map/map-styles)
     */
    setStyle: (style: StyleInput, options?: {
        keepState?: boolean;
    }) => void;
    /**
     * Retrieves the current style configuration of the map.
     *
     * @returns The current {@link StyleInput} configuration, or `undefined` if no style is set.
     *
     * @remarks
     * Returns the style configuration as it was set, not the fully resolved MapLibre style object.
     * Use this to inspect or store the current style configuration for later restoration.
     *
     * **Return Value:**
     * - String ID (e.g., `'standardLight'`) for simple style configurations
     * - Style object with `type`, `id`, and optional `include` properties for detailed configurations
     * - `undefined` if no style has been explicitly set
     *
     * @example
     * ```typescript
     * const currentStyle = map.getStyle();
     * console.log('Current style:', currentStyle);
     *
     * // Save style for later
     * const savedStyle = map.getStyle();
     *
     * // Later, restore it
     * if (savedStyle) {
     *   map.setStyle(savedStyle);
     * }
     * ```
     *
     * @example
     * Conditional logic based on current style:
     * ```typescript
     * const style = map.getStyle();
     * if (typeof style === 'string' && style.includes('Dark')) {
     *   console.log('Dark mode is active');
     * }
     * ```
     *
     * @see {@link setStyle} - For changing the map style
     * @see {@link StyleInput} - For available style configuration options
     */
    getStyle: () => StyleInput | undefined;
    private _setLanguage;
    /**
     * Changes the language of the map.
     * * You can use this method to change the language at runtime.
     * * To set the language upon initialization, you can better do it via {@link core!TomTomConfig global config}
     * or {@link TomTomMapParams}.
     * @param language The language to be used in map translations.
     *
     * @remarks
     * **Behavior:**
     * - Updates all localizable map labels to the specified language
     * - Falls back to the default label name if the requested language is unavailable
     * - Can be called before or after the map is fully loaded
     * - If called before map is ready, will apply once the style loads
     *
     * **Language Format:**
     * - Simple language codes: `'en'`, `'fr'`, `'de'`, `'ja'`, `'zh'`
     * - Locale-specific codes: `'en-US'`, `'en-GB'`, `'zh-CN'`, `'pt-BR'`
     * - When using locale codes (with `-`), only the language portion is used for labels
     *
     * **Persistence:**
     * - Language setting persists across style changes (when `keepState: true`)
     * - Set during initialization via {@link TomTomMapParams.language} for immediate application
     *
     * @example
     * Change language at runtime:
     * ```typescript
     * // Switch to French
     * map.setLanguage('fr');
     * ```
     *
     * @example
     * Use locale-specific codes:
     * ```typescript
     * // Use Simplified Chinese
     * map.setLanguage('zh-CN');
     *
     * // Use Brazilian Portuguese
     * map.setLanguage('pt-BR');
     * ```
     *
     * @example
     * Language switcher UI:
     * ```typescript
     * const languageSelector = document.getElementById('lang-select');
     * languageSelector.addEventListener('change', (e) => {
     *   map.setLanguage(e.target.value);
     * });
     * ```
     *
     * @see {@link TomTomMapParams.language} - For setting language during initialization
     * @see {@link https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes | ISO 639-1 Language Codes}
     */
    setLanguage(language: Language): void;
    /**
     * Retrieves the current visible map area as a GeoJSON bounding box.
     *
     * @returns A {@link https://tools.ietf.org/html/rfc7946#section-5 | GeoJSON BBox} array
     * in the format `[west, south, east, north]` representing the map's current viewport bounds.
     *
     * @remarks
     * **Return Format:**
     * - Array of four numbers: `[minLongitude, minLatitude, maxLongitude, maxLatitude]`
     * - Coordinates are in WGS84 decimal degrees
     * - West/East values range from -180 to 180
     * - South/North values range from -90 to 90
     *
     * **Use Cases:**
     * - Performing spatial queries within the visible area
     * - Saving and restoring map view state
     * - Filtering data to display only what's visible
     * - Analytics and tracking of viewed regions
     *
     * @example
     * Get current bounds:
     * ```typescript
     * const bbox = map.getBBox();
     * console.log('Bounds:', bbox);
     * // Output: [-122.5, 37.7, -122.3, 37.8]
     * // [west, south, east, north]
     * ```
     *
     * @example
     * Use bounds for spatial query:
     * ```typescript
     * const bbox = map.getBBox();
     * const results = await searchAPI.searchInBoundingBox({
     *   bbox: bbox,
     *   query: 'restaurants'
     * });
     * ```
     *
     * @example
     * Save and restore map view:
     * ```typescript
     * // Save current view
     * const savedBounds = map.getBBox();
     * const savedZoom = map.mapLibreMap.getZoom();
     *
     * // Later, restore the view
     * const [west, south, east, north] = savedBounds;
     * map.mapLibreMap.fitBounds([[west, south], [east, north]]);
     * ```
     *
     * @see {@link https://tools.ietf.org/html/rfc7946#section-5 | GeoJSON BBox Specification}
     * @see {@link https://maplibre.org/maplibre-gl-js-docs/api/geography/#lnglatbounds | MapLibre LngLatBounds}
     */
    getBBox(): BBox;
    private handleStyleData;
    /**
     * Registers a handler to be notified when the map style changes.
     *
     * @param handler - A {@link StyleChangeHandler} object with callbacks for style change events.
     *
     * @remarks
     * **When to Use:**
     * - You have custom layers or sources that need to be recreated after style changes
     * - Your application needs to respond to style switches (e.g., light/dark mode transitions)
     * - You need to save and restore state during style changes
     * - Map modules need to reinitialize when styles change
     *
     * **Handler Lifecycle:**
     * 1. `onStyleAboutToChange()` - Called before the style change begins
     * 2. Style change occurs
     * 3. `onStyleChanged()` - Called after the new style has been fully loaded
     *
     * **Multiple Handlers:**
     * - Multiple handlers can be registered and will all be called in registration order
     * - Each handler's errors are caught independently and logged to the console
     * - One failing handler won't prevent others from executing
     *
     * **Important Notes:**
     * - Handlers are only triggered by {@link setStyle} calls, not initial map construction
     * - Only called when `keepState: true` in {@link setStyle} options
     * - Handlers persist for the lifetime of the TomTomMap instance
     *
     * @example
     * Basic usage:
     * ```typescript
     * map.addStyleChangeHandler({
     *   onStyleAboutToChange: () => {
     *     console.log('Style is changing...');
     *   },
     *   onStyleChanged: () => {
     *     console.log('Style changed successfully!');
     *   }
     * });
     *
     * // Later trigger the handlers
     * map.setStyle('standardDark');
     * ```
     *
     * @example
     * Preserve custom layers across style changes:
     * ```typescript
     * let customLayerData = null;
     *
     * map.addStyleChangeHandler({
     *   onStyleAboutToChange: () => {
     *     // Save custom layer data before style changes
     *     if (map.mapLibreMap.getLayer('my-custom-layer')) {
     *       customLayerData = map.mapLibreMap.getSource('my-data')._data;
     *       map.mapLibreMap.removeLayer('my-custom-layer');
     *       map.mapLibreMap.removeSource('my-data');
     *     }
     *   },
     *   onStyleChanged: () => {
     *     // Restore custom layer after new style is loaded
     *     if (customLayerData) {
     *       map.mapLibreMap.addSource('my-data', {
     *         type: 'geojson',
     *         data: customLayerData
     *       });
     *       map.mapLibreMap.addLayer({
     *         id: 'my-custom-layer',
     *         type: 'circle',
     *         source: 'my-data',
     *         paint: { 'circle-radius': 6, 'circle-color': '#007cbf' }
     *       });
     *     }
     *   }
     * });
     * ```
     *
     * @example
     * Async handler for external API calls:
     * ```typescript
     * map.addStyleChangeHandler({
     *   onStyleAboutToChange: async () => {
     *     await saveStateToAPI(map.getStyle());
     *   },
     *   onStyleChanged: async () => {
     *     await loadStateFromAPI();
     *   }
     * });
     * ```
     *
     * @example
     * Update UI based on style:
     * ```typescript
     * map.addStyleChangeHandler({
     *   onStyleAboutToChange: () => {
     *     document.body.classList.add('style-changing');
     *   },
     *   onStyleChanged: () => {
     *     document.body.classList.remove('style-changing');
     *     const style = map.getStyle();
     *     if (typeof style === 'string' && style.includes('Dark')) {
     *       document.body.classList.add('dark-mode');
     *     } else {
     *       document.body.classList.remove('dark-mode');
     *     }
     *   }
     * });
     * ```
     *
     * @see {@link StyleChangeHandler} - Handler interface definition
     * @see {@link setStyle} - Method that triggers the handlers
     */
    addStyleChangeHandler(handler: StyleChangeHandler): void;
}

/**
 * Parameters for initializing a TomTom map instance.
 *
 * Combines global SDK configuration with map-specific settings like style and events.
 *
 * @example
 * ```typescript
 * const mapParams: TomTomMapParams = {
 *   key: 'your-api-key',
 *   container: 'map-container',
 *   center: [4.9041, 52.3676],
 *   zoom: 12,
 *   style: 'standardLight',
 *   eventsConfig: {
 *     onClick: (event) => console.log('Map clicked', event)
 *   }
 * };
 * ```
 *
 * @group Map
 */
export declare type TomTomMapParams = GlobalConfig & {
    /**
     * Map style to load.
     *
     * If not specified, defaults to 'standardLight'.
     *
     * @default 'standardLight'
     *
     * @example
     * ```typescript
     * // Use dark theme
     * style: 'standardDark'
     *
     * // Custom configuration
     * style: {
     *   type: 'standard',
     *   id: 'standardLight',
     *   include: ['trafficFlow']
     * }
     * ```
     */
    style?: StyleInput;
    /**
     * Event handler configuration for map interactions.
     *
     * Define callbacks for various map events like clicks, hovers, and movements.
     *
     * @example
     * ```typescript
     * eventsConfig: {
     *   onClick: (event) => {
     *     console.log('Clicked at', event.lngLat);
     *   },
     *   onMoveEnd: () => {
     *     console.log('Map moved to', map.getCenter());
     *   }
     * }
     * ```
     */
    eventsConfig?: MapEventsConfig;
};

/**
 * Contains a source relevant for TomTom Maps SDK JS.
 * * The source might already be initialized from the map style, or it might be initialized here.
 * @ignore
 */
export declare class TomTomMapSource<SOURCE_SPEC extends SourceSpecification = SourceSpecification, RUNTIME_SOURCE extends Source = Source> {
    readonly id: string;
    readonly spec?: SOURCE_SPEC | undefined;
    runtimeSource?: RUNTIME_SOURCE | undefined;
    constructor(id: string, spec?: SOURCE_SPEC | undefined, runtimeSource?: RUNTIME_SOURCE | undefined);
    ensureAddedToMap(map: Map_2): void;
}

/**
 * Transforms the input of a "show" call to FeatureCollection "Places".
 * @ignore
 */
export declare const toPlaces: (places: Place | Place[] | Places_2) => Places_2;

/**
 * Source identifier for traffic flow vector tiles.
 *
 * @remarks
 * References the vector tile source containing real-time traffic flow data
 * showing current traffic speeds and congestion levels.
 *
 * @group Traffic Flow
 */
export declare const TRAFFIC_FLOW_SOURCE_ID = "vectorTilesFlow";

/**
 * Source identifier for traffic incidents vector tiles.
 *
 * @remarks
 * References the vector tile source containing real-time traffic incident data
 * such as accidents, road closures, and construction.
 *
 * @group Traffic Incidents
 */
export declare const TRAFFIC_INCIDENTS_SOURCE_ID = "vectorTilesIncidents";

/**
 * Common filter configuration shared between traffic incidents and flow visualization.
 *
 * @remarks
 * Provides road category filtering capabilities used by both incident and flow modules.
 *
 * @group Traffic
 */
export declare type TrafficCommonFilter = {
    /**
     * Filters traffic data by road hierarchy categories.
     *
     * @remarks
     * Controls which road types display traffic information.
     * Use the `mode` field to specify whether to show or hide the selected categories.
     *
     * @example
     * ```ts
     * // Show only motorways and trunk roads
     * roadCategories: { mode: 'show', values: ['motorway', 'trunk'] }
     * ```
     */
    roadCategories?: ValuesFilter<RoadCategory>;
    /**
     * Filters traffic data by road sub-categories.
     *
     * @remarks
     * Provides finer-grained control for tertiary roads and streets.
     * Applies to sub-categories of {@link TertiaryRoadCategory} and {@link StreetRoadCategory}.
     *
     * @example
     * ```ts
     * // Hide minor local streets
     * roadSubCategories: { mode: 'hide', values: ['minor_local'] }
     * ```
     */
    roadSubCategories?: ValuesFilter<TertiaryRoadCategory | StreetRoadCategory>;
};

/**
 * Filter configuration for traffic flow visualization.
 *
 * @remarks
 * Extends common traffic filters with flow-specific options,
 * particularly for highlighting road closures in the flow layer.
 *
 * @group Traffic Flow
 */
export declare type TrafficFlowFilter = TrafficCommonFilter & {
    /**
     * Controls road closure display in the traffic flow layer.
     *
     * @remarks
     * Determines whether to exclusively show road closures or exclude them from display.
     *
     * - `'show'` - Display only road closures
     * - `'hide'` - Display everything except road closures
     *
     * @example
     * ```ts
     * // Highlight only road closures
     * showRoadClosures: 'show'
     * ```
     */
    showRoadClosures?: FilterShowMode;
};

/**
 * Collection of traffic flow filters with OR logic.
 *
 * @remarks
 * Combines multiple flow filter configurations where traffic flow data is shown
 * if it matches **any** of the provided filter criteria (logical OR).
 *
 * @example
 * ```ts
 * // Show flow on motorways OR show road closures on any road
 * filters: {
 *   any: [
 *     { roadCategories: { mode: 'show', values: ['motorway'] } },
 *     { showRoadClosures: 'show' }
 *   ]
 * }
 * ```
 *
 * @group Traffic Flow
 */
export declare type TrafficFlowFilters = {
    /**
     * Array of flow filters combined with OR logic.
     *
     * @remarks
     * Traffic flow data is displayed if it satisfies at least one of the filter configurations.
     */
    any: TrafficFlowFilter[];
};

/**
 * Traffic Flow Module for displaying and configuring real-time traffic flow information on the map.
 *
 * This module controls the vector tile traffic flow layers that visualize current
 * traffic speed conditions using color-coded road segments.
 *
 * @remarks
 * **Features:**
 * - Toggle traffic flow visibility on/off
 * - Filter by road categories and types
 * - Color-coded speed visualization (green = free flow, red = congestion)
 * - Real-time traffic data from vector tiles
 * - Filter road closures
 *
 * **Visual Representation:**
 * - Green: Free-flowing traffic
 * - Yellow/Orange: Slow traffic
 * - Red: Heavy congestion
 * - Dark gray: Road closures
 *
 * **Use Cases:**
 * - Real-time traffic monitoring
 * - Route planning with current conditions
 * - Traffic analysis applications
 * - Navigation systems
 *
 * @example
 * Basic usage:
 * ```typescript
 * import { TrafficFlowModule } from '@tomtom-international/maps-sdk-js/map';
 *
 * // Get module (auto-add to style if needed)
 * const trafficFlow = await TrafficFlowModule.get(map, {
 *   visible: true
 * });
 *
 * // Toggle visibility
 * trafficFlow.setVisible(false);
 * trafficFlow.setVisible(true);
 * ```
 *
 * @example
 * Filter by road type:
 * ```typescript
 * // Show only highway traffic
 * trafficFlow.filter({
 *   any: [{
 *     roadCategories: {
 *       show: 'only',
 *       values: ['motorway', 'trunk']
 *     }
 *   }]
 * });
 *
 * // Hide local streets
 * trafficFlow.filter({
 *   any: [{
 *     roadCategories: {
 *       show: 'all_except',
 *       values: ['street']
 *     }
 *   }]
 * });
 * ```
 *
 * @example
 * Show only road closures:
 * ```typescript
 * trafficFlow.filter({
 *   any: [{
 *     showRoadClosures: 'only'
 *   }]
 * });
 * ```
 *
 * @see [Traffic Flow Guide](https://docs.tomtom.com/maps-sdk-js/guides/map/traffic-flow)
 * @see [Traffic Guide](https://docs.tomtom.com/maps-sdk-js/guides/map/traffic)
 *
 * @group Traffic Flow
 */
export declare class TrafficFlowModule extends AbstractMapModule<TrafficFlowSourcesWithLayers, FlowConfig> {
    private originalFilters;
    /**
     * Retrieves a TrafficFlowModule instance for the given map.
     *
     * @param map - The TomTomMap instance to attach this module to.
     * @param config - Optional configuration for initialization, visibility, and filters.
     *
     * @returns A promise that resolves to the initialized TrafficFlowModule.
     *
     * @remarks
     * **Configuration:**
     * - `visible`: Initial visibility state
     * - `ensureAddedToStyle`: Auto-add traffic flow to style if missing
     * - `filters`: Road category and type filters
     *
     * **Style Requirement:**
     * Traffic flow must be included in the map style or added via `ensureAddedToStyle`.
     *
     * @throws Error if traffic flow source is not in style and `ensureAddedToStyle` is false
     *
     * @example
     * Default initialization:
     * ```typescript
     * const trafficFlow = await TrafficFlowModule.get(map);
     * ```
     *
     * @example
     * Auto-add to style:
     * ```typescript
     * const trafficFlow = await TrafficFlowModule.get(map, {
     *   visible: true,
     *   filters: {
     *     any: [{
     *       roadCategories: {
     *         show: 'only',
     *         values: ['motorway', 'trunk', 'primary']
     *       }
     *     }]
     *   }
     * });
     * ```
     */
    static get(map: TomTomMap, config?: FlowConfig): Promise<TrafficFlowModule>;
    private constructor();
    /**
     * @ignore
     */
    protected _initSourcesWithLayers(): {
        trafficFlow: StyleSourceWithLayers<SourceSpecification, Source>;
    };
    /**
     * @ignore
     */
    protected _applyConfig(config: FlowConfig | undefined): FlowConfig | undefined;
    private getLayers;
    /**
     * Applies filters to traffic flow display.
     *
     * @param filters - Filter configuration for road types, categories, and closures.
     * Pass `undefined` to reset to defaults (show all).
     *
     * @remarks
     * **Filter Options:**
     * - `roadCategories`: Filter by road importance (motorway, trunk, primary, etc.)
     * - `roadSubCategories`: Filter by specific street types
     * - `showRoadClosures`: Show only closures or exclude them
     *
     * **Available Road Categories:**
     * - `motorway`: Major highways
     * - `trunk`: Major roads
     * - `primary`: Primary roads
     * - `secondary`: Secondary roads
     * - `tertiary`: Tertiary roads
     * - `street`: Local streets
     *
     * **Filter Logic:**
     * Uses "any" (OR) logic - traffic matching any filter is shown.
     *
     * @example
     * Show only major roads:
     * ```typescript
     * trafficFlow.filter({
     *   any: [{
     *     roadCategories: {
     *       show: 'only',
     *       values: ['motorway', 'trunk', 'primary']
     *     }
     *   }]
     * });
     * ```
     *
     * @example
     * Hide street-level traffic:
     * ```typescript
     * trafficFlow.filter({
     *   any: [{
     *     roadCategories: {
     *       show: 'all_except',
     *       values: ['street']
     *     }
     *   }]
     * });
     * ```
     *
     * @example
     * Multiple filter criteria:
     * ```typescript
     * trafficFlow.filter({
     *   any: [
     *     {
     *       roadCategories: { show: 'only', values: ['motorway'] }
     *     },
     *     {
     *       showRoadClosures: 'only'
     *     }
     *   ]
     * });
     * ```
     *
     * @example
     * Reset filters:
     * ```typescript
     * trafficFlow.filter(undefined);
     * ```
     */
    filter(filters?: TrafficFlowFilters): void;
    private _filter;
    /**
     * Sets the visibility of traffic flow layers.
     *
     * @param visible - `true` to show traffic flow, `false` to hide it.
     *
     * @example
     * ```typescript
     * trafficFlow.setVisible(true);  // Show traffic
     * trafficFlow.setVisible(false); // Hide traffic
     * ```
     */
    setVisible(visible: boolean): void;
    /**
     * Returns if any layer for traffic flow is visible or not.
     */
    isVisible(): boolean;
    /**
     * Create the events on/off for this module
     * @returns An instance of EventsModule
     */
    get events(): EventsModule<MapGeoJSONFeature>;
}

/**
 * IDs of sources and layers for traffic flow module.
 */
declare type TrafficFlowSourcesWithLayers = {
    trafficFlow: StyleSourceWithLayers;
};

/**
 * Filter configuration for traffic incidents visualization.
 *
 * @remarks
 * Extends common traffic filters with incident-specific filtering options
 * including category, severity, and delay-based filtering.
 *
 * @group Traffic Incidents
 */
export declare type TrafficIncidentsFilter = TrafficCommonFilter & {
    /**
     * Filters incidents by category type.
     *
     * @remarks
     * Controls which types of incidents are displayed on the map.
     *
     * @example
     * ```ts
     * // Show only accidents and road closures
     * incidentCategories: { mode: 'show', values: ['accident', 'road_closed'] }
     * ```
     */
    incidentCategories?: ValuesFilter<IncidentCategory>;
    /**
     * Filters incidents by delay severity magnitude.
     *
     * @remarks
     * Controls display based on the severity of traffic delays caused by incidents.
     *
     * Magnitude levels:
     * - `0` - Unknown
     * - `1` - Minor
     * - `2` - Moderate
     * - `3` - Major
     * - `4` - Undefined
     *
     * @example
     * ```ts
     * // Show only major incidents
     * magnitudes: { mode: 'show', values: [3] }
     * ```
     */
    magnitudes?: ValuesFilter<DelayMagnitude>;
    /**
     * Filters incidents by delay duration.
     *
     * @remarks
     * Allows filtering based on whether incidents have delays and minimum delay thresholds.
     */
    delays?: DelayFilter;
};

/**
 * Collection of traffic incident filters with OR logic.
 *
 * @remarks
 * Combines multiple incident filter configurations where an incident is shown
 * if it matches **any** of the provided filter criteria (logical OR).
 *
 * This allows for complex filtering scenarios where incidents from different
 * categories or with different characteristics can all be displayed.
 *
 * @example
 * ```ts
 * // Show major incidents OR road closures
 * filters: {
 *   any: [
 *     { magnitudes: { mode: 'show', values: [3] } },
 *     { incidentCategories: { mode: 'show', values: ['road_closed'] } }
 *   ]
 * }
 * ```
 *
 * @group Traffic Incidents
 */
export declare type TrafficIncidentsFilters = {
    /**
     * Array of incident filters combined with OR logic.
     *
     * @remarks
     * An incident is displayed if it satisfies at least one of the filter configurations.
     */
    any: TrafficIncidentsFilter[];
};

/**
 * Traffic Incidents Module for displaying and configuring real-time traffic incidents on the map.
 *
 * This module controls the vector tile traffic incidents layers that show traffic
 * events like accidents, road closures, construction, and hazards.
 *
 * @remarks
 * **Features:**
 * - Toggle incidents visibility on/off
 * - Separate control for incident icons
 * - Filter by incident type (accident, construction, etc.)
 * - Filter by severity/delay magnitude
 * - Filter by road categories
 * - Icon and line/polygon visualization
 *
 * **Incident Types:**
 * - Accidents
 * - Road closures
 * - Construction/road works
 * - Weather conditions (fog, ice, rain, etc.)
 * - Lane closures
 * - Traffic jams
 * - Broken down vehicles
 *
 * **Use Cases:**
 * - Real-time incident monitoring
 * - Route planning around incidents
 * - Traffic management systems
 * - Driver alert systems
 *
 * @example
 * Basic usage:
 * ```typescript
 * import { TrafficIncidentsModule } from '@tomtom-international/maps-sdk-js/map';
 *
 * // Get module (auto-add to style if needed)
 * const incidents = await TrafficIncidentsModule.get(map, {
 *   visible: true
 * });
 *
 * // Toggle visibility
 * incidents.setVisible(false);
 * incidents.setVisible(true);
 *
 * // Control icons separately
 * incidents.setIconsVisible(false);
 * ```
 *
 * @example
 * Filter by incident type:
 * ```typescript
 * // Show only accidents and road closures
 * incidents.filter({
 *   any: [{
 *     incidentCategories: {
 *       show: 'only',
 *       values: ['accident', 'road_closed']
 *     }
 *   }]
 * });
 *
 * // Hide construction
 * incidents.filter({
 *   any: [{
 *     incidentCategories: {
 *       show: 'all_except',
 *       values: ['road_works']
 *     }
 *   }]
 * });
 * ```
 *
 * @example
 * Filter by severity:
 * ```typescript
 * // Show only major delays
 * incidents.filter({
 *   any: [{
 *     magnitudes: {
 *       show: 'only',
 *       values: ['major']
 *     }
 *   }]
 * });
 *
 * // Show incidents with at least 10 minutes delay
 * incidents.filter({
 *   any: [{
 *     delays: {
 *       mustHaveDelay: true,
 *       minDelayMinutes: 10
 *     }
 *   }]
 * });
 * ```
 *
 * @example
 * Filter icons separately from incident areas:
 * ```typescript
 * // Show all incidents but only major icons
 * incidents.filter(
 *   {
 *     any: [{}] // Show all incidents
 *   },
 *   {
 *     any: [{
 *       magnitudes: { show: 'only', values: ['major'] }
 *     }]
 *   }
 * );
 * ```
 *
 * @see [Traffic Incidents Guide](https://docs.tomtom.com/maps-sdk-js/guides/map/traffic-incidents)
 * @see [Traffic Guide](https://docs.tomtom.com/maps-sdk-js/guides/map/traffic)
 *
 * @group Traffic Incidents
 */
export declare class TrafficIncidentsModule extends AbstractMapModule<TrafficIncidentsSourcesWithLayers, IncidentsConfig> {
    private originalFilters;
    /**
     * Retrieves a TrafficIncidentsModule instance for the given map.
     *
     * @param map - The TomTomMap instance to attach this module to.
     * @param config - Optional configuration for initialization, visibility, and filters.
     *
     * @returns A promise that resolves to the initialized TrafficIncidentsModule.
     *
     * @remarks
     * **Configuration:**
     * - `visible`: Initial visibility state for all incidents
     * - `icons.visible`: Initial visibility for incident icons
     * - `ensureAddedToStyle`: Auto-add traffic incidents to style if missing
     * - `filters`: Incident type, severity, and delay filters
     * - `icons.filters`: Separate filters for icons
     *
     * @throws Error if traffic incidents source is not in style and `ensureAddedToStyle` is false
     *
     * @example
     * Default initialization:
     * ```typescript
     * const incidents = await TrafficIncidentsModule.get(map);
     * ```
     *
     * @example
     * With configuration:
     * ```typescript
     * const incidents = await TrafficIncidentsModule.get(map, {
     *   visible: true,
     *   icons: { visible: true },
     *   filters: {
     *     any: [{
     *       incidentCategories: {
     *         show: 'only',
     *         values: ['accident', 'road_closed', 'jam']
     *       }
     *     }]
     *   }
     * });
     * ```
     */
    static get(map: TomTomMap, config?: IncidentsConfig): Promise<TrafficIncidentsModule>;
    private constructor();
    /**
     * @ignore
     */
    protected _initSourcesWithLayers(): {
        trafficIncidents: StyleSourceWithLayers<SourceSpecification, Source>;
    };
    /**
     * @ignore
     */
    protected _applyConfig(config: IncidentsConfig | undefined): IncidentsConfig | undefined;
    /**
     * Applies filters to traffic incidents display.
     *
     * @param incidentFilters - Filter for incident areas/lines. Pass `undefined` to reset.
     * @param iconFilters - Optional separate filter for incident icons. Pass `undefined` to reset.
     *
     * @remarks
     * **Filter Options:**
     * - `incidentCategories`: Filter by incident type
     * - `magnitudes`: Filter by delay severity (minor/moderate/major/unknown)
     * - `delays`: Filter by delay duration
     * - `roadCategories`: Filter by road importance
     * - `roadSubCategories`: Filter by specific road types
     *
     * **Available Incident Categories:**
     * - `accident`, `road_closed`, `lane_closed`
     * - `road_works` (construction)
     * - `jam` (traffic jam)
     * - `fog`, `rain`, `ice`, `wind`, `flooding`
     * - `dangerous_conditions`
     * - `broken_down_vehicle`
     * - `unknown`
     *
     * **Delay Magnitudes:**
     * - `minor`: Small delays
     * - `moderate`: Moderate delays
     * - `major`: Significant delays
     * - `unknown`: Unknown or no delay info
     *
     * @example
     * Filter by type:
     * ```typescript
     * incidents.filter({
     *   any: [{
     *     incidentCategories: {
     *       show: 'only',
     *       values: ['accident', 'road_closed']
     *     }
     *   }]
     * });
     * ```
     *
     * @example
     * Filter by severity and delay:
     * ```typescript
     * incidents.filter({
     *   any: [{
     *     magnitudes: { show: 'only', values: ['major', 'moderate'] },
     *     delays: {
     *       mustHaveDelay: true,
     *       minDelayMinutes: 5
     *     }
     *   }]
     * });
     * ```
     *
     * @example
     * Different filters for icons and areas:
     * ```typescript
     * // Show all incidents on roads
     * const incidentFilter = {
     *   any: [{
     *     roadCategories: { show: 'only', values: ['motorway', 'trunk'] }
     *   }]
     * };
     *
     * // But only show icons for major incidents
     * const iconFilter = {
     *   any: [{
     *     magnitudes: { show: 'only', values: ['major'] }
     *   }]
     * };
     *
     * incidents.filter(incidentFilter, iconFilter);
     * ```
     */
    filter(incidentFilters?: TrafficIncidentsFilters, iconFilters?: TrafficIncidentsFilters): void;
    private _filter;
    private getLayers;
    private getSymbolLayers;
    private getNonSymbolLayers;
    /**
     * Sets the visibility of incident icon layers.
     *
     * @param visible - `true` to show icons, `false` to hide them.
     *
     * @remarks
     * This controls only the icon/symbol layers, not the incident area polygons or lines.
     *
     * @example
     * ```typescript
     * // Hide icons but keep incident areas visible
     * incidents.setIconsVisible(false);
     *
     * // Show icons
     * incidents.setIconsVisible(true);
     * ```
     */
    setIconsVisible(visible: boolean): void;
    /**
     * Sets the visibility of all traffic incident layers.
     *
     * @param visible - `true` to show incidents, `false` to hide them.
     *
     * @remarks
     * This controls all incident layers including icons, lines, and polygons.
     *
     * @example
     * ```typescript
     * incidents.setVisible(false); // Hide all incidents
     * incidents.setVisible(true);  // Show all incidents
     * ```
     */
    setVisible(visible: boolean): void;
    private _setVisible;
    /**
     * Checks if any traffic incident layers are currently visible.
     *
     * @returns `true` if any incident layer is visible, `false` if all are hidden.
     *
     * @example
     * ```typescript
     * if (incidents.isVisible()) {
     *   console.log('Incidents are displayed');
     * }
     * ```
     */
    isVisible(): boolean;
    /**
     * Checks if any incident icon layers are currently visible.
     *
     * @returns `true` if any icon layer is visible, `false` if all icons are hidden.
     *
     * @example
     * ```typescript
     * if (incidents.anyIconLayersVisible()) {
     *   console.log('Incident icons are shown');
     * }
     * ```
     */
    anyIconLayersVisible(): boolean;
    /**
     * Create the events on/off for this module
     * @returns An instance of EventsModule
     */
    get events(): EventsModule<MapGeoJSONFeature>;
}

/**
 * IDs of sources and layers for traffic incidents module.
 */
declare type TrafficIncidentsSourcesWithLayers = {
    trafficIncidents: StyleSourceWithLayers;
};

/**
 * @ignore
 */
export declare const UNKNOWN_DELAY_COLOR = "#000000";

/**
 * Handler function for user interaction events on map features.
 *
 * @remarks
 * Called when a user interacts with features on the map (e.g., click, hover).
 * Provides detailed information about the interacted feature, its location,
 * and all features at the event coordinates.
 *
 * **Feature Type Mapping:**
 * - **GeoJSON modules** (places, routes, geometries): `topFeature` is the original feature passed to the `show()` method
 * - **Vector tile modules** (POIs, traffic): `topFeature` is derived from MapLibre's internal feature representation
 *
 * **Event Precision:**
 * - The `lngLat` coordinates may be near but not exactly on the feature, depending on the precision mode
 * - The precision behavior is controlled by `MapEventsConfig.precisionMode`
 *
 * @typeParam T - The type of the top feature being interacted with
 *
 * @param topFeature - The primary target feature for the event, positioned on top of any overlapping features
 * @param lngLat - The geographic coordinates where the event occurred
 * @param allEventFeatures - All features matching the event coordinates across all map modules, as raw MapLibre GeoJSON features. The first feature corresponds to `topFeature`
 * @param sourceWithLayers - The source and layer configuration to which the `topFeature` belongs
 *
 * @example
 * Click handler for route features:
 * ```ts
 * routingModule.on('click', (route, lngLat, allFeatures, source) => {
 *   console.log('Clicked route:', route.properties.id);
 *   console.log('At coordinates:', lngLat);
 *   console.log('Total features at location:', allFeatures.length);
 * });
 * ```
 *
 * @example
 * Hover handler for places with feature inspection:
 * ```ts
 * placesModule.on('mousemove', (place, lngLat, allFeatures, source) => {
 *   // Show tooltip with place information
 *   showTooltip({
 *     title: place.properties.poi?.name,
 *     address: place.properties.address.freeformAddress,
 *     coordinates: lngLat
 *   });
 *
 *   // Check for overlapping features
 *   if (allFeatures.length > 1) {
 *     console.log(`${allFeatures.length} features at this location`);
 *   }
 * });
 * ```
 *
 * @see {@link EventsModule.on} - For registering event handlers
 *
 * @group User Events
 */
export declare type UserEventHandler<T> = (topFeature: T, lngLat: LngLat, allEventFeatures: MapGeoJSONFeature[], sourceWithLayers: SourceWithLayers) => void;

/**
 * Generic filter configuration for showing or hiding items by value.
 *
 * Provides a flexible way to control visibility of categorized items (e.g., POI categories,
 * layer groups, road types) using either inclusion or exclusion mode.
 *
 * @typeParam T - The type of values being filtered (e.g., string literals, enums)
 *
 * @remarks
 * **Filter Modes:**
 * - `only`: Whitelist mode - only specified values are shown
 * - `all_except`: Blacklist mode - all values except specified ones are shown
 *
 * **Common Use Cases:**
 * - Filtering POI categories (show only restaurants)
 * - Hiding map layer groups (hide all except roads)
 * - Filtering traffic incidents by type
 * - Controlling road categories in traffic flow
 *
 * @example
 * ```typescript
 * // Show only specific categories
 * const includeFilter: ValuesFilter<string> = {
 *   show: 'only',
 *   values: ['RESTAURANT', 'CAFE', 'BAR']
 * };
 *
 * // Hide specific categories
 * const excludeFilter: ValuesFilter<string> = {
 *   show: 'all_except',
 *   values: ['PARKING_GARAGE']
 * };
 *
 * // Type-safe with string literals
 * type RoadType = 'motorway' | 'trunk' | 'primary';
 * const roadFilter: ValuesFilter<RoadType> = {
 *   show: 'only',
 *   values: ['motorway', 'trunk']
 * };
 * ```
 *
 * @group Shared
 */
export declare type ValuesFilter<T> = {
    /**
     * Filter mode determining whether values list is inclusive or exclusive.
     *
     * @remarks
     * - `only`: Shows only the items in the values array (whitelist)
     * - `all_except`: Shows all items except those in the values array (blacklist)
     */
    show: FilterShowMode;
    /**
     * Array of values to include or exclude based on the show mode.
     *
     * @remarks
     * The interpretation of this array depends on the `show` property:
     * - If `show` is `'only'`, only these values will be visible
     * - If `show` is `'all_except'`, these values will be hidden
     *
     * @example
     * ```typescript
     * // Include only these values
     * values: ['RESTAURANT', 'HOTEL']
     *
     * // Exclude these values
     * values: ['PARKING']
     * ```
     */
    values: T[];
};

/**
 * Display properties for a waypoint marker on the map.
 *
 * Extends location display properties with waypoint-specific information
 * including position in the route and stop numbering.
 *
 * @remarks
 * Waypoints are displayed differently based on their position:
 * - **Start**: Origin marker (often "A" or green pin)
 * - **Middle**: Numbered stop markers (1, 2, 3, etc.)
 * - **Finish**: Destination marker (often "B" or red pin)
 *
 * @example
 * ```typescript
 * // Start waypoint
 * const start: WaypointDisplayProps = {
 *   id: 'waypoint-0',
 *   iconID: 'waypoint-start',
 *   index: 0,
 *   indexType: 'start',
 *   title: 'Amsterdam Central Station'
 * };
 *
 * // Intermediate stop
 * const stop: WaypointDisplayProps = {
 *   id: 'waypoint-1',
 *   iconID: 'waypoint-stop',
 *   index: 1,
 *   indexType: 'middle',
 *   stopDisplayIndex: 1,
 *   title: 'Schiphol Airport'
 * };
 *
 * // Destination
 * const finish: WaypointDisplayProps = {
 *   id: 'waypoint-2',
 *   iconID: 'waypoint-finish',
 *   index: 2,
 *   indexType: 'finish',
 *   title: 'Rotterdam Central Station'
 * };
 * ```
 *
 * @group Routing
 */
export declare type WaypointDisplayProps = PlaceDisplayProps & {
    /**
     * The index of the waypoint in relation to the other waypoints.
     *
     * @remarks
     * Zero-based index of this waypoint in the complete waypoints array,
     * including start, all stops, and finish.
     *
     * @example
     * ```typescript
     * index: 0  // First waypoint (start)
     * index: 1  // Second waypoint (first stop or finish)
     * index: 2  // Third waypoint
     * ```
     */
    index: number;
    /**
     * The type associated to the index, describing how the waypoint sits in the list of waypoints.
     *
     * @remarks
     * Determines the waypoint's role and visual representation:
     * - `start`: Origin point
     * - `middle`: Intermediate stop
     * - `finish`: Final destination
     *
     * This affects icon selection and labeling behavior.
     */
    indexType: WaypointIndexType;
    /**
     * The stop index to be displayed.
     *
     * @remarks
     * Stops are the non-soft waypoints added between origin and destination,
     * numbered starting from 1. Only present for middle waypoints.
     *
     * **Display Behavior:**
     * - Start waypoint: undefined
     * - First stop: 1
     * - Second stop: 2
     * - Finish waypoint: undefined
     *
     * Used for displaying stop numbers (e.g., "Stop 1", "Stop 2") in the UI.
     *
     * @example
     * ```typescript
     * stopDisplayIndex: 1  // First intermediate stop
     * stopDisplayIndex: 2  // Second intermediate stop
     * stopDisplayIndex: undefined  // Start or finish waypoint
     * ```
     */
    stopDisplayIndex?: number;
};

/**
 * @group Routing
 */
export declare type WaypointIndexType = typeof START_INDEX | typeof MIDDLE_INDEX | typeof FINISH_INDEX;

/**
 * Configuration for controlling waypoint data sources and display behavior.
 *
 * @remarks
 * Determines how waypoint position data is processed when rendering waypoints on the map,
 * particularly in relation to entry point information.
 *
 * @group Routing
 */
export declare type WaypointsConfig = {
    /**
     * Icon display configuration for waypoints.
     *
     * @remarks
     * Allows customization of the visual style for waypoint icons (origin, destination, stops) on the map.
     *
     */
    icon?: {
        /**
         * Base style options for the SVG waypoint icon.
         *
         * @remarks
         * Use this to set the fill color, outline color, and outline opacity for the default waypoint icon.
         *
         * Example:
         * ```typescript
         * baseStyle: {
         *   fillColor: '#007AFF',
         *   outlineColor: '#FFFFFF',
         *   outlineOpacity: 0.8
         * }
         * ```
         */
        style?: SVGIconStyleOptions;
    };
    /**
     * Controls how entry points are used when displaying waypoints on the map.
     *
     * @remarks
     * Entry points represent the actual navigable entrance to a location,
     * which may differ from the geometric center coordinates.
     *
     * Available options:
     * - `main-when-available` - Uses the main entry point coordinates when available, falling back to the waypoint coordinates
     * - `ignore` - Always uses the original waypoint coordinates
     *
     * @defaultValue `"ignore"`
     */
    entryPoints?: GetPositionEntryPointOption;
};

export { }
