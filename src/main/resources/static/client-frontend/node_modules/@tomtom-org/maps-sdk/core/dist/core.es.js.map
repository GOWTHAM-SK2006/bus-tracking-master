{"version":3,"file":"core.es.js","sources":["../src/config/globalConfig.ts","../src/types/place/ev/chargingStation.ts","../src/types/place/ev/connector.ts","../src/types/place/place.ts","../src/types/route/chargingStop.ts","../src/types/route/route.ts","../src/types/route/sections.ts","../src/types/view.ts","../src/util/bbox.ts","../src/util/generateId.ts","../src/util/headers.ts","../src/util/lngLat.ts","../src/util/routePlanningLocations.ts","../src/util/traffic.ts","../src/util/unitFormatters.ts","../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isNil.js"],"sourcesContent":["import type { Language } from '../types';\nimport type { DistanceUnitsType } from '../util';\n\n/**\n * Configuration for displaying distance-based units.\n *\n * Allows customization of distance unit labels and the unit system\n * (metric or imperial) used throughout the SDK.\n *\n * @group Configuration\n */\nexport type DistanceDisplayUnits = {\n    /**\n     * Type of distance unit system.\n     *\n     * Determines whether to use metric (meters, kilometers) or\n     * imperial (feet, miles, yards) units.\n     */\n    type?: DistanceUnitsType;\n    /**\n     * Custom label for kilometer units.\n     *\n     * @default \"km\"\n     */\n    kilometers?: string;\n    /**\n     * Custom label for meter units.\n     *\n     * @default \"m\"\n     */\n    meters?: string;\n    /**\n     * Custom label for mile units.\n     *\n     * @default \"mi\"\n     */\n    miles?: string;\n    /**\n     * Custom label for feet units.\n     *\n     * @default \"ft\"\n     */\n    feet?: string;\n    /**\n     * Custom label for yard units.\n     *\n     * @default \"yd\"\n     */\n    yards?: string;\n};\n\n/**\n * Configuration for displaying time-based units.\n *\n * Allows customization of time unit labels used for durations\n * throughout the SDK.\n *\n * @group Configuration\n */\nexport type TimeDisplayUnits = {\n    /**\n     * Custom label for hour units.\n     *\n     * @default \"h\"\n     */\n    hours?: string;\n    /**\n     * Custom label for minute units.\n     *\n     * @default \"min\"\n     */\n    minutes?: string;\n};\n\n/**\n * Display unit configuration for time and distance.\n *\n * Used by formatting utilities and map information displays to present\n * durations and distances with custom labels.\n *\n * @group Configuration\n */\nexport type DisplayUnits = {\n    /**\n     * Distance unit configuration.\n     *\n     * Controls how distances are displayed throughout the SDK.\n     */\n    distance?: DistanceDisplayUnits;\n    /**\n     * Time unit configuration.\n     *\n     * Controls how durations are displayed throughout the SDK.\n     */\n    time?: TimeDisplayUnits;\n};\n\n/**\n * Global configuration for the TomTom Maps SDK.\n *\n * Contains essential parameters like API keys, language settings, and display preferences\n * that apply across all SDK services and map functionality.\n *\n * @remarks\n * This configuration can be set globally using {@link TomTomConfig} and will be merged\n * with service-specific configurations, with service configs taking precedence.\n *\n * @example\n * ```typescript\n * const config: GlobalConfig = {\n *   apiKey: 'your-api-key',\n *   apiVersion: 1,\n *   commonBaseURL: 'https://api.tomtom.com',\n *   language: 'en-US',\n *   displayUnits: {\n *     distance: { type: 'metric' },\n *     time: { hours: 'hrs', minutes: 'mins' }\n *   }\n * };\n * ```\n *\n * @group Configuration\n */\nexport type GlobalConfig = {\n    /**\n     * TomTom API key for authentication.\n     *\n     * Required for all SDK features. Obtain an API key from the\n     * [TomTom Developer Portal](https://developer.tomtom.com/).\n     *\n     * @default None (required)\n     */\n    apiKey: string;\n\n    /**\n     * An experimental alternative to the API Key which enables oauth2 access to APIs.\n     * * If provided, then the API key parameter will be ignored.\n     * @experimental\n     */\n    // TODO: restore if we implement oauth2 access\n    // apiAccessToken?: string;\n\n    /**\n     * API version number for service endpoints.\n     *\n     * Each service may have its own default version. Consult the specific\n     * service documentation for available versions.\n     *\n     * @default 1 (but each service can override)\n     */\n    apiVersion: number;\n\n    /**\n     * Request identifier for tracing and support.\n     *\n     * Must match the pattern: `^[a-zA-Z0-9-]{1,100}$`\n     *\n     * Recommended format is UUID (e.g., `9ac68072-c7a4-11e8-a8d5-f2801f1b9fd1`).\n     * When specified, it's included in the `Tracking-ID` response header.\n     * This is solely for support purposes and does not involve user tracking.\n     *\n     * @see {@link https://docs.tomtom.com/search-api/documentation/search-service/fuzzy-search#trackingid-response | Tracking-ID documentation}\n     */\n    trackingId?: string;\n\n    /**\n     * Language code for SDK services and map content.\n     *\n     * Accepts IETF language codes (case-insensitive). Affects search results,\n     * routing instructions, and map labels.\n     *\n     * @default \"NGT\" (Neutral Ground Truth - uses local language for each location)\n     *\n     * @see {@link https://docs.tomtom.com/search-api/documentation/product-information/supported-languages | Search supported languages}\n     * @see {@link https://docs.tomtom.com/routing-api/documentation/product-information/supported-languages | Routing supported languages}\n     */\n    language?: Language;\n\n    /**\n     * Base URL for all TomTom API services.\n     *\n     * Individual services can override this with their own base URLs.\n     * Typically only changed for testing or enterprise deployments.\n     *\n     * @default \"https://api.tomtom.com\"\n     */\n    commonBaseURL: string;\n\n    /**\n     * Custom display units for time and distance.\n     *\n     * Applied to {@link formatDistance} and {@link formatDuration} utilities,\n     * which are used throughout the SDK for displaying map information.\n     * If not provided, default unit labels are used.\n     */\n    displayUnits?: DisplayUnits;\n};\n\n/**\n * Default global configuration values.\n *\n * Provides sensible defaults for the global configuration.\n * The API key must be set before using SDK features.\n *\n * @group Configuration\n */\nexport const defaultConfig: GlobalConfig = {\n    commonBaseURL: 'https://api.tomtom.com',\n    apiKey: '',\n    apiVersion: 1,\n};\n\n/**\n * Global configuration singleton for the TomTom Maps SDK.\n *\n * Manages SDK-wide configuration settings that apply to all services and maps.\n * Uses the singleton pattern to ensure consistent configuration across the application.\n *\n * @remarks\n * Configuration set via this class is merged with service-specific parameters,\n * with service parameters taking precedence over global settings.\n *\n * @example\n * ```typescript\n * // Set global configuration\n * TomTomConfig.instance.put({\n *   apiKey: 'your-api-key',\n *   language: 'en-US'\n * });\n *\n * // Get current configuration\n * const config = TomTomConfig.instance.get();\n *\n * // Reset to defaults\n * TomTomConfig.instance.reset();\n * ```\n *\n * @group Configuration\n */\nexport class TomTomConfig {\n    /**\n     * Singleton instance of the configuration.\n     */\n    static readonly instance = new TomTomConfig();\n    private config: GlobalConfig = { ...defaultConfig };\n\n    private constructor() {}\n\n    /**\n     * Merge configuration values into the global configuration.\n     *\n     * New values override existing ones. This performs a shallow merge,\n     * so nested objects are replaced entirely rather than merged.\n     *\n     * @param config - Partial configuration to merge\n     *\n     * @example\n     * ```typescript\n     * TomTomConfig.instance.put({\n     *   apiKey: 'your-api-key',\n     *   language: 'de-DE'\n     * });\n     * ```\n     */\n    put(config: Partial<GlobalConfig>) {\n        this.config = { ...this.config, ...config };\n    }\n\n    /**\n     * Reset configuration to default values.\n     *\n     * Clears all custom configuration and restores the initial defaults.\n     * Note that the default API key is an empty string.\n     *\n     * @example\n     * ```typescript\n     * TomTomConfig.instance.reset();\n     * ```\n     */\n    reset() {\n        this.config = { ...defaultConfig };\n    }\n\n    /**\n     * Get the current global configuration.\n     *\n     * @returns Current configuration object\n     *\n     * @example\n     * ```typescript\n     * const config = TomTomConfig.instance.get();\n     * console.log(config.apiKey);\n     * ```\n     */\n    get() {\n        return this.config;\n    }\n}\n\n/**\n * Merges the global configuration into the given one, with the latter having priority.\n * @ignore\n */\nexport const mergeFromGlobal = <T extends Partial<GlobalConfig>>(givenConfig: T = {} as T): T => ({\n    ...TomTomConfig.instance.get(),\n    ...givenConfig,\n});\n","import type { Connector } from './connector';\n\n/**\n * @group Place\n */\nexport const chargingStationAccessTypes = ['Public', 'Authorized', 'Restricted', 'Private', 'Unknown'] as const;\n\n/**\n * Access type for EV charging stations.\n *\n * Indicates who can use the charging station.\n *\n * @remarks\n * - `Public`: Open to all electric vehicle drivers\n * - `Authorized`: Requires membership, subscription, or authorization\n * - `Restricted`: Limited access (e.g., hotel guests, employees only)\n * - `Private`: Private use only, not available to public\n * - `Unknown`: Access type not specified\n *\n * @example\n * ```typescript\n * const accessType: ChargingStationsAccessType = 'Public';\n * ```\n *\n * @group Place\n */\nexport type ChargingStationsAccessType = (typeof chargingStationAccessTypes)[number];\n\n/**\n * @group Place\n */\nexport const chargingPointStatus = ['Available', 'Reserved', 'Occupied', 'OutOfService', 'Unknown'] as const;\n\n/**\n * Real-time operational status of a charging point.\n *\n * @remarks\n * - `Available`: Ready for use, not currently occupied\n * - `Reserved`: Reserved by another user\n * - `Occupied`: Currently in use\n * - `OutOfService`: Not operational (maintenance or malfunction)\n * - `Unknown`: Status information unavailable\n *\n * @example\n * ```typescript\n * const status: ChargingPointStatus = 'Available';\n * ```\n *\n * @group Place\n */\nexport type ChargingPointStatus = (typeof chargingPointStatus)[number];\n\n/**\n * Possible capabilities for a charging point.\n * @group Place\n */\nexport const chargingPointCapabilities = [\n    'ChargingProfileCapable',\n    'ChargingPreferencesCapable',\n    'ChipCardSupport',\n    'ContactlessCardSupport',\n    'CreditCardPayable',\n    'DebitCardPayable',\n    'PedTerminal',\n    'RemoteStartStopCapable',\n    'Reservable',\n    'RfidReader',\n    'StartSessionConnectorRequired',\n    'TokenGroupCapable',\n    'UnlockCapable',\n    'PlugAndCharge',\n    'Unknown',\n] as const;\n\n/**\n * Capability of a charging point.\n *\n * Describes features and payment options available at the charging point.\n *\n * @remarks\n * - `ChargingProfileCapable`: Supports custom charging profiles\n * - `ChargingPreferencesCapable`: Supports charging preferences\n * - `ChipCardSupport`: Payment terminal accepts chip cards\n * - `ContactlessCardSupport`: Payment terminal accepts contactless cards\n * - `CreditCardPayable`: Accepts credit card payments\n * - `DebitCardPayable`: Accepts debit card payments\n * - `PedTerminal`: Has PIN entry device for payments\n * - `RemoteStartStopCapable`: Can be started/stopped remotely\n * - `Reservable`: Supports reservations\n * - `RfidReader`: Supports RFID token authorization\n * - `StartSessionConnectorRequired`: Requires connector ID to start session\n * - `TokenGroupCapable`: Supports token groups for start/stop with different tokens\n * - `UnlockCapable`: Connector can be remotely unlocked\n * - `PlugAndCharge`: Supports ISO 15118 Plug & Charge (automatic authentication)\n * - `Unknown`: Capability not specified\n *\n * @example\n * ```typescript\n * // Check for specific capabilities\n * const capabilities: ChargingPointCapability[] = [\n *   'CreditCardPayable',\n *   'Reservable',\n *   'RemoteStartStopCapable'\n * ];\n * ```\n *\n * @group Place\n */\nexport type ChargingPointCapability = (typeof chargingPointCapabilities)[number];\n\n/**\n * @group Place\n */\nexport const chargingPointRestrictions = ['EvOnly', 'Plugged', 'Disabled', 'Customers', 'Motorcycles'] as const;\n\n/**\n * Parking or usage restrictions for a charging point.\n *\n * Indicates special requirements or limitations for using the charging location.\n *\n * @remarks\n * - `EvOnly`: Reserved parking spot for electric vehicles only\n * - `Plugged`: Parking allowed only while actively charging\n * - `Disabled`: Reserved for disabled persons with valid identification\n * - `Customers`: For customers/guests only (e.g., hotel, shop)\n * - `Motorcycles`: Suitable only for electric motorcycles or scooters\n *\n * @example\n * ```typescript\n * const restrictions: ChargingPointRestriction[] = ['EvOnly', 'Customers'];\n * ```\n *\n * @group Place\n */\nexport type ChargingPointRestriction = (typeof chargingPointRestrictions)[number];\n\n/**\n * Individual charging point (EVSE - Electric Vehicle Supply Equipment).\n *\n * Represents a single charging unit with one or more connectors.\n *\n * @remarks\n * A charging station typically contains multiple charging points.\n * Each charging point can have multiple connectors of different types.\n *\n * @example\n * ```typescript\n * const chargingPoint: ChargingPoint = {\n *   evseId: 'EVSE-001',\n *   status: 'Available',\n *   capabilities: ['CreditCardPayable', 'RemoteStartStopCapable', 'PlugAndCharge'],\n *   restrictions: ['EvOnly'],\n *   connectors: [\n *     { id: 'conn-1', type: 'IEC62196Type2CCS', ratedPowerKW: 150, ... }\n *   ]\n * };\n * ```\n *\n * @group Place\n */\nexport type ChargingPoint = {\n    /**\n     * Unique identifier for this charging point (EVSE ID).\n     *\n     * Often follows international standards like ISO 15118.\n     */\n    evseId: string;\n\n    /**\n     * Capabilities and features of this charging point.\n     *\n     * Indicates payment options, remote control, and advanced features.\n     */\n    capabilities: ChargingPointCapability[];\n\n    /**\n     * Usage or parking restrictions for this charging point.\n     *\n     * Specifies who can use the charger or special parking rules.\n     */\n    restrictions: ChargingPointRestriction[];\n\n    /**\n     * Real-time operational status of this charging point.\n     *\n     * Indicates if the charger is available, occupied, or out of service.\n     */\n    status: ChargingPointStatus;\n\n    /**\n     * Physical connectors available at this charging point.\n     *\n     * Each connector represents a different plug type and charging capability.\n     */\n    connectors?: Connector[];\n};\n\n/**\n * Electric vehicle charging station.\n *\n * Represents a complete charging station facility with one or more charging points.\n * A station is typically at a single location but may have multiple charging units.\n *\n * @example\n * ```typescript\n * const station: ChargingStation = {\n *   id: 'station-123',\n *   chargingPoints: [\n *     { evseId: 'EVSE-001', status: 'Available', ... },\n *     { evseId: 'EVSE-002', status: 'Occupied', ... }\n *   ]\n * };\n * ```\n *\n * @group Place\n */\nexport type ChargingStation = {\n    /**\n     * Unique identifier for the charging station.\n     */\n    id: string;\n\n    /**\n     * Array of charging points available at this station.\n     *\n     * Each charging point can serve one vehicle at a time.\n     */\n    chargingPoints: ChargingPoint[];\n};\n","/**\n * @group Place\n */\nexport const connectorTypes = [\n    'StandardHouseholdCountrySpecific',\n    'IEC62196Type1',\n    'IEC62196Type1CCS',\n    'IEC62196Type2CableAttached',\n    'IEC62196Type2Outlet',\n    'IEC62196Type2CCS',\n    'IEC62196Type3',\n    'Chademo',\n    'GBT20234Part2',\n    'GBT20234Part3',\n    'IEC60309AC3PhaseRed',\n    'IEC60309AC1PhaseBlue',\n    'IEC60309DCWhite',\n    'Tesla',\n] as const;\n\n/**\n * Electric vehicle charging connector type.\n *\n * Defines the physical connector standard used for EV charging.\n * Different regions and vehicle manufacturers use different connector types.\n *\n * @remarks\n * Common connector types:\n * - `IEC62196Type1`: SAE J1772 (North America, Japan)\n * - `IEC62196Type2CableAttached`: Mennekes/Type 2 (Europe)\n * - `IEC62196Type1CCS`: CCS Type 1 (Combined Charging System)\n * - `IEC62196Type2CCS`: CCS Type 2 (Combined Charging System)\n * - `Chademo`: CHAdeMO (Japan, DC fast charging)\n * - `Tesla`: Tesla proprietary connector\n * - `GBT20234Part2/3`: Chinese GB/T standard\n *\n * @example\n * ```typescript\n * const connectorType: ConnectorType = 'IEC62196Type2CCS';\n * ```\n *\n * @group Place\n */\nexport type ConnectorType = (typeof connectorTypes)[number];\n\n/**\n * @group Place\n */\nexport const currentTypes = ['AC1', 'AC3', 'DC'] as const;\n\n/**\n * Current type for electric vehicle charging.\n *\n * Specifies the type of electrical current used for charging.\n *\n * @remarks\n * - `AC1`: Alternating Current, single-phase (slower charging, typically 3-7 kW)\n * - `AC3`: Alternating Current, three-phase (faster AC charging, up to 22 kW)\n * - `DC`: Direct Current (DC fast charging, 50-350+ kW)\n *\n * @example\n * ```typescript\n * const currentType: CurrentType = 'DC';  // DC fast charging\n * ```\n *\n * @group Place\n */\nexport type CurrentType = (typeof currentTypes)[number];\n\n/**\n * The charging speed classification of this charging connection.\n *\n * @remarks\n * - `slow`: Typically up to 12 kW (Level 1 AC charging)\n * - `regular`: Typically between 12 kW and 50 kW (Level 2 AC charging)\n * - `fast`: Typically between 50 kW and 150 kW (DC fast charging)\n * - `ultra-fast`: Typically above 150 kW (High-power DC fast charging)\n */\nexport type ChargingSpeed = 'slow' | 'regular' | 'fast' | 'ultra-fast';\n\n/**\n * Electric vehicle charging connector with specifications.\n *\n * Describes a specific charging connector available at a charging point,\n * including its technical specifications and capabilities.\n *\n * @example\n * ```typescript\n * const connector: Connector = {\n *   id: 'connector-1',\n *   type: 'IEC62196Type2CCS',\n *   ratedPowerKW: 150,\n *   voltageV: 400,\n *   currentA: 375,\n *   currentType: 'DC'\n * };\n * ```\n *\n * @group Place\n */\nexport type Connector = {\n    /**\n     * Unique identifier for this connector.\n     */\n    id: string;\n    /**\n     * Physical connector type/standard.\n     *\n     * Must match the vehicle's charging port for compatibility.\n     */\n    type: ConnectorType;\n    /**\n     * Rated charging power in kilowatts (kW).\n     *\n     * Indicates the maximum charging speed. Common values:\n     * - 3-7 kW: Level 1/2 AC charging\n     * - 7-22 kW: Level 2 AC charging\n     * - 50-150 kW: DC fast charging\n     * - 150-350 kW: DC ultra-fast charging\n     */\n    ratedPowerKW: number;\n    /**\n     * The charging speed classification of this charging connection.\n     *\n     * @remarks\n     * - `slow`: Typically up to 12 kW (Level 1 AC charging)\n     * - `regular`: Typically between 12 kW and 50 kW (Level 2 AC charging)\n     * - `fast`: Typically between 50 kW and 150 kW (DC fast charging)\n     * - `ultra-fast`: Typically above 150 kW (High-power DC fast charging)\n     */\n    chargingSpeed: ChargingSpeed;\n    /**\n     * Voltage in volts (V).\n     *\n     * Operating voltage for this connector.\n     * Common values: 120V, 240V (AC), 400V, 800V (DC)\n     */\n    voltageV: number;\n    /**\n     * Current in amperes (A).\n     *\n     * Maximum current capacity for this connector.\n     */\n    currentA: number;\n    /**\n     * Type of electrical current (AC or DC).\n     */\n    currentType: CurrentType;\n};\n","import type { Feature, Point, Position } from 'geojson';\nimport type { FeatureCollectionWithProperties } from '../extendedGeoJSON';\nimport type { ChargingPark } from './ev/evPlaceProps';\nimport type { PlaceDataSources } from './placeDataSources';\nimport type { POI, RelatedPOI } from './poi/poi';\n\n/**\n * @group Place\n */\nexport const geographyTypes = [\n    'Country',\n    'CountrySubdivision',\n    'CountrySecondarySubdivision',\n    'CountryTertiarySubdivision',\n    'Municipality',\n    'MunicipalitySubdivision',\n    'Neighbourhood',\n    'PostalCodeArea',\n] as const;\n\n/**\n * Type of geographic administrative entity.\n *\n * Defines the hierarchical level of an administrative area or postal region.\n *\n * @remarks\n * Geographic hierarchy from largest to smallest:\n * - `Country`: Sovereign nation\n * - `CountrySubdivision`: State, province, or first-level admin division\n * - `CountrySecondarySubdivision`: County or second-level admin division\n * - `CountryTertiarySubdivision`: Third-level admin division\n * - `Municipality`: City or town\n * - `MunicipalitySubdivision`: District within a city\n * - `Neighbourhood`: Named neighborhood or area within a city\n * - `PostalCodeArea`: Area defined by postal/ZIP code\n *\n * @example\n * ```typescript\n * const geographyType: GeographyType = 'Municipality';  // City level\n * ```\n *\n * @group Place\n */\nexport type GeographyType = (typeof geographyTypes)[number];\n\n/**\n * Type of mapcode.\n *\n * Mapcodes are short location codes that can be used as an alternative to coordinates.\n *\n * @remarks\n * - `Local`: Shortest mapcode, requires territory context (e.g., \"4J.P2\" for Eiffel Tower in FRA)\n * - `International`: Unambiguous worldwide, no territory needed but longer\n * - `Alternative`: Alternative local encoding pointing to slightly different coordinates\n *\n * @see [Mapcode documentation](https://www.mapcode.com)\n *\n * @group Place\n */\nexport type MapcodeType = 'Local' | 'International' | 'Alternative';\n\n/**\n * Mapcode representation of a location.\n *\n * A mapcode is a short, memorable code representing a geographic location,\n * designed as an alternative to coordinates.\n *\n * @example\n * ```typescript\n * // Local mapcode (requires territory)\n * const localMapcode: Mapcode = {\n *   type: 'Local',\n *   fullMapcode: 'NLD 4J.P2',\n *   territory: 'NLD',\n *   code: '4J.P2'\n * };\n *\n * // International mapcode (no territory needed)\n * const intlMapcode: Mapcode = {\n *   type: 'International',\n *   fullMapcode: 'VHXGB.4J9W',\n *   code: 'VHXGB.4J9W'\n * };\n * ```\n *\n * @group Place\n */\nexport type Mapcode = {\n    /**\n     * The type of mapcode (Local, International, or Alternative).\n     */\n    type: MapcodeType;\n    /**\n     * Complete mapcode including territory if applicable.\n     *\n     * Always unambiguous. Format: \"TERRITORY CODE\" for local, just \"CODE\" for international.\n     */\n    fullMapcode: string;\n    /**\n     * Territory code for local mapcodes.\n     *\n     * Present only for Local and Alternative mapcodes. Uses Latin alphabet.\n     * Not present for International mapcodes.\n     */\n    territory?: string;\n    /**\n     * The mapcode without territory.\n     *\n     * Two groups of letters/digits separated by a dot (e.g., \"4J.P2\").\n     * Uses the response language/alphabet. Not present for International mapcodes.\n     */\n    code?: string;\n};\n\n/**\n * Address range information for a street segment.\n *\n * Used for Address Range type results to indicate ranges of addresses\n * along a street segment.\n *\n * @group Place\n */\nexport type AddressRanges = {\n    /**\n     * Address range on the left side of the street.\n     *\n     * Looking from the 'from' point toward the 'to' point.\n     */\n    rangeLeft: string;\n    /**\n     * Address range on the right side of the street.\n     *\n     * Looking from the 'from' point toward the 'to' point.\n     */\n    rangeRight: string;\n    /**\n     * Starting coordinates of the street segment [longitude, latitude].\n     */\n    from: Position;\n    /**\n     * Ending coordinates of the street segment [longitude, latitude].\n     */\n    to: Position;\n};\n\n/**\n * Type of entry point for a place.\n *\n * @remarks\n * - `main`: Primary entrance (at most one per place)\n * - `minor`: Secondary or alternative entrance (can have multiple)\n *\n * @group Place\n */\nexport type EntryPointType = 'main' | 'minor';\n\n/**\n * Entry point (entrance) for a place.\n *\n * Represents a physical access point to a building or facility,\n * useful for routing to ensure users are directed to the correct entrance.\n *\n * @example\n * ```typescript\n * const entryPoint: EntryPoint = {\n *   type: 'main',\n *   functions: ['FrontDoor'],\n *   position: [4.9041, 52.3676]\n * };\n * ```\n *\n * @group Place\n */\nexport type EntryPoint = {\n    /**\n     * Type of entry point (main or minor).\n     */\n    type: EntryPointType;\n    /**\n     * Functional description of the entry point.\n     *\n     * Examples: 'FrontDoor', 'ServiceEntrance', 'ParkingGarage'\n     */\n    functions?: string[];\n    /**\n     * Geographic coordinates of the entry point [longitude, latitude].\n     */\n    position: Position;\n};\n\n/**\n * @group Place\n */\nexport const placeTypes = ['POI', 'Street', 'Geography', 'Point Address', 'Address Range', 'Cross Street'] as const;\n\n/**\n * Type of place result.\n *\n * Categorizes the kind of location returned by search or geocoding services.\n *\n * @remarks\n * - `POI`: Point of Interest (business, landmark, facility)\n * - `Street`: A named street\n * - `Geography`: Administrative area (city, state, country, etc.)\n * - `Point Address`: Specific street address with building number\n * - `Address Range`: Range of addresses along a street segment\n * - `Cross Street`: Intersection of two streets\n *\n * @example\n * ```typescript\n * const placeType: PlaceType = 'POI';\n * ```\n *\n * @group Place\n */\nexport type PlaceType = (typeof placeTypes)[number];\n\n/**\n * Structured address components for a place.\n *\n * Provides hierarchical address information from building number up to country level.\n * Not all components are present for every place; availability depends on the location\n * and data coverage.\n *\n * @example\n * ```typescript\n * const address: AddressProperties = {\n *   freeformAddress: '1600 Pennsylvania Avenue NW, Washington, DC 20500, USA',\n *   streetNumber: '1600',\n *   streetName: 'Pennsylvania Avenue NW',\n *   municipality: 'Washington',\n *   countrySubdivision: 'DC',\n *   postalCode: '20500',\n *   countryCode: 'US',\n *   country: 'United States',\n *   countryCodeISO3: 'USA'\n * };\n * ```\n *\n * @group Place\n */\nexport type AddressProperties = {\n    /**\n     * Complete formatted address string.\n     *\n     * Follows the formatting conventions of the result's country of origin.\n     * For countries, this is the full country name.\n     */\n    freeformAddress: string;\n\n    /**\n     * Building or house number on the street.\n     */\n    streetNumber?: string;\n\n    /**\n     * Street name without the building number.\n     */\n    streetName?: string;\n\n    /**\n     * Subdivision of a municipality (sub-city or super-city area).\n     */\n    municipalitySubdivision?: string;\n\n    /**\n     * City or town name.\n     */\n    municipality?: string;\n\n    /**\n     * County or second-level administrative subdivision.\n     */\n    countrySecondarySubdivision?: string;\n\n    /**\n     * Named area or third-level administrative subdivision.\n     */\n    countryTertiarySubdivision?: string;\n\n    /**\n     * State or province (first-level administrative subdivision).\n     */\n    countrySubdivision?: string;\n\n    /**\n     * Postal code or ZIP code.\n     */\n    postalCode?: string;\n\n    /**\n     * Extended postal code.\n     *\n     * Availability depends on region. More precise than standard postal code.\n     */\n    extendedPostalCode?: string;\n\n    /**\n     * Two-letter ISO 3166-1 alpha-2 country code.\n     *\n     * Examples: 'US', 'GB', 'NL', 'DE'\n     */\n    countryCode?: string;\n\n    /**\n     * Full country name.\n     */\n    country?: string;\n\n    /**\n     * Three-letter ISO 3166-1 alpha-3 country code.\n     *\n     * Examples: 'USA', 'GBR', 'NLD', 'DEU'\n     *\n     * @see [ISO 3166-1 alpha-3 codes](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3)\n     */\n    countryCodeISO3?: string;\n\n    /**\n     * Full name of the first-level administrative subdivision.\n     *\n     * Present when countrySubdivision is abbreviated. Supported for USA, Canada, and Great Britain.\n     * Example: \"California\" when countrySubdivision is \"CA\"\n     */\n    countrySubdivisionName?: string;\n\n    /**\n     * Local area or locality name.\n     *\n     * Represents a named geographic area that groups addressable objects\n     * without being an official administrative unit.\n     */\n    localName?: string;\n};\n\n/**\n * Common properties shared by all place types.\n *\n * Provides the base structure for place information including address,\n * entry points, POI details, and data source references.\n *\n * @group Place\n */\nexport type CommonPlaceProps = {\n    /**\n     * Type classification of this place.\n     */\n    type: PlaceType;\n    /**\n     * Structured address components.\n     */\n    address: AddressProperties;\n    /**\n     * Geographic entity type(s).\n     *\n     * Present only when type === 'Geography'.\n     * Array can contain multiple types for areas with multiple administrative roles.\n     */\n    geographyType?: GeographyType[];\n    /**\n     * Mapcode representations of this location.\n     *\n     * Alternative location codes that can be used instead of coordinates.\n     */\n    mapcodes?: Mapcode[];\n    /**\n     * Physical entry points (entrances) to the place.\n     *\n     * Useful for navigation to direct users to the correct entrance.\n     */\n    entryPoints?: EntryPoint[];\n    /**\n     * Address ranges along a street segment.\n     *\n     * Present only when type === 'Address Range'.\n     */\n    addressRanges?: AddressRanges;\n    /**\n     * Point of Interest information.\n     *\n     * Present only when type === 'POI'. Contains business details, categories, hours, etc.\n     */\n    poi?: POI;\n    /**\n     * Related Points of Interest.\n     *\n     * Parent or child POIs (e.g., stores within a mall, a mall containing stores).\n     */\n    relatedPois?: RelatedPOI[];\n    /**\n     * EV charging infrastructure information.\n     *\n     * Present only for Electric Vehicle charging station POIs.\n     */\n    chargingPark?: ChargingPark;\n    /**\n     * References to additional data sources.\n     *\n     * IDs for fetching more detailed information from other services\n     * (geometry, availability, POI details).\n     */\n    dataSources?: PlaceDataSources;\n};\n\n/**\n * Side of the street indicator.\n *\n * @remarks\n * - `L`: Left side\n * - `R`: Right side\n *\n * @group Place\n */\nexport type SideOfStreet = 'L' | 'R';\n\n/**\n * Properties for reverse geocoded places.\n *\n * Extends common place properties with reverse geocoding-specific information\n * like the original query position and address interpolation details.\n *\n * @group Place\n */\nexport type RevGeoAddressProps = CommonPlaceProps & {\n    /**\n     * Original coordinates used in the reverse geocoding query [longitude, latitude].\n     */\n    originalPosition: Position;\n    /**\n     * Offset position coordinates for address interpolation.\n     *\n     * Present when a street number was specified in the query.\n     * Represents the interpolated position of the specific address number.\n     */\n    offsetPosition?: Position;\n    /**\n     * Which side of the street the address is located on.\n     *\n     * Present only when a street number was specified in the query.\n     */\n    sideOfStreet?: SideOfStreet;\n};\n\n/**\n * Properties for search result places.\n *\n * Extends common place properties with search-specific information\n * like relevance scores and distances.\n *\n * @group Place\n */\nexport type SearchPlaceProps = CommonPlaceProps & {\n    /**\n     * Information about the original data source.\n     *\n     * Attribution or source identification for the result.\n     */\n    info?: string;\n    /**\n     * Relevance score for this search result.\n     *\n     * Higher scores indicate better match to the query criteria.\n     * Used for ranking search results.\n     */\n    score?: number;\n    /**\n     * Distance in meters to this result from the bias position.\n     *\n     * Present only when geoBias (position bias) was provided in the search.\n     */\n    distance?: number;\n};\n\n/**\n * GeoJSON Feature representing a place.\n *\n * A place is a Point feature with comprehensive location information\n * including address, coordinates, and metadata.\n *\n * @typeParam P - Type of the place properties (defaults to CommonPlaceProps)\n *\n * @example\n * ```typescript\n * const place: Place<SearchPlaceProps> = {\n *   type: 'Feature',\n *   id: 'place-123',\n *   geometry: { type: 'Point', coordinates: [4.9041, 52.3676] },\n *   properties: {\n *     type: 'POI',\n *     address: { freeformAddress: 'Dam, Amsterdam', ... },\n *     poi: { name: 'Dam Square', ... },\n *     score: 0.95\n *   }\n * };\n * ```\n *\n * @group Place\n */\nexport type Place<P extends CommonPlaceProps = CommonPlaceProps> = Omit<Feature<Point, P>, 'id'> & {\n    /**\n     * Unique identifier for this place.\n     *\n     * Required string ID (stricter than GeoJSON Feature's optional id).\n     */\n    id: string;\n};\n\n/**\n * GeoJSON FeatureCollection containing multiple places.\n *\n * Collection of place results from search or geocoding operations.\n *\n * @typeParam P - Type of individual place properties (defaults to CommonPlaceProps)\n * @typeParam FeatureCollectionProps - Type of collection-level properties\n *\n * @example\n * ```typescript\n * const places: Places<SearchPlaceProps> = {\n *   type: 'FeatureCollection',\n *   features: [\n *     { id: '1', type: 'Feature', geometry: {...}, properties: {...} },\n *     { id: '2', type: 'Feature', geometry: {...}, properties: {...} }\n *   ]\n * };\n * ```\n *\n * @group Place\n */\nexport type Places<P extends CommonPlaceProps = CommonPlaceProps, FeatureCollectionProps = unknown> = Omit<\n    FeatureCollectionWithProperties<Point, P, FeatureCollectionProps>,\n    'features'\n> & {\n    /**\n     * Array of place features.\n     *\n     * Each place has a required string ID.\n     */\n    features: Place<P>[];\n};\n","import type { ChargingSpeed, CommonPlaceProps, CurrentType, Place } from '..';\n\n/**\n * Available plug types for EV charging.\n * @group Route\n */\nexport const plugTypes = [\n    'Small_Paddle_Inductive',\n    'Large_Paddle_Inductive',\n    'IEC_60309_1_Phase',\n    'IEC_60309_3_Phase',\n    'IEC_62196_Type_1_Outlet',\n    'IEC_62196_Type_2_Outlet',\n    'IEC_62196_Type_3_Outlet',\n    'IEC_62196_Type_1_Connector_Cable_Attached',\n    'IEC_62196_Type_2_Connector_Cable_Attached',\n    'IEC_62196_Type_3_Connector_Cable_Attached',\n    'Combo_to_IEC_62196_Type_1_Base',\n    'Combo_to_IEC_62196_Type_2_Base',\n    'Type_E_French_Standard_CEE_7_5',\n    'Type_F_Schuko_CEE_7_4',\n    'Type_G_British_Standard_BS_1363',\n    'Type_J_Swiss_Standard_SEV_1011',\n    'China_GB_Part_2',\n    'China_GB_Part_3',\n    'IEC_309_DC_Plug',\n    'AVCON_Connector',\n    'Tesla_Connector',\n    'NEMA_5_20',\n    'CHAdeMO',\n    'SAE_J1772',\n    'TEPCO',\n    'Better_Place_Socket',\n    'Marechal_Socket',\n    'Standard_Household_Country_Specific',\n] as const;\n\n/**\n * Standard plug/connector type for electric vehicle charging.\n *\n * Defines the physical connector type used for charging, which must match\n * the vehicle's charging port. Different regions and manufacturers use different standards.\n *\n * @remarks\n * Common standards include:\n * - **IEC 62196 Types**: European and international standards (Type 1, Type 2, Type 3)\n * - **CHAdeMO**: Japanese DC fast charging standard\n * - **CCS (Combo)**: Combined charging system (AC + DC)\n * - **Tesla_Connector**: Tesla proprietary connector\n * - **SAE_J1772**: North American standard for AC charging\n * - **China_GB**: Chinese national standard\n * - **NEMA**: North American standard household outlets\n *\n * Different vehicles support different plug types, and charging stations may have multiple\n * connector types available.\n *\n * @example\n * ```typescript\n * // Common connector types\n * const type2: PlugType = 'IEC_62196_Type_2_Connector_Cable_Attached';  // Common in Europe\n * const chademo: PlugType = 'CHAdeMO';  // Japanese standard\n * const ccs: PlugType = 'Combo_to_IEC_62196_Type_2_Base';  // CCS Combo 2\n * const tesla: PlugType = 'Tesla_Connector';  // Tesla vehicles\n * ```\n *\n * @group Route\n */\nexport type PlugType = (typeof plugTypes)[number];\n\n/**\n * Information about a specific charging connection at a charging point.\n *\n * Describes the technical specifications of a charging connector including\n * plug type, voltage, current, and power ratings.\n *\n * @group Route\n */\nexport type ChargingConnectionInfo = {\n    /**\n     * The plug type for this charging connection.\n     *\n     * Must be compatible with the vehicle's charging port.\n     */\n    plugType: PlugType;\n    /**\n     * The rated voltage in volts (V) of the charging process.\n     *\n     * Common values: 120V, 240V (AC), 400V, 800V (DC)\n     */\n    voltageInV?: number;\n    /**\n     * The rated current in amperes (A) of the charging process.\n     *\n     * Determines the charging speed along with voltage.\n     */\n    currentInA?: number;\n    /**\n     * The current type (AC/DC) for this charging connection.\n     *\n     * - AC: Alternating current (slower charging, 1-phase or 3-phase)\n     * - DC: Direct current (fast charging)\n     */\n    currentType?: CurrentType;\n    /**\n     * The rated maximum power in kilowatts (kW) of the charging connection.\n     *\n     * Indicates the maximum charging speed. Common values:\n     * - 3-7 kW: Level 1/2 AC charging\n     * - 7-22 kW: Level 2 AC charging\n     * - 50-350 kW: DC fast charging\n     */\n    chargingPowerInkW?: number;\n\n    /**\n     * The charging speed classification of this charging connection.\n     *\n     * @remarks\n     * - `slow`: Typically up to 12 kW (Level 1 AC charging)\n     * - `regular`: Typically between 12 kW and 50 kW (Level 2 AC charging)\n     * - `fast`: Typically between 50 kW and 150 kW (DC fast charging)\n     * - `ultra-fast`: Typically above 150 kW (High-power DC fast charging)\n     */\n    chargingSpeed?: ChargingSpeed;\n};\n\n/**\n * Available payment methods for electric vehicle charging stations.\n *\n * Defines the types of payment accepted at charging locations.\n *\n * @remarks\n * - `No_Payment`: Free charging, no payment required\n * - `Subscription`: Requires a subscription or membership plan\n * - `Direct`: Pay-per-use, direct payment (credit card, app, etc.)\n *\n * @group Route\n */\nexport const paymentMethods = ['No_Payment', 'Subscription', 'Direct'] as const;\n\n/**\n * Payment method type for electric vehicle charging stations.\n *\n * Specifies how users can pay for charging services at a particular station.\n *\n * @example\n * ```typescript\n * const method: PaymentMethod = 'Subscription';\n * ```\n *\n * @group Route\n */\nexport type PaymentMethod = (typeof paymentMethods)[number];\n\n/**\n * Payment option configuration for a charging station.\n *\n * Describes a specific payment method and associated payment brands/networks\n * accepted at a charging location.\n *\n * @remarks\n * The `brands` array may include specific payment network names or provider brands\n * that are accepted when using the specified payment method.\n *\n * @example\n * ```typescript\n * // Credit card payment with specific brands\n * const paymentOption: ChargingPaymentOption = {\n *   method: 'Direct',\n *   brands: ['Visa', 'Mastercard', 'American Express']\n * };\n *\n * // Subscription-based payment\n * const subscriptionOption: ChargingPaymentOption = {\n *   method: 'Subscription',\n *   brands: ['ChargePoint', 'EVgo']\n * };\n * ```\n *\n * @group Route\n */\nexport type ChargingPaymentOption = {\n    /**\n     * The payment method type accepted at this charging station.\n     */\n    method: PaymentMethod;\n    /**\n     * Optional list of specific payment brands or networks accepted.\n     *\n     * Examples: credit card brands (Visa, Mastercard), charging networks\n     * (ChargePoint, EVgo), or payment apps (Apple Pay, Google Pay).\n     */\n    brands?: string[];\n};\n\n/**\n * Properties specific to charging stops in electric vehicle routes.\n *\n * These properties are combined with {@link CommonPlaceProps} to form\n * a complete {@link ChargingStop} object.\n *\n * @group Route\n */\nexport type ChargingStopProps = CommonPlaceProps & {\n    /**\n     * Unique identifier for the charging park.\n     */\n    chargingParkId: string;\n    /**\n     * Array of available charging connections at this park.\n     *\n     * Each connection specifies plug type, power ratings, and current type.\n     */\n    chargingConnections: ChargingConnectionInfo[];\n    /**\n     * Estimated time in seconds required to charge the battery at this stop.\n     *\n     * Calculated based on:\n     * - Current battery charge level\n     * - Target charge level for next leg\n     * - Charging power of the selected connector\n     * - Battery charging curve characteristics\n     */\n    chargingTimeInSeconds: number;\n\n    /**\n     * The unique UUID identifier of this charging park.\n     *\n     * This universally unique identifier can be used to:\n     * - Check real-time availability of charging stations\n     * - Query detailed charging park information\n     * - Track charging park status and updates\n     * - Cross-reference with TomTom EV Charging Stations API\n     *\n     * @remarks\n     * Use this UUID with the EV Charging Stations Availability API to get\n     * real-time connector availability before arriving at the charging stop.\n     *\n     * @example\n     * ```typescript\n     * // Use UUID to check availability\n     * const availability = await evChargingAvailability.get({\n     *   chargingAvailability: chargingStop.chargingParkUuid\n     * });\n     * ```\n     */\n    chargingParkUuid: string;\n\n    /**\n     * Detailed information about the recommended charging connection for this stop.\n     *\n     * Specifies which connector type, power level, and charging specifications\n     * should be used at this charging park for optimal charging.\n     *\n     * @remarks\n     * This is typically the best connector available that matches:\n     * - Vehicle's charging capabilities\n     * - Required charging speed for the journey\n     * - Availability at the charging park\n     */\n    chargingConnectionInfo?: ChargingConnectionInfo;\n\n    /**\n     * The common name of this charging park.\n     *\n     * A human-readable name for the charging location, often including nearby\n     * landmarks, business names, or descriptive identifiers.\n     *\n     * @example\n     * ```typescript\n     * chargingParkName: \"Amsterdam Central Station - North Side\"\n     * chargingParkName: \"Shell Recharge - Highway A2\"\n     * ```\n     */\n    chargingParkName?: string;\n\n    /**\n     * The charging network operator or provider name.\n     *\n     * Identifies the company or organization that operates this charging park.\n     *\n     * @remarks\n     * Common operators include: Shell Recharge, Ionity, ChargePoint, EVgo,\n     * Tesla Supercharger, Fastned, etc.\n     *\n     * @example\n     * ```typescript\n     * chargingParkOperatorName: \"Ionity\"\n     * chargingParkOperatorName: \"Shell Recharge\"\n     * ```\n     */\n    chargingParkOperatorName?: string;\n\n    /**\n     * Maximum available charging power at this charging park in kilowatts (kW).\n     *\n     * Represents the highest power output available across all charging connections\n     * at this location. Actual charging power may be lower depending on:\n     * - Vehicle capabilities\n     * - Selected connector type\n     * - Battery state of charge\n     * - Grid conditions\n     *\n     * @remarks\n     * This is typically the power of the fastest charger at the park.\n     *\n     * @example\n     * ```typescript\n     * // A charging park with multiple chargers\n     * chargingParkPowerInkW: 150 // Has at least one 150kW charger\n     * ```\n     */\n    chargingParkPowerInkW?: number;\n\n    /**\n     * The best charging speed classification of this charging park amongst its connectors.\n     *\n     * @remarks\n     * - `slow`: Typically up to 12 kW (Level 1 AC charging)\n     * - `regular`: Typically between 12 kW and 50 kW (Level 2 AC charging)\n     * - `fast`: Typically between 50 kW and 150 kW (DC fast charging)\n     * - `ultra-fast`: Typically above 150 kW (High-power DC fast charging)\n     */\n    chargingParkSpeed?: ChargingSpeed;\n\n    /**\n     * The source of the charging stop at the end of this leg.\n     *\n     * Indicates whether the charging stop was automatically calculated by the\n     * routing engine or explicitly specified by the user.\n     *\n     * @remarks\n     * - `Auto_Generated`: The routing engine selected this charging stop to optimize the route\n     * - `User_Defined`: The user explicitly requested a charging stop at this location\n     */\n    chargingStopType?: 'Auto_Generated' | 'User_Defined';\n\n    /**\n     * Available payment options at this charging park.\n     *\n     * Lists the payment methods accepted at this charging location.\n     * Multiple options may be available.\n     */\n    chargingParkPaymentOptions?: ChargingPaymentOption[];\n\n    /**\n     * Target battery charge level in kilowatt-hours (kWh) after charging.\n     *\n     * The routing engine determines the optimal charge level to minimize\n     * total journey time while ensuring the vehicle can reach the next stop.\n     */\n    targetChargeInkWh: number;\n    /**\n     * Target battery charge level as a percentage of maximum capacity.\n     *\n     * Derived from targetChargeInkWh and the vehicle's maximum battery capacity.\n     *\n     * @example\n     * ```typescript\n     * // If maxChargeInkWh is 100 and targetChargeInkWh is 80\n     * targetChargeInPCT // 80\n     * ```\n     */\n    targetChargeInPCT?: number;\n};\n\n/**\n * Information about a battery charging stop along an electric vehicle route.\n *\n * A GeoJSON Feature representing a charging location where an EV needs to stop\n * and recharge during a long-distance journey (LDEVR - Long Distance EV Routing).\n *\n * @remarks\n * **Structure:**\n * - Extends {@link Place} (GeoJSON Feature with Point geometry)\n * - Includes all {@link CommonPlaceProps} (type, address, poi, chargingPark, etc.)\n * - Adds charging-specific properties from {@link ChargingStopProps}\n *\n * **When Provided:**\n * - For EV routes where charging is needed to reach the destination\n * - At the end of route legs where battery charge is insufficient for the next leg\n * - Contains both required and optional charging stop details\n *\n * **Key Properties:**\n * - `id`: Unique string identifier for this feature, corresponds to charging park ID.\n * - `type`: Always 'Feature' (GeoJSON)\n * - `geometry`: Point geometry with charging park coordinates [longitude, latitude]\n * - `properties`: Combined common place properties and charging-specific details\n *   - Standard place info: `type`, `address`, `poi`, `chargingPark`\n *   - Charging details: `chargingParkId`, `chargingParkUuid`, `chargingConnections`\n *   - Route planning: `chargingTimeInSeconds`, `targetChargeInkWh`, `targetChargeInPCT`\n *   - Metadata: `chargingParkName`, `chargingParkOperatorName`, `chargingParkPowerInkW`\n *\n * @example\n * ```typescript\n * const chargingStop: ChargingStop = {\n *   id: 'charging-stop-1',\n *   type: 'Feature',\n *   geometry: {\n *     type: 'Point',\n *     coordinates: [4.8945, 52.3667]\n *   },\n *   properties: {\n *     // CommonPlaceProps\n *     type: 'POI',\n *     address: {\n *       freeformAddress: 'Amsterdam Central Station',\n *       municipality: 'Amsterdam',\n *       country: 'Netherlands'\n *     },\n *     // ChargingStopProps\n *     chargingParkId: 'park123',\n *     chargingParkUuid: 'uuid-123-456',\n *     chargingParkName: 'Amsterdam Central Station - North Side',\n *     chargingParkOperatorName: 'Ionity',\n *     chargingConnections: [{\n *       plugType: 'IEC_62196_Type_2_Connector_Cable_Attached',\n *       chargingPowerInkW: 150,\n *       currentType: 'DC'\n *     }],\n *     chargingTimeInSeconds: 1200,\n *     chargingParkPowerInkW: 150,\n *     chargingStopType: 'Auto_Generated',\n *     targetChargeInkWh: 75,\n *     targetChargeInPCT: 75\n *   }\n * };\n * ```\n *\n * @group Route\n */\nexport type ChargingStop = Place<ChargingStopProps>;\n","import type { Feature, LineString } from 'geojson';\nimport type { FeatureCollectionWithProperties } from '../extendedGeoJSON';\nimport type { Guidance } from './guidance';\nimport type { SectionsProps } from './sections';\nimport type { RouteSummary } from './summary';\n\n/**\n * Array of all available route avoidance options.\n *\n * This constant defines the complete set of road/route features that can be avoided\n * during route calculation. Use this to derive the {@link Avoidable} type or to validate\n * user input against supported avoidance options.\n *\n * @remarks\n * This is a readonly tuple used as the source of truth for valid avoidance types.\n * The {@link Avoidable} type is derived from this array to ensure type safety.\n *\n * @example\n * ```typescript\n * // Check if a string is a valid avoidance type\n * const userInput = 'tollRoads';\n * if (avoidableTypes.includes(userInput as Avoidable)) {\n *   // userInput is valid\n * }\n *\n * // Iterate over all available options\n * avoidableTypes.forEach(type => {\n *   console.log(`Available option: ${type}`);\n * });\n * ```\n *\n * @group Route\n */\nexport const avoidableTypes = [\n    'tollRoads',\n    'motorways',\n    'ferries',\n    'unpavedRoads',\n    'carpools',\n    'alreadyUsedRoads',\n    'borderCrossings',\n    'tunnels',\n    'carTrains',\n    'lowEmissionZones',\n] as const;\n\n/**\n * Route features that the routing engine will attempt to avoid when calculating routes.\n *\n * Use these options to customize routes based on vehicle capabilities, user preferences,\n * or regulatory requirements. Note that avoidance is not guaranteed if no alternative route exists.\n *\n * @remarks\n * Available avoidance options:\n * - `tollRoads`: Avoids roads requiring toll payments\n * - `motorways`: Avoids high-speed limited-access highways (useful for scenic routes or vehicle restrictions)\n * - `ferries`: Avoids water crossings requiring ferry transport\n * - `unpavedRoads`: Avoids unpaved/dirt roads (recommended for standard vehicles)\n * - `carpools`: Avoids carpool/HOV (High Occupancy Vehicle) lanes\n * - `alreadyUsedRoads`: Prevents using the same road segment multiple times (useful for delivery routes)\n * - `borderCrossings`: Avoids crossing international borders (useful for customs/visa considerations)\n * - `tunnels`: Avoids underground tunnels (useful for vehicles carrying hazardous materials)\n * - `carTrains`: Avoids car train transport segments\n * - `lowEmissionZones`: Avoids zones with vehicle emission restrictions\n *\n * @example\n * ```typescript\n * // Avoid tolls and motorways for a scenic route\n * const avoid: Avoidable[] = ['tollRoads', 'motorways'];\n *\n * // Avoid unpaved roads for a standard car\n * const avoid: Avoidable[] = ['unpavedRoads'];\n * ```\n *\n * @group Route\n */\nexport type Avoidable = (typeof avoidableTypes)[number];\n\n/**\n * Primary mode of transportation for route calculation.\n *\n * Currently only `'car'` is supported. This determines road type preferences,\n * speed calculations, and routing rules applied to the calculated route.\n *\n * @remarks\n * Future versions may support additional modes like truck, taxi, bus, bicycle, and pedestrian.\n *\n * @example\n * ```typescript\n * const travelMode: TravelMode = 'car';\n * ```\n *\n * @group Route\n */\nexport type TravelMode = 'car'; // TODO no longer supported | \"truck\" | \"taxi\" | \"bus\" | \"van\" | \"motorcycle\" | \"bicycle\" | \"pedestrian\";\n\n/**\n * Progress information for a specific point along the route.\n *\n * Contains cumulative distance and time measurements from the route start to this point.\n *\n * @group Route\n */\nexport type RouteProgressPoint = {\n    /**\n     * Zero-based index of this point in the route's coordinate array.\n     */\n    pointIndex: number;\n    /**\n     * Cumulative travel time in seconds from the route start to this point.\n     */\n    travelTimeInSeconds?: number;\n    /**\n     * Cumulative distance in meters from the route start to this point.\n     */\n    distanceInMeters?: number;\n};\n\n/**\n * Array of progress points along the route path.\n *\n * Provides distance and time information at key points along the route.\n * This field is included when `extendedRouteRepresentations` is requested.\n *\n * @remarks\n * - Always contains entries for the first and last points in the route\n * - Progress for intermediate points can be linearly interpolated between explicitly defined points\n * - Use the Haversine formula for distance calculations between points\n *\n * @example\n * ```typescript\n * const progress: RouteProgress = [\n *   { pointIndex: 0, travelTimeInSeconds: 0, distanceInMeters: 0 },\n *   { pointIndex: 50, travelTimeInSeconds: 120, distanceInMeters: 2500 },\n *   { pointIndex: 100, travelTimeInSeconds: 300, distanceInMeters: 5000 }\n * ];\n * ```\n *\n * @group Route\n */\nexport type RouteProgress = RouteProgressPoint[];\n\n/**\n * Properties object for a calculated route.\n *\n * Contains all route information including summary statistics, sections,\n * guidance instructions, and progress data.\n *\n * @group Route\n */\nexport type RouteProps = {\n    /**\n     * Unique identifier for this route.\n     *\n     * Randomly generated to distinguish between multiple route alternatives.\n     */\n    id: string;\n    /**\n     * Summary statistics for the entire route.\n     *\n     * Contains departure/arrival times, total length, duration, and consumption estimates.\n     */\n    summary: RouteSummary;\n    /**\n     * Route sections with specific characteristics.\n     *\n     * Sections represent portions of the route with distinct properties such as:\n     * - Countries traversed\n     * - Traffic incidents\n     * - Route legs (segments between waypoints)\n     * - Special road types (tunnels, ferries, toll roads)\n     */\n    sections: SectionsProps;\n    /**\n     * Turn-by-turn navigation instructions.\n     *\n     * Only present when guidance was requested and is available.\n     * Includes maneuvers, road names, and instruction text.\n     */\n    guidance?: Guidance;\n    /**\n     * Distance and time progress at key points along the route.\n     *\n     * Only present when extended route representations are requested.\n     * Useful for displaying progress information or calculating intermediate times.\n     */\n    progress?: RouteProgress;\n    /**\n     * Index of this route in the collection of alternatives.\n     *\n     * The first route (index 0) is typically the recommended/best route.\n     * Subsequent indices represent alternative routes.\n     */\n    index: number;\n};\n\n/**\n * GeoJSON Feature representing a calculated route.\n *\n * The geometry is a LineString containing the route path coordinates.\n * The properties contain all route information (summary, sections, guidance).\n *\n * @typeParam P - Type of the route properties (defaults to RouteProps)\n *\n * @example\n * ```typescript\n * const route: Route = {\n *   type: 'Feature',\n *   geometry: {\n *     type: 'LineString',\n *     coordinates: [[4.9, 52.3], [4.91, 52.31], ...]\n *   },\n *   properties: {\n *     id: 'route-123',\n *     summary: { lengthInMeters: 5000, travelTimeInSeconds: 300, ... },\n *     sections: { ... },\n *     index: 0\n *   }\n * };\n * ```\n *\n * @group Route\n */\nexport type Route<P extends RouteProps = RouteProps> = Feature<LineString, P>;\n\n/**\n * GeoJSON FeatureCollection containing one or more calculated routes.\n *\n * Typically contains the main route (index 0) and optional alternative routes.\n * Collection properties can include metadata about the routing request.\n *\n * @typeParam P - Type of individual route properties (defaults to RouteProps)\n * @typeParam FeatureCollectionProps - Type of collection-level properties\n *\n * @example\n * ```typescript\n * const routes: Routes = {\n *   type: 'FeatureCollection',\n *   features: [\n *     { type: 'Feature', geometry: {...}, properties: { index: 0, ... } }, // Main route\n *     { type: 'Feature', geometry: {...}, properties: { index: 1, ... } }  // Alternative\n *   ],\n *   properties: {\n *     requestId: 'req-456',\n *     calculatedAt: new Date()\n *   }\n * };\n * ```\n *\n * @group Route\n */\nexport type Routes<\n    P extends RouteProps = RouteProps,\n    FeatureCollectionProps = unknown,\n> = FeatureCollectionWithProperties<LineString, P, FeatureCollectionProps>;\n","import type { RoadShieldReference } from './guidance';\nimport type { LegSummary } from './summary';\n\n/**\n * Base properties for all route sections.\n *\n * Sections divide a route into portions with specific characteristics or attributes.\n * All section types extend this base with additional specialized properties.\n *\n * @group Route\n */\nexport type SectionProps = {\n    /**\n     * Unique identifier for this section.\n     *\n     * Randomly generated to distinguish between sections.\n     */\n    id: string;\n    /**\n     * Index of the route coordinate where this section begins.\n     *\n     * Zero-based index into the route's LineString coordinates array.\n     */\n    startPointIndex: number;\n    /**\n     * Index of the route coordinate where this section ends (inclusive).\n     *\n     * Zero-based index into the route's LineString coordinates array.\n     */\n    endPointIndex: number;\n    /**\n     * Elapsed time in seconds from route start to the beginning of this section.\n     */\n    startTravelTimeInSeconds?: number;\n    /**\n     * Elapsed time in seconds from route start to the end of this section.\n     */\n    endTravelTimeInSeconds?: number;\n    /**\n     * Duration in seconds to traverse this section.\n     *\n     * Calculated as: endTravelTimeInSeconds - startTravelTimeInSeconds\n     */\n    durationInSeconds?: number;\n    /**\n     * Cumulative distance in meters from route start to the beginning of this section.\n     */\n    startLengthInMeters?: number;\n    /**\n     * Cumulative distance in meters from route start to the end of this section.\n     */\n    endLengthInMeters?: number;\n    /**\n     * Length in meters of this section.\n     *\n     * Calculated as: endLengthInMeters - startLengthInMeters\n     */\n    lengthInMeters?: number;\n};\n\n/**\n * Route section representing passage through a country.\n *\n * Used to identify which countries the route traverses, useful for:\n * - Border crossing planning\n * - International routing costs\n * - Regulatory requirements\n *\n * @example\n * ```typescript\n * const countrySection: CountrySectionProps = {\n *   id: 'country-section-1',\n *   startPointIndex: 0,\n *   endPointIndex: 150,\n *   countryCodeISO3: 'NLD',  // Netherlands\n *   lengthInMeters: 25000\n * };\n * ```\n *\n * @group Route\n */\nexport type CountrySectionProps = SectionProps & {\n    /**\n     * Three-letter ISO 3166-1 alpha-3 country code.\n     *\n     * Examples: 'USA', 'GBR', 'NLD', 'DEU', 'FRA'\n     *\n     * @see [ISO 3166-1 alpha-3 codes](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3)\n     */\n    countryCodeISO3: string;\n};\n\n/**\n * Sections with important stretches of road information.\n *\n * * It provides a set of street names and/or a set of road numbers that allow the driver to identify and distinguish the course of the route (from other potential routes).\n *\n * @group Route\n */\nexport type ImportantRoadStretchProps = SectionProps & {\n    /**\n     * The integer value of importance. The index starts from 0, and a lower value means higher importance. The index is needed for two reasons:\n     * * To understand which stretch is the most important (for example, if it is necessary to display a smaller number of stretches).\n     * * To group different sections that belong to the same stretch (since there may be gaps in one stretch for various reasons).\n     */\n    index: number;\n    /**\n     * The street name of the important road stretch.\n     */\n    streetName?: string;\n    /**\n     * A set of road numbers that identify the important road stretch.\n     *\n     * @remarks\n     * The road numbers are sorted in descending order of display priority.\n     */\n    roadNumbers?: string[];\n};\n\n/**\n * All possible traffic incident categories.\n * @group Route\n */\nexport const trafficCategories = [\n    'jam',\n    'accident',\n    'roadworks',\n    'road-closed',\n    'narrow-lanes',\n    'danger',\n    'animals-on-road',\n    'broken-down-vehicle',\n    'lane-closed',\n    'wind',\n    'fog',\n    'rain',\n    'frost',\n    'flooding',\n    'other',\n] as const;\n\n/**\n * Simple category classification for traffic incidents.\n *\n * @remarks\n * - `jam`: Traffic congestion or slow-moving traffic\n * - `accident`: Traffic accident or collision\n * - `roadworks`: Construction or maintenance work\n * - `road-closed`: Road is closed or blocked\n * - `danger`: Dangerous situation on the road\n * - `broken-down-vehicle`: Vehicle breakdown causing obstruction\n * - `lane-closed`: One or more lanes closed\n * - `wind`: Strong wind conditions affecting traffic\n * - `fog`: Fog reducing visibility\n * - `rain`: Heavy rain affecting driving conditions\n * - `frost`: Frost or ice on the road\n * - `flooding`: Flooded road section\n * - `other`: Other types of incidents\n *\n * @group Route\n */\nexport type TrafficCategory = (typeof trafficCategories)[number];\n\n/**\n * Severity of the traffic delay.\n *\n * @remarks\n * - `unknown`: Delay magnitude cannot be determined\n * - `minor`: Small delay (few minutes)\n * - `moderate`: Noticeable delay (several minutes to ~10 minutes)\n * - `major`: Significant delay (10+ minutes)\n * - `indefinite`: Unknown or extremely long delay (e.g., road closure)\n *\n * @group Route\n */\nexport type DelayMagnitude = 'unknown' | 'minor' | 'moderate' | 'major' | 'indefinite';\n\n/**\n * Traffic incident cause based on TPEG2-TEC standard.\n *\n * TPEG (Transport Protocol Experts Group) codes provide standardized\n * classification of traffic incident causes.\n *\n * @see [TPEG2-TEC Standard](https://www.iso.org/standard/59231.html)\n *\n * @group Route\n */\nexport type CauseTEC = {\n    /**\n     * Main cause code from TPEG2-TEC standard.\n     *\n     * Primary classification of what caused the incident.\n     */\n    mainCauseCode: number;\n    /**\n     * Optional sub-cause code from TPEG2-TEC standard.\n     *\n     * More specific classification under the main cause.\n     */\n    subCauseCode?: number;\n};\n\n/**\n * Traffic incident information based on TPEG2-TEC standard.\n *\n * Provides standardized classification of traffic flow effects and causes.\n *\n * @group Route\n */\nexport type TrafficIncidentTEC = {\n    /**\n     * Effect code describing impact on traffic flow.\n     *\n     * TPEG2-TEC standard code indicating how traffic is affected.\n     */\n    effectCode?: number;\n    /**\n     * List of causes for this traffic incident.\n     *\n     * Array of cause elements with at least one entry. Multiple causes\n     * may contribute to a single traffic incident.\n     */\n    causes?: [CauseTEC, ...CauseTEC[]];\n};\n\n/**\n * Route section affected by a traffic incident.\n *\n * Represents a portion of the route experiencing traffic delays due to\n * congestion, accidents, construction, or other incidents.\n *\n * @example\n * ```typescript\n * const trafficSection: TrafficSectionProps = {\n *   id: 'traffic-1',\n *   startPointIndex: 50,\n *   endPointIndex: 75,\n *   simpleCategory: 'jam',\n *   magnitudeOfDelay: 'moderate',\n *   delayInSeconds: 420,  // 7 minutes\n *   effectiveSpeedInKmh: 25,\n *   tec: { effectCode: 1, causes: [{ mainCauseCode: 101 }] }\n * };\n * ```\n *\n * @group Route\n */\nexport type TrafficSectionProps = SectionProps & {\n    /**\n     * Categories of the incident. Based on the 'tec' cause codes.\n     */\n    categories: TrafficCategory[];\n    /**\n     * Severity level of the delay caused by this incident.\n     */\n    magnitudeOfDelay: DelayMagnitude;\n    /**\n     * TPEG2-TEC standardized incident information.\n     *\n     * Provides internationally standardized codes for traffic incident classification.\n     */\n    tec: TrafficIncidentTEC;\n    /**\n     * Actual average speed through this incident in km/h.\n     *\n     * Present when speed information is available. Lower speeds indicate worse congestion.\n     */\n    effectiveSpeedInKmh?: number;\n    /**\n     * Additional delay in seconds caused by this incident.\n     *\n     * Extra time compared to free-flow conditions. Present when delay can be calculated.\n     */\n    delayInSeconds?: number;\n};\n\n/**\n * Route section representing a leg between waypoints.\n *\n * A leg is the portion of route between two consecutive non-circle waypoints.\n * This is a top-level section that encompasses the entire journey segment.\n *\n * @remarks\n * Leg examples:\n * - AB route: 1 leg (A to B)\n * - ABC route: 2 legs (A to B, then B to C)\n * - AB(circle)C route: 2 legs (A to B, then B to C) - circle waypoint doesn't create a leg\n *\n * @example\n * ```typescript\n * const leg: LegSectionProps = {\n *   id: 'leg-1',\n *   summary: {\n *     departureTime: new Date(),\n *     arrivalTime: new Date(),\n *     lengthInMeters: 50000,\n *     travelTimeInSeconds: 3600,\n *     // ... other summary fields\n *   },\n *   startPointIndex: 0,\n *   endPointIndex: 250\n * };\n * ```\n *\n * @group Route\n */\nexport type LegSectionProps = Omit<SectionProps, 'startPointIndex' | 'endPointIndex'> & {\n    /**\n     * Index where this leg starts in the route coordinates.\n     *\n     * Only present if the route polyline geometry is available.\n     */\n    startPointIndex?: number;\n    /**\n     * Index where this leg ends in the route coordinates.\n     *\n     * Only present if the route polyline geometry is available.\n     */\n    endPointIndex?: number;\n    /**\n     * Summary statistics for this leg.\n     *\n     * Contains departure/arrival times, distances, durations, and consumption\n     * estimates specifically for this leg of the journey.\n     */\n    summary: LegSummary;\n};\n\n/**\n * Possible directions a lane can lead to.\n *\n * Used in lane guidance to indicate which directions are possible from a lane.\n *\n * @group Route\n */\nexport type PossibleLaneDirection =\n    | 'STRAIGHT'\n    | 'SLIGHT_RIGHT'\n    | 'RIGHT'\n    | 'SHARP_RIGHT'\n    | 'RIGHT_U_TURN'\n    | 'SLIGHT_LEFT'\n    | 'LEFT'\n    | 'SHARP_LEFT'\n    | 'LEFT_U_TURN';\n\n/**\n * Lane guidance information.\n *\n * Describes possible directions for a lane and which direction to follow.\n * Used for lane-level navigation guidance.\n *\n * @example\n * ```typescript\n * // Left lane allows left turn or straight\n * const laneDirection: LaneDirection = {\n *   directions: ['LEFT', 'STRAIGHT'],\n *   follow: 'LEFT'  // Follow the left turn\n * };\n * ```\n *\n * @group Route\n */\nexport type LaneDirection = {\n    /**\n     * All possible directions this lane leads to.\n     *\n     * A lane may allow multiple directions (e.g., straight and turn).\n     */\n    directions: PossibleLaneDirection[];\n    /**\n     * The direction to follow in this lane for the route.\n     *\n     * Present when guidance indicates which direction to take.\n     */\n    follow?: PossibleLaneDirection;\n};\n\n/**\n * All the possible lane separators.\n * @group Route\n */\nexport type PossibleLaneSeparator =\n    | 'UNKNOWN'\n    | 'NO_MARKING'\n    | 'LONG_DASHED'\n    | 'DOUBLE_SOLID'\n    | 'SINGLE_SOLID'\n    | 'SOLID_DASHED'\n    | 'DASHED_SOLID'\n    | 'SHORT_DASHED'\n    | 'SHADED_AREA_MARKING'\n    | 'DASHED_BLOCKS'\n    | 'DOUBLE_DASHED'\n    | 'CROSSING_ALERT'\n    | 'PHYSICAL_DIVIDER'\n    | 'PHYSICAL_DIVIDER_LESS_THAN_3M'\n    | 'PHYSICAL_DIVIDER_GUARDRAIL'\n    | 'CURB';\n/**\n * Section representing a lane configuration.\n * @group Route\n */\nexport type LaneSectionProps = SectionProps & {\n    /**\n     * The lane directions for this lane section.\n     */\n    lanes: LaneDirection[];\n    /**\n     * The lane separators for this lane section.\n     */\n    laneSeparators: PossibleLaneSeparator[];\n    /**\n     * Properties of the lane section, as a possible combination of several values. This field is optional.\n     * Possible values:\n     * IS_MANEUVER: whether the lane section contains a maneuver point, that is, there exists a guidance instruction\n     * with a maneuverPoint that falls into this section. The section describes the lane configuration for that\n     * particular instruction.\n     * It is possible that more values will be added to the API in the future.\n     */\n    properties?: string[];\n};\n\n/**\n * Section representing a speed limit.\n * @group Route\n */\nexport type SpeedLimitSectionProps = SectionProps & {\n    /**\n     * The speed limit in km/h for this section.\n     */\n    maxSpeedLimitInKmh: number;\n};\n\n/**\n * Section representing a road shield.\n * @group Route\n */\nexport type RoadShieldSectionProps = SectionProps & {\n    /**\n     * The road shield code for this section.\n     */\n    roadShieldReferences: RoadShieldReference[];\n};\n\n/**\n * Route sections are parts of the planned route that have specific characteristics,\n * such as ones on a ferry or motorway, or sections with traffic incidents in them.\n * Using sections, you can show users where these things lie on a planned route.\n * @group Route\n */\nexport type SectionsProps = {\n    leg: LegSectionProps[];\n    carTrain?: SectionProps[];\n    ferry?: SectionProps[];\n    motorway?: SectionProps[];\n    pedestrian?: SectionProps[];\n    toll?: SectionProps[];\n    tollVignette?: CountrySectionProps[];\n    country?: CountrySectionProps[];\n    traffic?: TrafficSectionProps[];\n    vehicleRestricted?: SectionProps[];\n    tunnel?: SectionProps[];\n    unpaved?: SectionProps[];\n    urban?: SectionProps[];\n    carpool?: SectionProps[];\n    lowEmissionZone?: SectionProps[];\n    lanes?: LaneSectionProps[];\n    roadShields?: RoadShieldSectionProps[];\n    speedLimit?: SpeedLimitSectionProps[];\n    importantRoadStretch?: ImportantRoadStretchProps[];\n};\n\n/**\n * @group Route\n */\nexport type SectionType = keyof SectionsProps;\n\n/**\n * Route calculation request section types so they can be included in response.\n * @group Route\n */\nexport const inputSectionTypes: SectionType[] = [\n    'carTrain',\n    'ferry',\n    'tunnel',\n    'motorway',\n    'pedestrian',\n    'toll',\n    'tollVignette',\n    'country',\n    'vehicleRestricted',\n    'traffic',\n    'carpool',\n    'urban',\n    'unpaved',\n    'lowEmissionZone',\n    'speedLimit',\n    'roadShields',\n    'importantRoadStretch',\n] as const;\n\n/**\n * Route calculation request section types, including guidance-related ones, so they can be included in response.\n * @group Route\n */\nexport const inputSectionTypesWithGuidance: SectionType[] = [...inputSectionTypes, 'lanes'] as const;\n\n/**\n * @group Route\n */\nexport const sectionTypes: SectionType[] = [...inputSectionTypesWithGuidance, 'leg'] as const;\n","/**\n * List of available views for geopolitical context.\n * @group Shared\n */\nexport const views = ['Unified', 'AR', 'IN', 'PK', 'IL', 'MA', 'RU', 'TR', 'CN'] as const;\n\n/**\n * Geopolitical view context for map display and data.\n *\n * Controls how disputed territories and borders are displayed on the map and in service responses.\n * Different countries may have different perspectives on territorial boundaries and place names.\n *\n * @remarks\n * - `Unified`: Default view with a neutral representation\n * - Country-specific codes (e.g., `AR`, `IN`, `PK`, etc.): Displays boundaries and names according to that country's perspective\n *\n * @example\n * ```typescript\n * // Use unified/neutral view\n * const view: View = 'Unified';\n *\n * // Use India's geopolitical perspective\n * const view: View = 'IN';\n *\n * // Use Argentina's perspective\n * const view: View = 'AR';\n * ```\n *\n * @group Shared\n */\nexport type View = (typeof views)[number];\n","import type {\n    BBox,\n    Feature,\n    FeatureCollection,\n    GeoJsonObject,\n    GeometryCollection,\n    LineString,\n    MultiPolygon,\n    Point,\n    Polygon,\n    Position,\n} from 'geojson';\nimport type { HasBBox, OptionalBBox } from '../types';\n\n/**\n * Calculates whether the given bbox has area (width and height).\n * @ignore\n * @param bbox The BBox to verify. If undefined, false is returned.\n */\nexport const isBBoxWithArea = (bbox: OptionalBBox): boolean =>\n    bbox ? bbox.length >= 4 && bbox[3] !== bbox[1] && bbox[2] !== bbox[0] : false;\n\n/**\n * Returns the given bbox if it has area, or undefined otherwise.\n * @ignore\n * @param bbox The BBox to verify. If undefined, undefined is returned.\n */\nexport const bboxOnlyIfWithArea = (bbox: OptionalBBox): OptionalBBox => (isBBoxWithArea(bbox) ? bbox : undefined);\n\n/**\n * Expands the given bounding box with the given position.\n * * If the given bounding box is undefined, the given position is considered alone.\n * This results in a zero-sized bounding box.\n * @ignore\n * @param positionToContain\n * @param bboxToExpand\n */\nexport const bboxExpandedWithPosition = (positionToContain: Position, bboxToExpand?: BBox): OptionalBBox => {\n    if (!positionToContain || positionToContain.length < 2) {\n        return undefined;\n    }\n    return bboxToExpand\n        ? [\n              // min longitude:\n              bboxToExpand[0] > positionToContain[0] ? positionToContain[0] : bboxToExpand[0],\n              // min latitude:\n              bboxToExpand[1] > positionToContain[1] ? positionToContain[1] : bboxToExpand[1],\n              // max longitude:\n              bboxToExpand[2] < positionToContain[0] ? positionToContain[0] : bboxToExpand[2],\n              // max latitude:\n              bboxToExpand[3] < positionToContain[1] ? positionToContain[1] : bboxToExpand[3],\n          ]\n        : // single point bbox with no size:\n          [positionToContain[0], positionToContain[1], positionToContain[0], positionToContain[1]];\n};\n\n/**\n * @ignore\n * @param bboxToContain\n * @param bboxToExpand\n */\nexport const bboxExpandedWithBBox = (bboxToContain: OptionalBBox, bboxToExpand?: BBox): OptionalBBox => {\n    if (!bboxToExpand || !bboxToContain) {\n        return bboxToContain || bboxToExpand;\n    }\n    return [\n        // min longitude:\n        bboxToExpand[0] > bboxToContain[0] ? bboxToContain[0] : bboxToExpand[0],\n        // min latitude:\n        bboxToExpand[1] > bboxToContain[1] ? bboxToContain[1] : bboxToExpand[1],\n        // max longitude:\n        bboxToExpand[2] < bboxToContain[2] ? bboxToContain[2] : bboxToExpand[2],\n        // max latitude:\n        bboxToExpand[3] < bboxToContain[3] ? bboxToContain[3] : bboxToExpand[3],\n    ];\n};\n\n/**\n * Calculates the bounding box which contains all the given bounding boxes.\n * @ignore\n * @param bboxes\n */\nexport const bboxFromBBoxes = (bboxes: OptionalBBox[]): OptionalBBox =>\n    bboxes?.length ? bboxes.reduce((previous, current) => bboxExpandedWithBBox(current, previous)) : undefined;\n\n/**\n * Calculates a bounding box from an array of coordinates.\n * * If the array is beyond a certain size, it doesn't scan it fully,\n * for performance, but still ensures a decent accuracy.\n *\n * @ignore\n * @param coordinates Should always be passed, but undefined is also supported, resulting in undefined bbox.\n */\nexport const bboxFromCoordsArray = (coordinates: Position[] | undefined): OptionalBBox => {\n    const length = coordinates?.length;\n    if (!length) {\n        return undefined;\n    }\n    let bbox: OptionalBBox;\n    const indexInterval = Math.ceil(length / 1000);\n    for (let i = 0; i < length; i += indexInterval) {\n        bbox = bboxExpandedWithPosition(coordinates[i], bbox);\n    }\n    // (we ensure that if we had intervals greater than 1, the last position is always included in the calculation)\n    return indexInterval === 1 ? bbox : bboxExpandedWithPosition(coordinates[length - 1], bbox);\n};\n\n/**\n * Extracts or calculates a bounding box from GeoJSON objects.\n *\n * This utility function handles various GeoJSON types and automatically determines\n * the best approach to obtain a bounding box:\n * - Uses existing `bbox` properties when available (fastest)\n * - Calculates from geometry coordinates when needed\n * - Aggregates bounding boxes from collections\n * - Optimizes large geometries by sampling points for performance\n *\n * The function prioritizes existing bbox fields over geometry calculations, which is\n * important for Point features from TomTom services that may have bbox representing\n * a broader area than just the point location.\n *\n * @param hasBBox A GeoJSON object (Feature, FeatureCollection, Geometry, etc.) or array of such objects\n * @returns The bounding box as `[minLng, minLat, maxLng, maxLat]`, or `undefined` if input is invalid\n *\n * @example\n * ```typescript\n * // From a Feature with existing bbox\n * const place = await geocode({ key: 'key', query: 'Amsterdam' });\n * const bbox = bboxFromGeoJSON(place);\n * // Returns the bbox that came with the place\n *\n * // From a Polygon geometry (calculates bbox)\n * const polygon = {\n *   type: 'Polygon',\n *   coordinates: [[\n *     [4.88, 52.36],\n *     [4.90, 52.36],\n *     [4.90, 52.38],\n *     [4.88, 52.38],\n *     [4.88, 52.36]\n *   ]]\n * };\n * const polyBbox = bboxFromGeoJSON(polygon);\n * // Returns: [4.88, 52.36, 4.90, 52.38]\n *\n * // From a FeatureCollection (aggregates all features)\n * const places = await search({ key: 'key', query: 'coffee' });\n * const collectionBbox = bboxFromGeoJSON(places);\n * // Returns bbox encompassing all search results\n *\n * // From a LineString (calculates from coordinates)\n * const route = await calculateRoute({\n *   key: 'key',\n *   locations: [[4.9, 52.3], [4.5, 51.9]]\n * });\n * const routeBbox = bboxFromGeoJSON(route.routes[0].geometry);\n * // Returns bbox containing the entire route\n *\n * // From an array of GeoJSON objects\n * const multiBbox = bboxFromGeoJSON([place1, place2, place3]);\n * // Returns bbox encompassing all three places\n * ```\n *\n * @group Shared\n */\nexport const bboxFromGeoJSON = (hasBBox: HasBBox): OptionalBBox => {\n    // Edge case:\n    if (!hasBBox) {\n        return undefined;\n    }\n    // Else...\n    // Already a BBox:\n    if (Array.isArray(hasBBox)) {\n        if (typeof hasBBox[0] === 'number') {\n            return hasBBox.length >= 4 ? (hasBBox as OptionalBBox) : undefined;\n        }\n        return bboxFromBBoxes(hasBBox.map((geoJsonItem) => bboxFromGeoJSON(geoJsonItem as GeoJsonObject)));\n    }\n    // Else...\n    // Already containing a BBox:\n    if (hasBBox.bbox) {\n        return hasBBox.bbox;\n    }\n    // Else...\n    // Needs direct or recursive bbox extraction/calculation:\n    switch (hasBBox.type) {\n        case 'Feature':\n            return bboxFromGeoJSON((hasBBox as Feature).geometry);\n        case 'FeatureCollection':\n            return bboxFromBBoxes((hasBBox as FeatureCollection).features.map(bboxFromGeoJSON));\n        case 'GeometryCollection':\n            return bboxFromBBoxes((hasBBox as GeometryCollection).geometries.map(bboxFromGeoJSON));\n        case 'Point':\n            return bboxExpandedWithPosition((hasBBox as Point).coordinates);\n        case 'LineString':\n        case 'MultiPoint':\n            // (LineString and MultiPoint both have the same coordinates type)\n            return bboxFromCoordsArray((hasBBox as LineString).coordinates);\n        case 'MultiLineString':\n        case 'Polygon':\n            // (MultiLineString and Polygon both have the same coordinates type)\n            return bboxFromBBoxes((hasBBox as Polygon).coordinates.map(bboxFromCoordsArray));\n        case 'MultiPolygon':\n            return bboxFromBBoxes(\n                (hasBBox as MultiPolygon).coordinates.flatMap((polygon) => polygon.map(bboxFromCoordsArray)),\n            );\n        default:\n            return undefined;\n    }\n};\n\n/**\n * Expands the given bounding box with the given GeoJSON.\n * * If the feature has also a bounding box, the latter is considered instead.\n * * If the given bounding box is undefined, the given point is considered alone.\n * This results in a zero-sized bounding box or the point bbox if it exists.\n * @ignore\n * @param geoJson\n * @param bboxToExpand\n */\nexport const bboxExpandedWithGeoJSON = (geoJson: GeoJsonObject, bboxToExpand?: BBox): OptionalBBox =>\n    bboxExpandedWithBBox(bboxFromGeoJSON(geoJson), bboxToExpand);\n\n/**\n * Calculate the center of bbox\n * @ignore\n * @param bbox\n * */\nexport const bboxCenter = (bbox: BBox): Position => [(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2];\n","/**\n * Generate random id for layers\n * @ignore\n */\nexport const generateId = () => Date.now().toString(36) + Math.random().toString(36).substring(2);\n","import type { GlobalConfig } from '../config/globalConfig';\nimport type { TomTomHeaders } from '../types';\n\n/**\n * SDK name used TomTom custom header TomTom-User-Agent\n * @ignore\n */\nexport const TOMTOM_USER_AGENT_SDK_NAME = 'MapsSDKJS';\n\n/**\n * Validate if the string to be used in the Tracking-ID header is valid.\n * The value must match the regular expression '^[a-zA-Z0-9-]{1,100}$'.\n * @see Tracking-ID: https://docs.tomtom.com/search-api/documentation/search-service/fuzzy-search#trackingid-request\n *\n * @param trackingId String to be validated\n */\nconst validateTrackingId = (trackingId: string): string => {\n    if (!/^[a-zA-Z0-9-]{1,100}$/.test(trackingId)) {\n        // If we send a invalid Tracking-ID value, a HTTP Bad Request 400 status code is\n        // returned and the request will fail. To avoid this issue, we throw an error before\n        // the request is made.\n        throw new TypeError(\n            `a string matching regular expression ^[a-zA-Z0-9-]{1,100}$ is expected, but ${trackingId} ['${typeof trackingId}'] given`,\n        );\n    }\n\n    return trackingId;\n};\n\n/**\n * Generates an object with TomTom custom header values for the given common parameters.\n *\n * @ignore\n * @param params Global SDK configuration\n */\nexport const generateTomTomHeaders = (params: Partial<GlobalConfig>): TomTomHeaders => ({\n    'TomTom-User-Agent': `${TOMTOM_USER_AGENT_SDK_NAME}/${__SDK_VERSION__}`,\n    // TODO: restore if we implement oauth2 access\n    // optional oauth2 access token:\n    // ...(params.apiAccessToken && { Authorization: `Bearer ${params.apiAccessToken}` }),\n    ...(params.trackingId && { 'Tracking-ID': validateTrackingId(params.trackingId) }),\n});\n","import type { Feature, Point, Position } from 'geojson';\nimport type { EntryPoint, GetPositionOptions, HasLngLat, Place } from '../types';\n\nconst getMainEntryPoint = (place: Place): EntryPoint | undefined =>\n    place?.properties?.entryPoints?.find((entryPoint) => entryPoint.type === 'main');\n\n/**\n * Extracts the lng-lat position from various input formats.\n *\n * This utility function accepts multiple formats and normalizes them to a standard\n * GeoJSON Position (lng-lat coordinate array). It handles:\n * - Raw coordinate arrays `[lng, lat]`\n * - GeoJSON Point geometries\n * - GeoJSON Point Features (including Places with entry points)\n *\n * @param hasLngLat An object which either is or contains a lng-lat position.\n * @param options Additional options to control how we extract the position.\n * @returns The extracted position as `[longitude, latitude]`, or `null` if the input is invalid.\n *\n * @example\n * ```typescript\n * // From coordinate array\n * getPosition([4.9, 52.3]); // Returns: [4.9, 52.3]\n *\n * // From Point geometry\n * getPosition({\n *   type: 'Point',\n *   coordinates: [4.9, 52.3]\n * }); // Returns: [4.9, 52.3]\n *\n * // From Point Feature\n * getPosition({\n *   type: 'Feature',\n *   geometry: { type: 'Point', coordinates: [4.9, 52.3] },\n *   properties: {}\n * }); // Returns: [4.9, 52.3]\n *\n * // From Place with entry point\n * const place = {\n *   type: 'Feature',\n *   geometry: { type: 'Point', coordinates: [4.9, 52.3] },\n *   properties: {\n *     entryPoints: [\n *       { type: 'main', position: [4.901, 52.301] }\n *     ]\n *   }\n * };\n * getPosition(place, { useEntryPoint: 'main-when-available' });\n * // Returns: [4.901, 52.301] (entry point instead of geometry)\n *\n * // Invalid input\n * getPosition(undefined); // Returns: null\n * ```\n *\n * @group Shared\n */\nexport const getPosition = (hasLngLat: HasLngLat | undefined, options?: GetPositionOptions): Position | null => {\n    if (hasLngLat) {\n        if (Array.isArray(hasLngLat)) {\n            // GeoJSON Position (lng-lat):\n            return hasLngLat;\n        }\n        if ((hasLngLat as Point).coordinates) {\n            // GeoJSON Point Geometry:\n            return (hasLngLat as Point).coordinates;\n        }\n        if ((hasLngLat as Feature).geometry) {\n            // GeoJSON Point Feature:\n            if (options?.useEntryPoint === 'main-when-available') {\n                const mainEntryPoint = getMainEntryPoint(hasLngLat as Place);\n                return mainEntryPoint?.position ?? (hasLngLat as Feature<Point>).geometry.coordinates;\n            }\n            return (hasLngLat as Feature<Point>).geometry.coordinates;\n        }\n    }\n    return null;\n};\n\n/**\n * Extracts the lng-lat position from various input formats (strict version).\n *\n * Similar to {@link getPosition}, but throws an error if the input doesn't contain\n * a valid position. Use this when you expect the input to always be valid and want\n * to fail fast on invalid data.\n *\n * @param hasLngLat An object which either is or contains a lng-lat position.\n * @param options Additional options to control how we extract the position.\n * @returns The extracted position as `[longitude, latitude]`.\n * @throws Error if the input object is undefined or does not contain a lng-lat position.\n *\n * @example\n * ```typescript\n * // Valid input\n * getPositionStrict([4.9, 52.3]); // Returns: [4.9, 52.3]\n *\n * // Invalid input throws error\n * try {\n *   getPositionStrict(undefined);\n * } catch (error) {\n *   console.error(error);\n *   // Error: The received object does not have lng-lat coordinates: undefined\n * }\n *\n * // Invalid object throws error\n * try {\n *   getPositionStrict({ invalid: 'object' });\n * } catch (error) {\n *   console.error(error);\n *   // Error: The received object does not have lng-lat coordinates: {\"invalid\":\"object\"}\n * }\n * ```\n *\n * @group Shared\n */\nexport const getPositionStrict = (hasLngLat: HasLngLat, options?: GetPositionOptions): Position => {\n    const position = getPosition(hasLngLat, options);\n    if (!position) {\n        throw new Error(`The received object does not have lng-lat coordinates: ${JSON.stringify(hasLngLat)}`);\n    }\n    return position;\n};\n\n/**\n * @ignore\n * @param lngLat\n */\nexport const toPointFeature = (lngLat: Position): Feature<Point> => ({\n    type: 'Feature',\n    geometry: { type: 'Point', coordinates: lngLat } as Point,\n    properties: {},\n});\n","import type { Feature, GeoJsonObject, Point } from 'geojson';\nimport type { HasLngLat, RoutePlanningLocation, RoutePlanningLocationType, Waypoint } from '../types';\nimport { getPositionStrict, toPointFeature } from './lngLat';\n\n/**\n * Creates a soft waypoint with a flexible radius for route calculation.\n *\n * A soft waypoint allows the routing algorithm to find the optimal path within\n * a specified radius of the target location, rather than forcing the route to\n * pass through the exact point. This is useful for:\n * - Allowing the router to stay on major roads instead of detouring\n * - Creating more efficient routes when exact location isn't critical\n * - Simulating \"pass near\" behavior in route planning\n *\n * The resulting waypoint is a GeoJSON Point Feature with a `radiusMeters` property\n * that the routing service uses to optimize the path.\n *\n * @param hasLngLat The location to extract coordinates from. Can be a coordinate array,\n *                  Point geometry, or Point Feature.\n * @param radiusMeters The radius in meters within which the route can pass.\n *                     The routing service will find the optimal point within this radius.\n * @returns A waypoint Feature with the radiusMeters property set.\n *\n * @example\n * ```typescript\n * // Create a soft waypoint from coordinates\n * // Route can pass anywhere within 500m of this point\n * const softWaypoint = asSoftWaypoint([4.9, 52.3], 500);\n *\n * // Use in route calculation\n * const route = await calculateRoute({\n *   key: 'your-api-key',\n *   locations: [\n *     [4.9, 52.3],              // Hard waypoint (exact location)\n *     asSoftWaypoint([5.1, 52.5], 1000),  // Soft waypoint (within 1km)\n *     [5.3, 52.7]               // Hard waypoint (exact location)\n *   ]\n * });\n *\n * // Create soft waypoint from a Place Feature\n * const place = await geocode({ key: 'your-api-key', query: 'Amsterdam' });\n * const softPlace = asSoftWaypoint(place, 2000);\n * // Route will pass within 2km of Amsterdam center\n * ```\n *\n * @see [Locations Guide](https://docs.tomtom.com/maps-sdk-js/guides/services/routing/locations)\n *\n * @group Route\n */\nexport const asSoftWaypoint = (hasLngLat: HasLngLat, radiusMeters: number): Waypoint => {\n    let inputAsFeature: Feature<Point>;\n    if (Array.isArray(hasLngLat) || (hasLngLat as GeoJsonObject).type !== 'Feature') {\n        inputAsFeature = toPointFeature(getPositionStrict(hasLngLat));\n    } else {\n        inputAsFeature = hasLngLat as Feature<Point>;\n    }\n    return { ...inputAsFeature, properties: { ...inputAsFeature.properties, radiusMeters } };\n};\n\n/**\n * Determines the type of geographic input (waypoint or path).\n *\n * This function inspects the structure of a RoutePlanningLocation to classify it as either:\n * - **waypoint**: A single point location (coordinate pair, Point geometry, or Point Feature)\n * - **path**: A line or route (array of coordinates, LineString geometry, or LineString Feature)\n *\n * @param routePlanningLocation The geographic input to classify. Can be coordinates, GeoJSON geometry, or GeoJSON Feature.\n * @returns The type of the input: 'waypoint' for point locations or 'path' for line geometries.\n *\n * @example\n * ```typescript\n * // Waypoint as coordinate array\n * getRoutePlanningLocationType([4.9, 52.3]); // Returns: 'waypoint'\n *\n * // Path as array of coordinates\n * getRoutePlanningLocationType([[4.9, 52.3], [4.5, 51.9]]); // Returns: 'path'\n *\n * // Waypoint as Point Feature\n * getRoutePlanningLocationType({\n *   type: 'Feature',\n *   geometry: { type: 'Point', coordinates: [4.9, 52.3] },\n *   properties: {}\n * }); // Returns: 'waypoint'\n *\n * // Path as LineString Feature\n * getRoutePlanningLocationType({\n *   type: 'Feature',\n *   geometry: { type: 'LineString', coordinates: [[4.9, 52.3], [4.5, 51.9]] },\n *   properties: {}\n * }); // Returns: 'path'\n * ```\n *\n * @group Route\n */\nexport const getRoutePlanningLocationType = (\n    routePlanningLocation: RoutePlanningLocation,\n): RoutePlanningLocationType => {\n    if (Array.isArray(routePlanningLocation)) {\n        if (Array.isArray(routePlanningLocation[0])) {\n            return 'path';\n        }\n        return 'waypoint';\n    }\n    if (routePlanningLocation.type === 'Feature') {\n        if (routePlanningLocation.geometry.type === 'LineString') {\n            return 'path';\n        }\n        return 'waypoint';\n    }\n    // assuming Point geometries:\n    return 'waypoint';\n};\n","import type { DelayMagnitude } from '../types';\n\n/**\n * @ignore\n */\nexport const indexedMagnitudes: DelayMagnitude[] = ['unknown', 'minor', 'moderate', 'major', 'indefinite'];\n","import { isNil } from 'lodash-es';\nimport type { DistanceDisplayUnits, TimeDisplayUnits } from '../config/globalConfig';\nimport { TomTomConfig } from '../config/globalConfig';\n\nconst minuteUnits = (displayUnits?: TimeDisplayUnits): string => displayUnits?.minutes ?? 'min';\nconst hourUnits = (displayUnits?: TimeDisplayUnits): string => displayUnits?.hours ?? 'hr';\n\n/**\n * Formats a duration in seconds into a human-readable time string.\n *\n * Converts raw seconds into a display-friendly format using hours and minutes,\n * with intelligent rounding and formatting based on the duration length.\n *\n * @param seconds The duration to format, given in seconds. Returns `undefined` for values < 30 seconds.\n * @param options Optional custom display units for hours and minutes text.\n *\n * @returns Formatted time string (e.g., \"1 hr 30 min\", \"45 min\"), or `undefined` if duration is too short.\n *\n * @remarks\n * **Rounding Behavior:**\n * - Durations under 30 seconds return `undefined`\n * - 30-59 seconds round to \"1 min\"\n * - Minutes are rounded to nearest minute\n * - Hours are displayed when duration  1 hour\n *\n * **Format Patterns:**\n * - Short duration: \"15 min\"\n * - Long duration: \"2 hr 30 min\"\n * - Exact hours: \"3 hr 00 min\"\n *\n * **Customization:**\n * Override default units via `options` or global {@link TomTomConfig}\n *\n * @example\n * ```typescript\n * // Basic usage\n * formatDuration(0);       // undefined (too short)\n * formatDuration(20);      // undefined (too short)\n * formatDuration(30);      // \"1 min\"\n * formatDuration(60);      // \"1 min\"\n * formatDuration(100);     // \"2 min\"\n * formatDuration(1800);    // \"30 min\"\n * formatDuration(3599);    // \"1 hr 00 min\"\n * formatDuration(3660);    // \"1 hr 01 min\"\n * formatDuration(7200);    // \"2 hr 00 min\"\n * formatDuration(36120);   // \"10 hr 02 min\"\n *\n * // Custom units\n * formatDuration(3660, { hours: 'h', minutes: 'm' });\n * // Returns: \"1 h 01 m\"\n *\n * // Route travel time\n * const route = await calculateRoute({ ... });\n * const travelTime = formatDuration(route.routes[0].summary.travelTimeInSeconds);\n * console.log(`Estimated time: ${travelTime}`);\n * // Output: \"Estimated time: 2 hr 15 min\"\n * ```\n *\n * @group Shared\n */\nexport const formatDuration = (seconds: number | undefined, options?: TimeDisplayUnits): string | undefined => {\n    if (seconds) {\n        // get the absolute value for seconds to calculate the right formatting\n        const hours = Math.abs(seconds) / 3600;\n        let flooredHours = Math.floor(hours);\n        let minutes = Math.round((hours % 1) * 60);\n        if (minutes === 60) {\n            minutes = 0;\n            flooredHours++;\n        }\n        const mergedOptions = { ...TomTomConfig.instance.get().displayUnits?.time, ...options };\n        if (flooredHours) {\n            return `${flooredHours} ${hourUnits(mergedOptions)} ${minutes.toString().padStart(2, '0')} ${minuteUnits(mergedOptions)}`;\n        }\n        if (minutes) {\n            return `${minutes.toString()} ${minuteUnits(mergedOptions)}`;\n        }\n        // else returns undefined\n    }\n    return undefined;\n};\n\n/**\n * Distance unit system types supported by the SDK formatters.\n *\n * Defines which measurement system to use when formatting distances.\n * Each system uses region-appropriate units and conventions.\n *\n * @remarks\n * **Unit Systems:**\n *\n * - `metric`: International System (SI)\n *   - Units: meters (m), kilometers (km)\n *   - Used in: Most of the world (Europe, Asia, Africa, South America, Australia)\n *   - Decimal-based, no fractions\n *\n * - `imperial_us`: United States customary units\n *   - Units: feet (ft), miles (mi)\n *   - Used in: United States\n *   - Uses fractions for miles (, , )\n *   - Feet for short distances (< 0.125 mi)\n *\n * - `imperial_uk`: United Kingdom imperial units\n *   - Units: yards (yd), miles (mi)\n *   - Used in: United Kingdom\n *   - Uses fractions for miles (, , )\n *   - Yards for short distances (< 0.125 mi)\n *\n * **Differences:**\n * - US uses feet for short distances\n * - UK uses yards for short distances\n * - Both use miles with fractions for medium/long distances\n *\n * @example\n * ```typescript\n * const system: DistanceUnitsType = 'metric';      // International\n * const usSystem: DistanceUnitsType = 'imperial_us';  // United States\n * const ukSystem: DistanceUnitsType = 'imperial_uk';  // United Kingdom\n * ```\n *\n * @group Shared\n */\nexport type DistanceUnitsType = 'metric' | 'imperial_us' | 'imperial_uk';\n\nconst MILE_IN_METERS = 1609.344;\nconst FEET_IN_METERS = 0.3048;\nconst YARD_IN_METERS = 0.9144;\n\nconst meterUnits = (displayUnits?: DistanceDisplayUnits): string => displayUnits?.meters ?? 'm';\nconst kmUnits = (displayUnits?: DistanceDisplayUnits): string => displayUnits?.kilometers ?? 'km';\n\nconst formatMetric = (meters: number, displayUnits: DistanceDisplayUnits): string => {\n    const absMeters = Math.abs(meters);\n    if (absMeters < 10) {\n        return `${meters} ${meterUnits(displayUnits)}`;\n    }\n    if (absMeters < 500) {\n        return `${Math.round(meters / 10) * 10} ${meterUnits(displayUnits)}`;\n    }\n    if (absMeters < 1000) {\n        const roundedMeters = Math.round(meters / 100) * 100;\n        return roundedMeters === 1000 || roundedMeters === -1000\n            ? `${meters < 0 ? '-' : ''}1 ${kmUnits(displayUnits)}`\n            : `${roundedMeters} ${meterUnits(displayUnits)}`;\n    }\n    if (absMeters < 10000) {\n        return `${(Math.round(meters / 100) * 100) / 1000} ${kmUnits(displayUnits)}`;\n    }\n    return `${Math.round(meters / 1000)} ${kmUnits(displayUnits)}`;\n};\n\nconst formatFeet = (meters: number, feetUnits: string): string => {\n    const feet = Math.round(meters / FEET_IN_METERS);\n    const absFeet = Math.abs(feet);\n    if (absFeet < 30) {\n        return `${feet} ${feetUnits}`;\n    }\n    if (absFeet < 500) {\n        return `${Math.round(feet / 10) * 10} ${feetUnits}`;\n    }\n    return `${Math.round(feet / 100) * 100} ${feetUnits}`;\n};\n\nconst formatYards = (meters: number, yardUnits: string): string => {\n    const yards = Math.round(meters / YARD_IN_METERS);\n    if (Math.abs(yards) < 10) {\n        return `${Math.round(yards)} ${yardUnits}`;\n    }\n    return `${Math.round(yards / 10) * 10} ${yardUnits}`;\n};\n\nconst formatUsMilesLessThanThree = (miles: number, absMiles: number, mileUnits: string): string => {\n    const milesInteger = Number.parseInt(absMiles.toString());\n    const milesFloat = absMiles - milesInteger;\n    const sign = miles < 0 ? '-' : '';\n    if (milesFloat < 0.125) {\n        return `${sign}${milesInteger} ${mileUnits}`;\n    }\n    const showIntegerIfNotZero = milesInteger > 0 ? milesInteger : '';\n    if (milesFloat < 0.375) {\n        return `${sign}${showIntegerIfNotZero} ${mileUnits}`;\n    }\n    if (milesFloat < 0.625) {\n        return `${sign}${showIntegerIfNotZero} ${mileUnits}`;\n    }\n    if (milesFloat < 0.875) {\n        return `${sign}${showIntegerIfNotZero} ${mileUnits}`;\n    }\n    return `${sign}${milesInteger + 1} ${mileUnits}`;\n};\n\nconst formatUsMilesLessThanTen = (miles: number, absMiles: number, mileUnits: string): string => {\n    const milesInteger = Number.parseInt(absMiles.toString());\n    const milesFloat = absMiles - milesInteger;\n    const sign = miles < 0 ? '-' : '';\n    if (milesFloat < 0.25) {\n        return `${sign}${milesInteger} ${mileUnits}`;\n    }\n    if (milesFloat < 0.75) {\n        return `${sign}${milesInteger} ${mileUnits}`;\n    }\n    return `${sign}${milesInteger + 1} ${mileUnits}`;\n};\n\nconst formatMiles = (miles: number, absMiles: number, mileUnits: string): string => {\n    if (absMiles < 3) {\n        return formatUsMilesLessThanThree(miles, absMiles, mileUnits);\n    }\n    if (absMiles < 10) {\n        return formatUsMilesLessThanTen(miles, absMiles, mileUnits);\n    }\n    return `${Math.round(miles)} ${mileUnits}`;\n};\n\nconst mileUnitsWithDefault = (displayUnits: DistanceDisplayUnits): string => displayUnits.miles ?? 'mi';\n\nconst formatUs = (meters: number, displayUnits: DistanceDisplayUnits): string => {\n    const miles = meters / MILE_IN_METERS;\n    const absMiles = Math.abs(miles);\n    if (absMiles < 0.125) {\n        return formatFeet(meters, displayUnits.feet ?? 'ft');\n    }\n    return formatMiles(miles, absMiles, mileUnitsWithDefault(displayUnits));\n};\n\nconst formatUk = (meters: number, displayUnits: DistanceDisplayUnits): string => {\n    const miles = meters / MILE_IN_METERS;\n    const absMiles = Math.abs(miles);\n    if (absMiles < 0.125) {\n        return formatYards(meters, displayUnits.yards ?? 'yd');\n    }\n    return formatMiles(miles, absMiles, mileUnitsWithDefault(displayUnits));\n};\n\n/**\n * Formatting is based on the number of meters passed and unit type. Less meters more precision.\n * @example\n * ```ts\n * (null, METRIC) -> \"\"\n * (0, METRIC) -> \"0 m\"\n * (2, METRIC) -> \"2 m\"\n * (237, METRIC) -> \"240 m\"\n * (730, METRIC) -> \"700 m\"\n * (950, METRIC) -> \"1 km\"\n * (-999, METRIC) -> \"-1 km\"\n * (2850, METRIC) -> \"2.9 km\"\n * (283520, METRIC) -> \"284 km\"\n * (2, IMPERIAL_US) -> \"7 ft\"\n * (100, IMPERIAL_US) -> \"330 ft\"\n * (182.88, IMPERIAL_US) -> \"600 ft\"\n * (205.95, IMPERIAL_US) -> \" mi\"\n * (1205.95, IMPERIAL_US) -> \" mi\"\n * (5309.7, IMPERIAL_US) -> \"3 mi\"\n * (-18181.7, IMPERIAL_US) -> \"-11 mi\"\n * (2, IMPERIAL_UK) -> \"2 yd\"\n * (150.88, IMPERIAL_UK) -> \"170 yd\"\n * (4344.3, IMPERIAL_UK) -> \"2 mi\"\n * (21753.68, IMPERIAL_UK) -> \"14 mi\"\n * ```\n * @param meters\n * @param options Options for the display units, including their type and custom ways to display them.\n * @group Shared\n */\nexport const formatDistance = (meters: number, options?: DistanceDisplayUnits): string => {\n    if (isNil(meters)) {\n        return '';\n    }\n    const mergedOptions = { ...TomTomConfig.instance.get().displayUnits?.distance, ...options };\n    const unitsType = mergedOptions?.type ?? 'metric';\n    switch (unitsType) {\n        case 'metric':\n            return formatMetric(meters, mergedOptions);\n        case 'imperial_us':\n            return formatUs(meters, mergedOptions);\n        case 'imperial_uk':\n            return formatUk(meters, mergedOptions);\n    }\n};\n","/**\n * Checks if `value` is `null` or `undefined`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n * @example\n *\n * _.isNil(null);\n * // => true\n *\n * _.isNil(void 0);\n * // => true\n *\n * _.isNil(NaN);\n * // => false\n */\nfunction isNil(value) {\n  return value == null;\n}\n\nexport default isNil;\n"],"names":["defaultConfig","commonBaseURL","apiKey","apiVersion","_TomTomConfig","constructor","this","config","put","reset","get","instance","TomTomConfig","mergeFromGlobal","givenConfig","chargingStationAccessTypes","chargingPointStatus","chargingPointCapabilities","chargingPointRestrictions","connectorTypes","currentTypes","geographyTypes","placeTypes","plugTypes","paymentMethods","avoidableTypes","trafficCategories","inputSectionTypes","inputSectionTypesWithGuidance","sectionTypes","views","isBBoxWithArea","bbox","length","bboxOnlyIfWithArea","bboxExpandedWithPosition","positionToContain","bboxToExpand","bboxExpandedWithBBox","bboxToContain","bboxFromBBoxes","bboxes","reduce","previous","current","bboxFromCoordsArray","coordinates","indexInterval","Math","ceil","i","bboxFromGeoJSON","hasBBox","Array","isArray","map","geoJsonItem","type","geometry","features","geometries","flatMap","polygon","bboxExpandedWithGeoJSON","geoJson","bboxCenter","generateId","Date","now","toString","random","substring","TOMTOM_USER_AGENT_SDK_NAME","validateTrackingId","trackingId","test","TypeError","generateTomTomHeaders","params","getPosition","hasLngLat","options","useEntryPoint","mainEntryPoint","place","properties","entryPoints","find","entryPoint","position","getPositionStrict","Error","JSON","stringify","toPointFeature","lngLat","asSoftWaypoint","radiusMeters","inputAsFeature","getRoutePlanningLocationType","routePlanningLocation","indexedMagnitudes","minuteUnits","displayUnits","minutes","formatDuration","seconds","hours","abs","flooredHours","floor","round","mergedOptions","time","padStart","MILE_IN_METERS","meterUnits","meters","kmUnits","kilometers","formatMiles","miles","absMiles","mileUnits","milesInteger","Number","parseInt","milesFloat","sign","showIntegerIfNotZero","formatUsMilesLessThanThree","formatUsMilesLessThanTen","mileUnitsWithDefault","formatUs","feetUnits","feet","absFeet","formatFeet","formatUk","yardUnits","yards","formatYards","formatDistance","distance","absMeters","roundedMeters","formatMetric"],"mappings":"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","x_google_ignoreList":[15]}