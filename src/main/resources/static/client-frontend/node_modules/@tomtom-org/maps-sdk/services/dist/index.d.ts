import { $ZodError } from 'zod/v4/core';
import { $ZodIssue } from 'zod/v4/core';
import { AddressProperties } from '../../../../core';
import { Avoidable } from '../../../../core';
import { ChargingStation } from '../../../../core';
import { ChargingStationsAccessType } from '../../../../core';
import { ChargingStationsAvailability } from '../../../core';
import { ChargingStopProps } from '../../../../core';
import { Classification } from '../../../../core';
import { CommonPlaceProps } from '../../../core';
import { Connector } from '../../../../core';
import { ConnectorType } from '../../../../core';
import { CurrentType } from '../../../../core';
import { EntryPoint } from '../../../../core';
import { EVChargingStationPlaceProps } from '../../../core';
import { Fuel } from '../../../../core';
import { GeographyType } from '../../../../core';
import { GeoJsonObject } from 'geojson';
import { GetPositionEntryPointOption } from '../../../../core';
import { GlobalConfig } from '../../../core';
import { Guidance } from '../../../../core';
import { HasBBox } from '../../../../core';
import { HasLngLat } from '../../../../core';
import { inputSectionTypes } from '../../../../core';
import { Instruction } from '../../../../core';
import { LaneDirection } from '../../../../core';
import { LegSummary } from '../../../../core';
import { Mapcode } from '../../../../core';
import { MapcodeType } from '../../../../core';
import { MultiPolygon } from 'geojson';
import { OpeningHours } from '../../../../core';
import { OpeningHoursMode } from '../../../../core';
import { Place } from '../../../core';
import { Place as Place_2 } from '../../../../core';
import { Place as Place_3 } from 'core';
import { PlaceDataSources } from '../../../../core';
import { Places } from '../../../../core';
import { Places as Places_2 } from '../../../core';
import { PlaceType } from '../../../../core';
import { PlugType } from '../../../../core';
import { POICategory } from '../../../../core';
import { Polygon } from 'geojson';
import { PolygonFeature } from '../../../core';
import { PolygonFeatures } from '../../../core';
import { PolygonFeatures as PolygonFeatures_2 } from '../../../../core';
import { Position } from 'geojson';
import { PossibleLaneSeparator } from '../../../../core';
import { RevGeoAddressProps } from '../../../core';
import { RoadShieldReference } from '../../../../core';
import { RoutePathPoint } from '../../../../core';
import { RoutePlanningLocation } from '../../../../core';
import { RouteProgress } from '../../../../core';
import { Routes } from '../../../core';
import { RouteSummary } from '../../../../core';
import { SearchPlaceProps } from '../../../../core';
import { SearchPlaceProps as SearchPlaceProps_2 } from '../../../core';
import { SideOfStreet } from '../../../../core';
import { TimeZone } from '../../../../core';
import { TomTomHeaders } from '../../../core';
import { TrafficIncidentTEC } from '../../../../core';
import { TravelMode } from '../../../../core';
import { View } from '../../../../core';
import { ZodMiniObject } from 'zod/v4-mini';

/**
 * @ignore
 */
export declare type AdditionalDataAPI = {
    providerID: string;
    error?: string;
    geometryData: GeoJsonObject;
};

/**
 * @ignore
 */
declare type AddressRangesAPI = {
    /**
     * An address range on the left side of a street segment (assuming looking from the "from" end toward the "to" end).
     */
    rangeLeft: string;
    /**
     * An address range on the right side of a street segment (assuming looking from the "from" end toward the "to" end).
     */
    rangeRight: string;
    /**
     * The beginning point of a street segment: Latitude, Longitude
     */
    from: LatLonAPI;
    /**
     * The end point of a street segment: Latitude, Longitude
     */
    to: LatLonAPI;
};

/**
 * @ignore
 */
declare enum APICode {
    TOO_MANY_REQUESTS = 429,
    FORBIDDEN = 403
}

/**
 * Mapping of API error codes to human-readable error messages.
 *
 * Provides standardized error messages for common API response codes,
 * ensuring consistent error handling across the SDK.
 *
 * @group Errors
 */
export declare const APIErrorCode: {
    readonly [K in APICode as number]: string;
};

/**
 * Error returned by an API.
 * @ignore
 */
declare type APIErrorResponse<T = DefaultAPIResponseErrorBody> = {
    status?: number;
    message: string;
    data?: T;
};

/**
 * Base properties shared across all autocomplete segment types.
 *
 * Contains the entity type, value, and mapping information showing
 * how the segment relates to the original input query.
 *
 * @group Autocomplete Search
 */
export declare type AutocompleteGenericSearchSegment = {
    /**
     * The type of detected entity.
     *
     * Currently detects: brand, category, and plaintext.
     * Additional types may be added in future versions.
     */
    type: AutocompleteSearchSegmentType;
    /**
     * The value of the detected entity.
     *
     * May be a category name, brand name, or unrecognized text.
     * For brand segments, this value can be used with the poiBrands
     * parameter in other search endpoints to filter POI results.
     */
    value: string;
    /**
     * Mapping between the input query and this segment.
     *
     * Shows which part(s) of the original query correspond to
     * this recognized entity.
     */
    matches: AutocompleteSearchMatches;
};

/**
 * Autocomplete search queries as the user types, enabling faster and more accurate search.
 *
 * The Autocomplete service recognizes entities (places, addresses, POIs) within a partial
 * input query and offers them as completion suggestions. This enables real-time search
 * assistance and improves the search experience.
 *
 * @remarks
 * Key features:
 * - **Real-time suggestions**: Returns results as the user types
 * - **Entity recognition**: Identifies addresses, POIs, and geographic areas
 * - **Structured results**: Provides both plain text and structured data
 * - **Query refinement**: Helps users formulate more accurate search queries
 * - **Fast response**: Optimized for low-latency interactive use
 *
 * Typical use cases:
 * - Search box autocomplete dropdowns
 * - Address entry forms
 * - Location pickers
 * - Navigation apps
 *
 * @param params - Autocomplete parameters including the partial query
 * @param customTemplate - Advanced customization for request/response handling
 *
 * @returns Promise resolving to autocomplete suggestions
 *
 * @example
 * ```typescript
 * // Autocomplete as user types "amster"
 * const suggestions = await autocompleteSearch({
 *   key: 'your-api-key',
 *   query: 'amster',
 *   limit: 5
 * });
 * // Returns: Amsterdam, Amsterdam Centraal, etc.
 *
 * // Autocomplete with position bias
 * const localSuggestions = await autocompleteSearch({
 *   key: 'your-api-key',
 *   query: 'main st',
 *   at: [4.9041, 52.3676],  // Near Amsterdam
 *   limit: 10
 * });
 *
 * // Autocomplete with category filter
 * const restaurantSuggestions = await autocompleteSearch({
 *   key: 'your-api-key',
 *   query: 'pizz',
 *   categorySet: [7315],  // Restaurant category
 *   at: [4.9041, 52.3676]
 * });
 * ```
 *
 * @see [Autocomplete API Documentation](https://docs.tomtom.com/search-api/documentation/autocomplete-service/autocomplete)
 * @see [Places Quickstart Guide](https://docs.tomtom.com/maps-sdk-js/guides/services/places/quickstart)
 * @see [Search Guide](https://docs.tomtom.com/maps-sdk-js/guides/services/places/search)
 *
 * @group Autocomplete Search
 */
export declare const autocompleteSearch: (params: AutocompleteSearchParams, customTemplate?: Partial<AutocompleteSearchTemplate>) => Promise<AutocompleteSearchResponse>;

/**
 * Autocomplete segment representing a recognized brand.
 *
 * Used to identify brand names in the autocomplete suggestion.
 * The value can be used with the poiBrands parameter in search
 * endpoints to filter results to specific brands.
 *
 * @group Autocomplete Search
 */
export declare type AutocompleteSearchBrandSegment = AutocompleteGenericSearchSegment & {
    type: 'brand';
};

/**
 * Autocomplete segment representing a recognized POI category.
 *
 * Used to identify category names in the autocomplete suggestion.
 * The id can be used with the poiCategories parameter in search
 * endpoints to filter results to specific categories.
 *
 * @group Autocomplete Search
 */
export declare type AutocompleteSearchCategorySegment = AutocompleteGenericSearchSegment & {
    type: 'category';
    /**
     * Category identifier for filtering search results.
     *
     * Use with the poiCategories parameter in other search endpoints
     * to restrict results to POIs of this category.
     */
    id: string;
    /**
     * Alternative name that matched the user query.
     *
     * Present only when a synonym or alternative name matched instead
     * of the primary category name. For example, for the query "petrol station",
     * the value will be "gas station" and matchedAlternativeName will be
     * "petrol station".
     */
    matchedAlternativeName?: string;
};

/**
 * Context information for an autocomplete search request.
 *
 * Captures the original query and optional geographic bias used
 * to influence the autocomplete suggestions.
 *
 * @group Autocomplete Search
 */
export declare type AutocompleteSearchContext = {
    /**
     * Original query string passed to the autocomplete engine.
     */
    inputQuery: string;
    /**
     * Geographic bias applied to influence results.
     *
     * Present when position and radius parameters were provided
     * to prioritize results near a specific location.
     */
    geoBias?: AutocompleteSearchResultGeoBias;
};

/**
 * @ignore
 */
export declare type AutocompleteSearchContextAPI = Omit<AutocompleteSearchContext, 'geoBias'> & {
    geoBias?: AutocompleteSearchResultGeoBiasAPI;
};

/**
 * A single match between a segment and the input query.
 *
 * Defines a substring of the input query that corresponds to
 * the recognized entity.
 *
 * @group Autocomplete Search
 */
export declare type AutocompleteSearchMatch = {
    /**
     * Starting position of the matched substring.
     *
     * Zero-based offset in the input query string.
     */
    offset: number;
    /**
     * Length of the matched substring in characters.
     */
    length: number;
};

/**
 * Match information linking a segment to the input query.
 *
 * Defines the relationship between recognized entities and the
 * portions of the original query they represent.
 *
 * @group Autocomplete Search
 */
export declare type AutocompleteSearchMatches = {
    /**
     * Array of matched substrings from the input query.
     *
     * Indicates which part(s) of the input query map to this segment.
     * Multiple entries are possible as matching may not be continuous.
     */
    inputQuery: AutocompleteSearchMatch[];
};

/**
 * Parameters for autocomplete search suggestions.
 *
 * Provides real-time search suggestions as users type, recognizing entities like
 * places, addresses, brands, and categories within partial input.
 *
 * @remarks
 * **Key Features:**
 * - Real-time suggestions as user types
 * - Entity recognition (brands, categories, addresses)
 * - Position-based relevance ranking
 * - Country and area filtering
 * - Type-based result filtering
 *
 * **Use Cases:**
 * - Search box autocomplete dropdowns
 * - Address entry assistance
 * - Navigation input fields
 * - Location pickers
 *
 * @example
 * ```typescript
 * // Basic autocomplete
 * const params: AutocompleteSearchParams = {
 *   key: 'your-api-key',
 *   query: 'pizz',
 *   limit: 5
 * };
 *
 * // Autocomplete with position bias
 * const biasedParams: AutocompleteSearchParams = {
 *   key: 'your-api-key',
 *   query: 'coffee',
 *   position: [4.9041, 52.3676],  // Near Amsterdam
 *   radiusMeters: 5000,
 *   limit: 10
 * };
 *
 * // Filter by result type
 * const brandParams: AutocompleteSearchParams = {
 *   key: 'your-api-key',
 *   query: 'mcdon',
 *   resultType: ['brand'],  // Only brand suggestions
 *   countries: ['NL', 'BE']  // Netherlands and Belgium only
 * };
 * ```
 *
 * @group Autocomplete Search
 */
export declare type AutocompleteSearchParams = CommonServiceParams<URL, AutocompleteSearchResponseAPI> & {
    /**
     * Search query string (partial user input).
     *
     * The text to autocomplete. Can be incomplete or partial words.
     *
     * @remarks
     * Must be properly URL encoded. The service will match this against
     * place names, addresses, brands, and categories.
     *
     * @example
     * ```typescript
     * query: 'amster'  // Will suggest "Amsterdam"
     * query: 'star'    // Will suggest "Starbucks" (brand) or "Main Street" (address)
     * ```
     */
    query: string;
    /**
     * Position to bias results towards.
     *
     * Results closer to this location will be ranked higher in suggestions.
     *
     * @remarks
     * Can be provided as:
     * - Object with `lon` and `lat` properties
     * - Array `[longitude, latitude]`
     *
     * When used without `radiusMeters`, biases results but doesn't restrict them.
     * When used with `radiusMeters`, constrains results to that area.
     *
     * @example
     * ```typescript
     * // Object format
     * position: { lon: 4.9041, lat: 52.3676 }
     *
     * // Array format
     * position: [4.9041, 52.3676]
     * ```
     */
    position?: HasLngLat;
    /**
     * Maximum number of suggestions to return.
     *
     * @default 10
     * @minimum 1
     * @maximum 100
     *
     * @example
     * ```typescript
     * limit: 5  // Return up to 5 suggestions
     * ```
     */
    limit?: number;
    /**
     * Search radius in meters from the position.
     *
     * When combined with `position`, restricts results to within this radius.
     * Without `position`, this parameter is ignored.
     *
     * @remarks
     * Only results within this distance from `position` will be returned.
     * Values ≤ 0 are ignored.
     *
     * @example
     * ```typescript
     * // Search within 5km of position
     * position: [4.9, 52.3],
     * radiusMeters: 5000
     * ```
     */
    radiusMeters?: number;
    /**
     * Restrict results to specific countries.
     *
     * List of country codes in ISO 3166-1 alpha-2 or alpha-3 format.
     *
     * @remarks
     * Only places within these countries will be suggested.
     * Useful for region-specific applications.
     *
     * @example
     * ```typescript
     * // Alpha-2 codes
     * countries: ['US', 'CA', 'MX']
     *
     * // Alpha-3 codes
     * countries: ['USA', 'CAN', 'MEX']
     *
     * // European countries
     * countries: ['NL', 'DE', 'FR', 'BE']
     * ```
     */
    countries?: string[];
    /**
     * Filter results by segment type.
     *
     * Restricts suggestions to specific entity types (brands, categories, or plaintext).
     *
     * @remarks
     * A result is only included if it contains segments of the specified types.
     * Omit this parameter to receive all types.
     *
     * @example
     * ```typescript
     * // Only brand suggestions (e.g., "Starbucks", "McDonald's")
     * resultType: ['brand']
     *
     * // Only category suggestions (e.g., "Restaurant", "Hotel")
     * resultType: ['category']
     *
     * // Brands and categories, exclude addresses
     * resultType: ['brand', 'category']
     *
     * // All types (default)
     * resultType: ['brand', 'category', 'plaintext']
     * ```
     */
    resultType?: AutocompleteSearchSegmentType[];
};

/**
 * Autocomplete segment representing unrecognized plaintext.
 *
 * Used for portions of the query that were not identified as
 * specific brands or categories.
 *
 * @group Autocomplete Search
 */
export declare type AutocompleteSearchPlaintextSegment = AutocompleteGenericSearchSegment & {
    type: 'plaintext';
};

/**
 * Response from the autocomplete search service.
 *
 * Contains context about the query and a list of autocomplete suggestions
 * with recognized entities (brands, categories, plaintext).
 *
 * @group Autocomplete Search
 */
export declare type AutocompleteSearchResponse = {
    /**
     * Information about the autocomplete request that was performed.
     *
     * Includes the original query and any geographic bias applied.
     */
    context: AutocompleteSearchContext;
    /**
     * List of autocomplete suggestions returned by the engine.
     *
     * Each result contains segments representing recognized entities
     * from the input query.
     */
    results: AutocompleteSearchResult[];
};

/**
 * @ignore
 */
export declare type AutocompleteSearchResponseAPI = {
    context: AutocompleteSearchContextAPI;
    results: AutocompleteSearchResult[];
};

/**
 * Individual autocomplete search result.
 *
 * Represents a single suggestion with its recognized entities
 * (brands, categories, or plaintext segments).
 *
 * @group Autocomplete Search
 */
export declare type AutocompleteSearchResult = {
    /**
     * Recognized entities within this autocomplete suggestion.
     *
     * Array of segments identifying specific brands, categories,
     * or plaintext portions of the suggestion.
     */
    segments: AutocompleteSearchSegment[];
};

/**
 * Geographic bias parameters for autocomplete search results.
 *
 * Defines a geographic area used to prioritize or constrain
 * autocomplete suggestions.
 *
 * @group Autocomplete Search
 */
export declare type AutocompleteSearchResultGeoBias = {
    /**
     * Center position for the geographic bias.
     *
     * Coordinates used to prioritize nearby results.
     */
    position?: Position;
    /**
     * Search radius in meters from the position.
     *
     * Defines the geographic area to constrain or prioritize results.
     */
    radiusMeters?: number;
};

/**
 * @ignore
 */
export declare type AutocompleteSearchResultGeoBiasAPI = {
    position?: LatLonAPI;
    radius?: number;
};

/**
 * Union type for all autocomplete search segment types.
 *
 * A segment represents a recognized entity within the autocomplete result,
 * which can be a brand, category, or plaintext.
 *
 * @group Autocomplete Search
 */
export declare type AutocompleteSearchSegment = AutocompleteSearchBrandSegment | AutocompleteSearchCategorySegment | AutocompleteSearchPlaintextSegment;

/**
 * Segment type for autocomplete results.
 *
 * Determines the type of entity being suggested in autocomplete results.
 *
 * @remarks
 * **Segment Types:**
 * - `brand`: Chain or brand names (e.g., "McDonald's", "Starbucks")
 * - `category`: POI categories (e.g., "Restaurant", "Gas Station")
 * - `plaintext`: Free-form text (addresses, place names)
 *
 * @example
 * ```typescript
 * // Filter for brand results only
 * const resultType: AutocompleteSearchSegmentType[] = ['brand'];
 *
 * // Filter for categories and brands
 * const resultType: AutocompleteSearchSegmentType[] = ['category', 'brand'];
 * ```
 *
 * @group Autocomplete Search
 */
export declare type AutocompleteSearchSegmentType = 'brand' | 'category' | 'plaintext';

/**
 * Autocomplete service template type.
 * @ignore
 */
declare type AutocompleteSearchTemplate = ServiceTemplate<AutocompleteSearchParams, URL, AutocompleteSearchResponseAPI, AutocompleteSearchResponse>;

/**
 * @ignore
 */
declare interface BaseAPIResponseErrorBody {
    httpStatusCode: number;
    detailedError: {
        code: string;
        message: string;
        target: string;
    };
}

declare type BatteryCurve = {
    /**
     * Minimum: 0
     */
    stateOfChargeInkWh: number;
    /**
     * Must be larger than 0.
     */
    maxPowerInkW: number;
};

/**
 * Intent indicating the query references a saved location.
 *
 * Detected when the query contains keywords for bookmarked locations
 * (e.g., "home", "work").
 *
 * @group Fuzzy Search
 */
export declare type BookmarkIntent = {
    /**
     * Query type identifier.
     *
     * The query contains keywords that can refer to saved locations.
     */
    type: 'BOOKMARK';
    /**
     * Details about the detected bookmark keyword.
     */
    details: BookmarkIntentDetails;
};

/**
 * Details for a bookmark query intent.
 *
 * Contains the bookmark keyword detected in the query.
 *
 * @group Fuzzy Search
 */
export declare type BookmarkIntentDetails = {
    /**
     * The detected bookmark keyword.
     *
     * Currently supports "HOME" and "WORK". Applications should suggest
     * the user's saved home or work address as a search result.
     */
    bookmark: string;
};

/**
 * @ignore
 */
declare type BoundingBoxAPI = BoundingBoxTopLeftAPI | BoundingBoxSouthWestAPI;

/**
 * @ignore
 */
declare type BoundingBoxSouthWestAPI = {
    southWest: string;
    northEast: string;
};

/**
 * @ignore
 */
declare type BoundingBoxTopLeftAPI = ViewportAPI;

/**
 * @ignore
 */
declare type BrandAPI = {
    /**
     * Brand name.
     *
     * The commercial or franchise name (e.g., 'McDonald\'s', 'Shell', 'Hilton').
     */
    name: string;
};

/**
 * Type of budget constraint for reachable range calculation.
 *
 * @remarks
 * **Budget Types:**
 * - `timeMinutes`: Travel time in minutes (isochrone)
 * - `distanceKM`: Travel distance in kilometers (isodistance)
 * - `remainingChargeCPT`: Remaining battery charge in percentage (EV)
 * - `spentChargePCT`: Battery charge consumed in percentage (EV)
 * - `spentFuelLiters`: Fuel consumed in liters (combustion)
 *
 * **Common Use Cases:**
 * - Time: "Where can I reach in 30 minutes?"
 * - Distance: "What's within 10 km?"
 * - EV charge: "How far can I go on 50% battery?"
 * - Fuel: "Range with 20 liters of fuel"
 *
 * @example
 * ```typescript
 * const timeType: BudgetType = 'timeMinutes';
 * const distanceType: BudgetType = 'distanceKM';
 * const evType: BudgetType = 'remainingChargeCPT';
 * ```
 *
 * @group Reachable Range
 */
declare type BudgetType = (typeof budgetTypes)[number];

declare const budgetTypes: readonly ["timeMinutes", "remainingChargeCPT", "spentChargePCT", "spentFuelLiters", "distanceKM"];

/**
 * Enhance multiple places with real-time EV charging availability data.
 *
 * Fetches availability information for all EV charging stations in a collection
 * and merges it into their properties. Non-EV places are returned unchanged.
 *
 * @remarks
 * **Important**: Availability requests are made sequentially to avoid exceeding
 * API rate limits (QPS - Queries Per Second). For large result sets, this may
 * take some time.
 *
 * @param places - Collection of places to enhance
 * @param options - Configuration options
 *
 * @returns Promise resolving to places collection with merged availability
 *
 * @example
 * ```typescript
 * // Search for charging stations and add availability
 * const results = await search({
 *   query: 'EV charging',
 *   at: [4.9, 52.3],
 *   radius: 5000
 * });
 *
 * const withAvailability = await buildPlacesWithEVAvailability(results, {
 *   includeIfAvailabilityUnknown: false  // Filter out stations with unknown availability
 * });
 *
 * // Display only stations with known availability
 * withAvailability.features.forEach(place => {
 *   const available = place.properties.chargingPark?.availability?.chargingPointAvailability.count;
 *   console.log(`${place.properties.poi?.name}: ${available} chargers`);
 * });
 * ```
 *
 * @group EV Charging
 */
export declare const buildPlacesWithEVAvailability: (places: Places_2, options?: {
    /**
     * If true, places with unknown availability will be still included. Otherwise, they will be filtered out.
     * @default true
     */
    includeIfAvailabilityUnknown: boolean;
}) => Promise<Places_2<EVChargingStationPlaceProps>>;

/**
 * Enhance a place with real-time EV charging availability data.
 *
 * Fetches availability information for an EV charging station and merges it into
 * the place properties. Non-EV places are returned unchanged.
 *
 * @param place - The place to enhance with availability data
 *
 * @returns Promise resolving to the place with merged availability information
 *
 * @example
 * ```typescript
 * // After search, enhance place with availability
 * const searchResult = await search({ query: 'EV charging', ... });
 * const place = searchResult.features[0];
 *
 * const enhancedPlace = await buildPlaceWithEVAvailability(place);
 * const availability = enhancedPlace.properties.chargingPark?.availability;
 *
 * if (availability) {
 *   console.log('Available chargers:', availability.chargingPointAvailability.count);
 * }
 * ```
 *
 * @group EV Charging
 */
export declare const buildPlaceWithEVAvailability: (place: Place) => Promise<Place<EVChargingStationPlaceProps>>;

/**
 * @ignore
 * Generate error for APIResponse, any other error type will be returned as it is.
 * @param error The error captured by a catch function.
 * @param serviceName The name of the service.
 * @param parseResponseError
 */
export declare const buildResponseError: (error: unknown, serviceName: ServiceName, parseResponseError?: ParseResponseError<unknown>) => SDKError;

/**
 * @ignore
 * @param error
 * @param serviceName
 */
export declare const buildValidationError: (error: ValidationError, serviceName: ServiceName) => SDKError;

/**
 * Calculates a route between an origin and destination, optionally passing through extra waypoints.
 *
 * @param params - Route calculation parameters including locations, travel mode, and other options
 * @param customTemplate - Optional template customization for request/response handling
 * @returns Promise resolving to calculated route(s) with geometry, distance, and travel time
 *
 * @see [Calculate Route API Documentation](https://docs.tomtom.com/routing-api/documentation/tomtom-maps/calculate-route)
 *
 * @group Routing
 */
export declare const calculateRoute: (params: CalculateRouteParams, customTemplate?: Partial<CalculateRouteTemplate>) => Promise<Routes>;

/**
 * Parameters for calculating a route between waypoints.
 *
 * Includes origin, destination, optional intermediate waypoints, and various routing options
 * to customize the calculated route based on vehicle type, traffic, and preferences.
 *
 * @example
 * ```typescript
 * // Basic route from A to B
 * const params: CalculateRouteParams = {
 *   apiKey: 'your-api-key',
 *   locations: [
 *     [4.9041, 52.3676],  // Amsterdam
 *     [4.4777, 51.9244]   // Rotterdam
 *   ]
 * };
 *
 * // Route with guidance and alternatives
 * const advancedParams: CalculateRouteParams = {
 *   apiKey: 'your-api-key',
 *   locations: [[4.9041, 52.3676], [4.4777, 51.9244]],
 *   guidance: { type: 'coded', phonetics: 'IPA' },
 *   maxAlternatives: 2,
 *   costModel: {
 *     routeType: 'fast',
 *     avoid: ['tollRoads', 'motorways']
 *   },
 *   when: {
 *     option: 'departAt',
 *     date: new Date('2025-10-20T08:00:00Z')
 *   }
 * };
 *
 * // Electric vehicle route with charging
 * const evParams: CalculateRouteParams = {
 *   apiKey: 'your-api-key',
 *   locations: [[4.9, 52.3], [8.5, 50.1]],
 *   vehicle: {
 *     engineType: 'electric',
 *     model: {
 *       engine: {
 *         charging: { maxChargeKWH: 85 },
 *         consumption: {
 *           speedsToConsumptionsKWH: [
 *             { speedKMH: 50, consumptionUnitsPer100KM: 8 },
 *             { speedKMH: 80, consumptionUnitsPer100KM: 12 },
 *             { speedKMH: 120, consumptionUnitsPer100KM: 18 }
 *           ]
 *         }
 *       }
 *     },
 *     state: { currentChargeInkWh: 50 }
 *   }
 * };
 * ```
 *
 * @group Routing
 */
export declare type CalculateRouteParams = CommonServiceParams<CalculateRouteRequestAPI, CalculateRouteResponseAPI> & CommonRoutingParams & {
    /**
     * Ordered list of locations (waypoints) and/or path points for route calculation.
     *
     * The route will pass through these locations in the specified order.
     *
     * @remarks
     * Requirements:
     * - Minimum 2 waypoints (origin and destination) OR 1 path with 2+ points
     *
     * Supported formats:
     * - Coordinate arrays: `[longitude, latitude]`
     * - Path arrays for route reconstruction
     * - (not supported) Waypoint objects with radius for circle waypoints
     *
     * @see [POST data parameters](https://docs.tomtom.com/routing-api/documentation/tomtom-maps/calculate-route#post-data-parameters)
     * @see [Response structure](https://docs.tomtom.com/routing-api/documentation/tomtom-maps/calculate-route#structure-of-a-successful-response)
     *
     * @example
     * ```typescript
     * // Coordinate arrays
     * locations: [[4.9, 52.3], [4.5, 51.9]]
     *
     * // With intermediate stop
     * locations: [[4.9, 52.3], [4.7, 52.1], [4.5, 51.9]]
     *
     * // Path array for route reconstruction
     * locations: [
     *   [4.9, 52.3],  // Origin waypoint
     *   [
     *     [4.85, 52.25], [4.80, 52.20], [4.75, 52.15]  // Path points between waypoints
     *   ],
     *   [4.5, 51.9]   // Destination waypoint
     * ]
     *
     * // (not supported) Waypoint objects with radius for circle waypoints
     * locations: [
     *   [4.9, 52.3],
     *   {
     *     type: 'Feature',
     *     geometry: { type: 'Point', coordinates: [4.7, 52.1] },
     *     properties: { radiusMeters: 5000 }
     *   },
     *   [4.5, 51.9]
     * ]
     * ```
     */
    locations: RoutePlanningLocation[];
    /**
     * Controls how entry points are used for routing.
     *
     * Entry points represent specific building entrances or facility access points.
     * Using them improves routing accuracy by directing to the correct entrance.
     *
     * @remarks
     * - `main-when-available`: Use main entry point if available, otherwise use place center (recommended for routing)
     * - `ignore`: Always use place center position
     *
     * @default 'main-when-available'
     *
     * @example
     * ```typescript
     * // Route to main entrance when available
     * useEntryPoints: 'main-when-available'
     * ```
     */
    useEntryPoints?: GetPositionEntryPointOption;
    /**
     * Request additional travel time calculations for different traffic scenarios.
     *
     * When set to 'all', the returned route summary will contain extra fields:
     * - `noTrafficTravelTimeInSeconds` – Free-flow (no traffic)
     * - `historicTrafficTravelTimeInSeconds` – Historic traffic patterns
     * - `liveTrafficIncidentsTravelTimeInSeconds` – Current live traffic
     *
     * Useful for comparing traffic impact and displaying "X minutes saved by leaving now".
     *
     * @default 'none'
     *
     * @example
     * ```typescript
     * computeAdditionalTravelTimeFor: 'all'
     * ```
     */
    computeAdditionalTravelTimeFor?: ComputeTravelTimeFor;
    /**
     * Request extended progress information at route polyline points.
     *
     * Includes cumulative distance and/or time from start to each coordinate.
     * When non-empty, the route features will contain additional property "progress" with an array of objects containing:
     * - `pointIndex` – Index of the coordinate in the route geometry
     * - `travelTimeInSeconds` - Cumulative travel time from start to this point (if "travelTime" is requested)
     * - `distanceInMeters` - Cumulative distance from start to this point (if "distance" is requested)
     *
     * Useful for displaying progress during navigation or animating route visualization.
     *
     * @default ['distance', 'travelTime']
     *
     * @example
     * ```typescript
     * extendedRouteRepresentations: ['distance', 'travelTime']
     * ```
     */
    extendedRouteRepresentations?: ExtendedRouteRepresentation[];
    /**
     * Request turn-by-turn guidance instructions.
     *
     * When specified, the response includes detailed navigation instructions
     * with maneuvers, road names, and optional phonetics.
     *
     * @example
     * ```typescript
     * guidance: {
     *   type: 'coded',
     *   version: 2,
     *   phonetics: 'IPA',
     *   roadShieldReferences: 'all'
     * }
     * ```
     */
    guidance?: GuidanceParams;
    /**
     * Route section types to include in the response.
     *
     * Sections help you display route characteristics like tolls, ferries, or traffic.
     * Leg sections are always included regardless of this parameter.
     *
     * @default All available section types
     *
     * @example
     * ```typescript
     * // Request specific sections
     * sectionTypes: ['toll', 'ferry', 'traffic', 'country']
     *
     * // Request no optional sections
     * sectionTypes: []
     * ```
     */
    sectionTypes?: InputSectionTypes;
    /**
     * Maximum number of alternative routes to calculate.
     *
     * Alternative routes provide different travel options between the same origin and destination.
     * Each alternative is optimized differently (e.g., avoiding highways, minimizing tolls).
     *
     * @remarks
     * - More alternatives increase response time
     * - Alternatives are returned in order of quality (best first)
     * - Not all requests will return the maximum number of alternatives
     *
     * @default 0
     *
     * @example
     * ```typescript
     * // Request up to 2 alternatives
     * maxAlternatives: 2
     * ```
     */
    maxAlternatives?: MaxNumberOfAlternatives;
};

/**
 * @ignore
 */
declare type CalculateRoutePOSTDataAPI = {
    supportingPoints?: LatitudeLongitudePointAPI[];
    pointWaypoints?: PointWaypointAPI[];
    chargingParameters?: ChargingParametersAPI;
};

/**
 * @ignore
 */
declare type CalculateRouteRequestAPI = FetchInput<CalculateRoutePOSTDataAPI>;

/**
 * @ignore
 */
declare type CalculateRouteResponseAPI = {
    formatVersion: string;
    routes: RouteAPI[];
    optimizedWaypoints?: {
        providedIndex: number;
        optimizedIndex: number;
    }[];
    report?: ReportAPI;
    roadShieldAtlasReference?: string;
};

/**
 * @ignore
 */
declare type CalculateRouteTemplate = ServiceTemplate<CalculateRouteParams, FetchInput<CalculateRoutePOSTDataAPI>, CalculateRouteResponseAPI, Routes>;

/**
 * @ignore
 */
declare type CategoryAPI = {
    id: number;
};

declare type ChargingConnector = {
    /**
     * One of the values AC1, AC3 for single- or three-phase alternating current, or DC for direct current.
     */
    currentType: CurrentType;
    /**
     * The compatible plug types.
     * * Must have at least one element.
     */
    plugTypes: [PlugType, ...PlugType[]];
    /**
     * Minimum 0, maximum 1.
     * @default 1
     */
    efficiency?: number;
    /**
     * @default 0
     */
    baseLoadInkW?: number;
    /**
     * If not specified the power is only limited by the charging facility.
     * * Must be a positive number or zero, where 0 implies no boundary applies.
     */
    maxPowerInkW?: number;
    /**
     * If not specified the voltage is only limited by the charging facility.
     * * Must be a positive number or zero, where 0 implies no boundary applies.
     */
    maxVoltageInV?: number;
    /**
     * If not specified the amperage is only limited by the charging facility.
     * * Must be a positive number or zero, where 0 implies no boundary applies.
     */
    maxCurrentInA?: number;
    /**
     * Must contain the fields minVoltageInV and maxVoltageInV
     * specifying minimal (included) and maximal (excluded) voltage values.
     */
    voltageRange?: {
        /**
         * Minimum: 0.
         */
        minVoltageInV?: number;
        /**
         * Minimum: minVoltageInV.
         */
        maxVoltageInV?: number;
    };
};

/**
 * The charging model describes how a car's battery performs,
 * and it's used mostly for Long Distance EV Routing and EV Reachable Range calculations.
 */
declare type ChargingModel = {
    /**
     * Specifies the maximum electric energy supply in kilowatt-hours (kWh) that may be stored in the vehicle's battery.
     * * Note: Requires state.currentChargeInPCT to be set.
     *
     * Minimum value: kWh equivalent to state.currentChargePCT
     */
    maxChargeKWH: number;
    /**
     * Must contain from zero to up to 20 (inclusive) json objects describing a battery point,
     * each containing stateOfChargeInkWh and maxPowerInkW.
     *
     * None of the stateOfChargeInkWh values from such an object may equal any other stateOfChargeInkWh of an object.
     * maxPowerInkW must be larger than zero.
     */
    batteryCurve?: BatteryCurve[];
    /**
     * Must be a non-empty array of chargingConnector elements.
     *
     * No chargingConnector may be equivalent to another, where equivalent chargingConnector elements:
     * * have the same currentType
     * * share at least one element of plugTypes
     * * have an overlapping voltageRange
     */
    chargingConnectors?: [ChargingConnector, ...ChargingConnector[]];
    /**
     * If not specified the default value 60 applies. Must be larger than or equal to zero.
     * @default 60
     */
    chargingTimeOffsetInSec?: number;
};

declare type ChargingParametersAPI = Omit<ChargingModel, 'maxChargeKWH'>;

/**
 * @ignore
 */
declare type ChargingParkAPI = {
    connectors: ConnectorAPI[];
};

/**
 * @ignore
 */
declare type ChargingParkLocationAPI = {
    coordinate: LatitudeLongitudePointAPI;
    street?: string;
    houseNumber?: string;
    city?: string;
    region?: string;
    postalCode?: string;
    country?: string;
};

/**
 * Charging preferences for Long Distance EV Routing.
 *
 * @remarks
 * Specifying these preferences will trigger the calculation of charging stops along your route.
 * Requires the ChargingModel to be set in `consumption.charging`.
 *
 * **When to Use:**
 * - Long-distance EV trips beyond single-charge range
 * - Planning trips with charging station stops
 * - Ensuring adequate battery buffers
 * - Optimizing charging stop locations
 *
 * **Choose Format:**
 * - Use percentage when thinking in terms of battery %
 * - Use kWh when you prefer absolute energy values
 *
 * @see {@link https://docs.tomtom.com/routing-api/documentation/extended-routing/long-distance-ev-routing | Long Distance EV Routing Documentation}
 *
 * @example
 * ```typescript
 * // Percentage-based preferences
 * const pctPrefs: ChargingPreferences = {
 *   minChargeAtDestinationPCT: 20,
 *   minChargeAtChargingStopsPCT: 10
 * };
 *
 * // Energy-based preferences
 * const kwhPrefs: ChargingPreferences = {
 *   minChargeAtDestinationInkWh: 15,
 *   minChargeAtChargingStopsInkWh: 10
 * };
 * ```
 *
 * @group Vehicle
 */
export declare type ChargingPreferences = ChargingPreferencesPCT | ChargingPreferencesKWH;

/**
 * Charging preferences specified by absolute energy in kilowatt-hours.
 *
 * @remarks
 * Use when you prefer to specify energy buffers in kWh rather than percentages.
 *
 * @example
 * ```typescript
 * const prefs: ChargingPreferencesKWH = {
 *   minChargeAtDestinationInkWh: 15,
 *   minChargeAtChargingStopsInkWh: 10
 * };
 * ```
 *
 * @group Vehicle
 */
export declare type ChargingPreferencesKWH = {
    /**
     * The minimum battery kWh you wish to arrive at your destination with.
     *
     * @remarks
     * **Typical Values (based on battery size):**
     * - Small EV (40 kWh): 5-10 kWh buffer
     * - Medium EV (75 kWh): 10-15 kWh buffer
     * - Large EV (100 kWh): 15-20 kWh buffer
     *
     * Minimum: 0, Maximum: `maxChargeKWH`
     *
     * @example
     * ```typescript
     * minChargeAtDestinationInkWh: 15  // 15 kWh remaining
     * minChargeAtDestinationInkWh: 10  // 10 kWh buffer
     * ```
     */
    minChargeAtDestinationInkWh: number;
    /**
     * The minimum battery kWh you wish to arrive at each charging station with.
     *
     * @remarks
     * However, the remaining charge at the first charging stop may be lower.
     *
     * **Typical Values:**
     * - Conservative: 15-20 kWh
     * - Moderate: 10-15 kWh
     * - Minimal: 5-10 kWh
     *
     * Minimum: 0, Maximum: half of `maxChargeKWH`
     *
     * @example
     * ```typescript
     * minChargeAtChargingStopsInkWh: 10  // 10 kWh at each stop
     * minChargeAtChargingStopsInkWh: 15  // Conservative buffer
     * ```
     */
    minChargeAtChargingStopsInkWh: number;
};

/**
 * Charging preferences specified by battery percentage.
 *
 * @remarks
 * Requires `maxChargeKWH` to be set in the vehicle model.
 *
 * @example
 * ```typescript
 * const prefs: ChargingPreferencesPCT = {
 *   minChargeAtDestinationPCT: 20,
 *   minChargeAtChargingStopsPCT: 10
 * };
 * ```
 *
 * @group Vehicle
 */
export declare type ChargingPreferencesPCT = {
    /**
     * The minimum battery percentage you wish to arrive at your destination with.
     *
     * @remarks
     * Requires `maxChargeKWH` to be set in the vehicle model.
     *
     * Ensures you don't arrive with critically low battery, providing a safety buffer.
     *
     * **Typical Values:**
     * - Conservative: 20-30% (safe buffer)
     * - Moderate: 10-20% (some buffer)
     * - Minimal: 5-10% (tight planning)
     *
     * Minimum: 0, Maximum: 100
     *
     * @example
     * ```typescript
     * minChargeAtDestinationPCT: 20  // Arrive with 20% battery
     * minChargeAtDestinationPCT: 15  // Moderate buffer
     * ```
     */
    minChargeAtDestinationPCT: number;
    /**
     * The minimum battery percentage you wish to arrive at each charging station with.
     *
     * @remarks
     * However, the remaining charge at the first charging stop may be lower.
     * Requires `maxChargeKWH` to be set in the vehicle model.
     *
     * Prevents deep discharge by ensuring you don't arrive at chargers with critically
     * low battery. This accounts for unexpected detours or charger unavailability.
     *
     * **Typical Values:**
     * - Conservative: 15-20%
     * - Moderate: 10-15%
     * - Minimal: 5-10%
     *
     * Minimum: 0, Maximum: 50
     *
     * @example
     * ```typescript
     * minChargeAtChargingStopsPCT: 10  // 10% buffer at each stop
     * minChargeAtChargingStopsPCT: 15  // Conservative buffer
     * ```
     */
    minChargeAtChargingStopsPCT: number;
};

/**
 * Parameters for the EV Charging Stations Availability service.
 *
 * Fetches real-time availability status of charging points at an EV charging park.
 *
 * @remarks
 * **Key Information Returned:**
 * - Charging point availability status (Available, Occupied, Reserved, Out of Service)
 * - Connector details (power ratings, plug types)
 * - Aggregated availability counts
 * - Access restrictions
 * - Opening hours
 *
 * **Use Cases:**
 * - Show available chargers in navigation apps
 * - Display real-time status on charging station maps
 * - Help EV drivers plan charging stops
 * - Monitor charging infrastructure for fleet management
 *
 * @example
 * ```typescript
 * // Basic usage
 * const params: ChargingStationsAvailabilityParams = {
 *   key: 'your-api-key',
 *   id: 'charging-park-id-from-search'
 * };
 *
 * // From search result
 * const searchResult = await search({ query: 'EV charging' });
 * const chargingParkId = searchResult.features[0].properties.dataSources?.chargingAvailability?.id;
 *
 * const params: ChargingStationsAvailabilityParams = {
 *   key: 'your-api-key',
 *   id: chargingParkId
 * };
 * ```
 *
 * @group EV Charging
 */
export declare type ChargingStationsAvailabilityParams = CommonServiceParams<URL, ChargingStationsAvailabilityResponseAPI> & {
    /**
     * The charging availability ID.
     *
     * @remarks
     * This ID is obtained from a previous Search API request, specifically from
     * the `dataSources.chargingAvailability.id` field of a charging station place.
     *
     * **How to Get the ID:**
     * 1. Search for EV charging stations
     * 2. Extract the ID from `place.properties.dataSources.chargingAvailability.id`
     * 3. Use this ID to fetch real-time availability
     *
     * @example
     * ```typescript
     * // From search result
     * const place = searchResults.features[0];
     * const id = place.properties.dataSources?.chargingAvailability?.id;
     *
     * // Use in availability request
     * id: 'US-12345-CHGID-001'
     * ```
     */
    id: string;
};

/**
 * @ignore
 */
declare type ChargingStationsAvailabilityResponseAPI = {
    summary: {
        numResults: number;
        offset: number;
        totalResults: number;
    };
    results?: EVChargingStationResultAPI[];
};

/**
 * @ignore
 */
declare type ChargingStopAPI = Omit<ChargingStopProps, 'targetChargeInPCT' | 'chargingConnectionInfo'> & {
    chargingParkLocation: ChargingParkLocationAPI;
    chargingConnectionInfo: {
        chargingVoltageInV: number;
        chargingCurrentInA: number;
        chargingCurrentType: CurrentTypeAPI;
        chargingPlugType: PlugType;
        chargingPowerInkW: number;
    };
};

/**
 * Circular search geometry (non-standard GeoJSON extension).
 *
 * Defines a circular search area by center point and radius. This is a convenience
 * type since standard GeoJSON does not include circles.
 *
 * @remarks
 * **Note:** This is not part of the official GeoJSON specification. It's a Maps SDK
 * extension that gets converted to the appropriate API format internally.
 *
 * **Coordinate Format:** `[longitude, latitude]` (standard GeoJSON order)
 *
 * @example
 * ```typescript
 * const circle: Circle = {
 *   type: 'Circle',
 *   coordinates: [4.9041, 52.3676],  // Amsterdam center
 *   radius: 2000  // 2km radius
 * };
 * ```
 *
 * @group Search
 */
export declare interface Circle {
    /**
     * Geometry type identifier.
     * Must be the literal string `'Circle'`.
     */
    type: 'Circle';
    /**
     * Center point of the circle in `[longitude, latitude]` format.
     *
     * @example [4.9041, 52.3676]
     */
    coordinates: Position;
    /**
     * Radius of the circle in meters.
     *
     * @remarks
     * Defines the search area around the center point. Places within or near
     * this radius will be included in results.
     *
     * @example 1000 // 1 kilometer
     */
    radius: number;
}

/**
 * @ignore
 */
export declare type CircleAPI = {
    type: 'CIRCLE';
    position: string;
    radius: number;
};

/**
 * The combustion consumption model is used when the engine type is set to "combustion".
 */
declare type CombustionConsumptionModel = ConsumptionModelBase & {
    /**
     * Specifies the speed-dependent component of consumption based on km/h and liters.
     */
    speedsToConsumptionsLiters: SpeedToConsumptionRate[];
    /**
     * Specifies the amount of fuel consumed for sustaining auxiliary systems of the vehicle, in liters per hour.
     *
     * It can be used to specify consumption due to devices and systems such as AC systems, radio, heating, etc.
     *
     * Minimum value: 0
     */
    auxiliaryPowerInLitersPerHour?: number;
    /**
     * Specifies the amount of chemical energy stored in one liter of fuel in megajoules (MJ).
     * * It is used in conjunction with the Efficiency parameters for conversions between saved or consumed energy and fuel.
     * * For example, energy density is 34.2 MJ/l for gasoline, and 35.8 MJ/l for Diesel fuel.
     * * This parameter must be used/required if any *Efficiency parameter is set.
     *
     * Minimum value: 1.0
     */
    fuelEnergyDensityInMJoulesPerLiter?: number;
};

declare type CombustionEngineModel = {
    /**
     * The consumption model for the combustion engine.
     * * This model is static for the vehicle and does not change along time.
     */
    consumption: CombustionConsumptionModel;
};

/**
 * Parameters specific to combustion engine vehicles.
 *
 * @remarks
 * Use for petrol, diesel, or other fuel-powered vehicles when you need
 * accurate fuel consumption and range calculations.
 *
 * @example
 * ```typescript
 * const params: CombustionVehicleParams = {
 *   engineType: 'combustion',
 *   model: {
 *     dimensions: {
 *       weightKG: 1500
 *     },
 *     engine: {
 *       consumption: {
 *         fuelEnergyDensityInMJoulesPerLiter: 34.2,
 *         speedsToConsumptionsLiters: [
 *           { speedKMH: 50, consumptionUnitsPer100KM: 6.5 },
 *           { speedKMH: 90, consumptionUnitsPer100KM: 7.2 },
 *           { speedKMH: 120, consumptionUnitsPer100KM: 9.0 }
 *         ]
 *       }
 *     }
 *   },
 *   state: {
 *     currentFuelInLiters: 45
 *   }
 * };
 * ```
 *
 * @group Vehicle
 */
export declare type CombustionVehicleParams = {
    /**
     * Combustion vehicles.
     *
     * @remarks
     * Identifies this as a fuel-powered vehicle (petrol, diesel, etc.).
     */
    engineType: 'combustion';
    /**
     * Model (static properties) specifically for combustion engine vehicles.
     *
     * @remarks
     * Can include fuel consumption curves and efficiency parameters.
     */
    model?: VehicleModel<'combustion'>;
    /**
     * State specifically for combustion engine vehicles.
     *
     * @remarks
     * Must include current fuel level for range calculations.
     */
    state?: VehicleState<'combustion'>;
    /**
     * Preferences specifically for combustion engine vehicles.
     *
     * @remarks
     * Currently no combustion-specific preferences; reserved for future features.
     */
    preferences?: VehiclePreferences<'combustion'>;
};

/**
 * State properties for combustion engine vehicles.
 *
 * @remarks
 * Tracks fuel level for consumption calculations and range predictions.
 *
 * @example
 * ```typescript
 * const state: CombustionVehicleState = {
 *   currentFuelInLiters: 45  // Half tank of a 90L tank
 * };
 * ```
 *
 * @group Vehicle
 */
export declare type CombustionVehicleState = {
    /**
     * Specifies the current supply of fuel in liters.
     *
     * @remarks
     * Used to:
     * - Calculate remaining range
     * - Determine if refueling is needed
     * - Optimize routes based on available fuel
     *
     * **Typical Tank Sizes:**
     * - Small car: 40-50 liters
     * - SUV: 60-80 liters
     * - Truck: 200-500 liters
     *
     * Minimum value: 0
     *
     * @example
     * ```typescript
     * currentFuelInLiters: 50   // 50 liters remaining
     * currentFuelInLiters: 200  // Truck with 200 liters
     * ```
     */
    currentFuelInLiters: number;
};

/**
 * Common parameters shared between fuzzy search and geocoding services.
 *
 * These parameters control search behavior that applies to both fuzzy search
 * and geocoding operations, including autocomplete mode, pagination, and geographic filtering.
 *
 * @remarks
 * Used by:
 * - {@link fuzzySearch}
 * - {@link geocode}
 *
 * @group Search
 */
export declare type CommonGeocodeAndFuzzySearchParams = {
    /**
     * Enable predictive/autocomplete mode for partial input queries.
     *
     * When true, the query is treated as incomplete text being typed by a user,
     * and the search returns suggestions that match the partial input.
     *
     * @remarks
     * **Autocomplete Behavior:**
     * - Optimized for real-time search-as-you-type
     * - Returns results that start with or contain the query
     * - Better for interactive search boxes
     * - Lower result quality thresholds to show more options
     *
     * **Regular Search (false):**
     * - Treats query as complete input
     * - Higher quality thresholds
     * - Better for final search submission
     *
     * @default false
     *
     * @example
     * ```typescript
     * // Autocomplete mode for "Amst" input
     * typeahead: true   // Returns: Amsterdam, Amstelveen, etc.
     *
     * // Regular search mode
     * typeahead: false  // Expects complete query
     * ```
     */
    typeahead?: boolean;
    /**
     * Starting position within the complete result set for pagination.
     *
     * Use with `limit` to implement pagination through large result sets.
     * Zero-based index indicating which result to start from.
     *
     * @remarks
     * **Pagination Pattern:**
     * - Page 1: `offset: 0, limit: 10` (results 0-9)
     * - Page 2: `offset: 10, limit: 10` (results 10-19)
     * - Page 3: `offset: 20, limit: 10` (results 20-29)
     *
     * **Performance Note:**
     * Very high offset values may have slower performance.
     *
     * @default 0
     *
     * @example
     * ```typescript
     * // First page
     * offset: 0
     *
     * // Second page (assuming limit: 10)
     * offset: 10
     *
     * // Third page
     * offset: 20
     * ```
     */
    offset?: number;
    /**
     * Search radius in meters around the specified position.
     *
     * When used with `position`, constrains results to locations within
     * this distance from the position. Creates a circular search area.
     *
     * @remarks
     * **Behavior:**
     * - Must be used with `position` parameter
     * - Values ≤ 0 are ignored (parameter has no effect)
     * - Mutually exclusive with `boundingBox` (radius takes precedence)
     *
     * **Typical Values:**
     * - 500m: Immediate vicinity (walking distance)
     * - 2000m: Neighborhood area
     * - 5000m: City district
     * - 10000m: Greater city area
     *
     * @example
     * ```typescript
     * // Search within 1km radius
     * radiusMeters: 1000
     *
     * // Search within 5km radius
     * radiusMeters: 5000
     *
     * // Combined with position
     * position: [4.9, 52.3],
     * radiusMeters: 2000  // Within 2km of Amsterdam center
     * ```
     */
    radiusMeters?: number;
    /**
     * Bounding box to constrain search results to a rectangular area.
     *
     * Filters results to only include locations within the specified bounding box.
     * Accepts various GeoJSON formats that contain or can derive a bounding box.
     *
     * @remarks
     * **Accepted Formats:**
     * - Direct BBox array: `[minLng, minLat, maxLng, maxLat]`
     * - GeoJSON Feature/FeatureCollection with bbox property
     * - Any GeoJSON geometry (bbox calculated automatically)
     *
     * **Important:**
     * - Mutually exclusive with Point-Radius parameters
     * - Point-Radius (`position` + `radiusMeters`) takes precedence if both provided
     * - Useful for map viewport filtering
     *
     * **Use Cases:**
     * - "Search in visible map area"
     * - City/region boundary filtering
     * - Custom geographic restrictions
     *
     * @example
     * ```typescript
     * // Direct bounding box (Amsterdam area)
     * boundingBox: [4.8, 52.3, 5.0, 52.4]
     *
     * // From GeoJSON Feature
     * boundingBox: {
     *   type: 'Feature',
     *   bbox: [4.8, 52.3, 5.0, 52.4],
     *   geometry: { ... },
     *   properties: {}
     * }
     *
     * // From Polygon (bbox calculated)
     * boundingBox: {
     *   type: 'Polygon',
     *   coordinates: [[
     *     [4.8, 52.3],
     *     [5.0, 52.3],
     *     [5.0, 52.4],
     *     [4.8, 52.4],
     *     [4.8, 52.3]
     *   ]]
     * }
     * ```
     */
    boundingBox?: HasBBox;
    /**
     * Restrict search to specific countries.
     *
     * Limits results to locations within the specified countries only.
     * Useful for country-specific searches or compliance requirements.
     *
     * @remarks
     * **Country Code Formats:**
     * - ISO 3166-1 alpha-2: Two-letter codes (e.g., "US", "FR", "DE")
     * - ISO 3166-1 alpha-3: Three-letter codes (e.g., "USA", "FRA", "DEU")
     * - Can mix formats: `["US", "FRA", "DE"]`
     *
     * **Behavior:**
     * - Multiple countries create OR condition (results from any listed country)
     * - Case-insensitive
     * - The `view` parameter may affect available countries
     *
     * **Use Cases:**
     * - Regional applications (EU-only, North America-only)
     * - Compliance with data sovereignty rules
     * - Simplifying results for specific markets
     *
     * @example
     * ```typescript
     * // Single country (United States)
     * countries: ['US']
     *
     * // Multiple countries (Europe)
     * countries: ['FR', 'DE', 'NL', 'BE']
     *
     * // Mixed formats
     * countries: ['US', 'GBR', 'CA']
     *
     * // North America
     * countries: ['USA', 'CAN', 'MEX']
     * ```
     */
    countries?: string[];
};

/**
 * Common parameters shared across places-related services.
 *
 * These parameters are used by search, geocoding, and reverse geocoding services
 * to customize query behavior, filter results, and control response formatting.
 *
 * @typeParam ApiRequest - The API request type (typically URL or FetchInput)
 * @typeParam ApiResponse - The API response type
 *
 * @remarks
 * **Applied to Services:**
 * - {@link search} and {@link fuzzySearch}
 * - {@link geocode}
 * - {@link reverseGeocode}
 * - {@link autocompleteSearch}
 * - {@link geometrySearch}
 *
 * **Key Features:**
 * - Result limits and pagination
 * - Geographic biasing for location-aware results
 * - Result type filtering (addresses, POIs, geographies)
 * - Additional data inclusion (mapcodes, extended postal codes)
 * - Geopolitical view context for disputed territories
 *
 * @example
 * ```typescript
 * // Basic search with position bias
 * const searchParams: CommonPlacesParams<URL, Response> = {
 *   query: 'pizza restaurant',
 *   position: [4.9041, 52.3676],  // Near Amsterdam
 *   limit: 20
 * };
 *
 * // Search with geography type filter
 * const citySearch: CommonPlacesParams<URL, Response> = {
 *   query: 'Paris',
 *   geographyTypes: ['Municipality'],  // Only cities
 *   limit: 10
 * };
 *
 * // Search with mapcodes and specific geopolitical view
 * const detailedSearch: CommonPlacesParams<URL, Response> = {
 *   query: 'disputed location',
 *   view: 'IN',  // India's perspective
 *   mapcodes: ['Local', 'International'],
 *   extendedPostalCodesFor: ['PAD', 'POI'],
 *   limit: 5
 * };
 *
 * // Address search with extended postal codes
 * const addressSearch: CommonPlacesParams<URL, Response> = {
 *   query: '123 Main Street',
 *   geographyTypes: ['Country', 'Municipality'],
 *   extendedPostalCodesFor: ['Geo', 'PAD', 'Addr'],
 *   limit: 15
 * };
 * ```
 *
 * @group Search
 */
export declare type CommonPlacesParams<ApiRequest, ApiResponse> = CommonServiceParams<ApiRequest, ApiResponse> & {
    /**
     * Search query string.
     *
     * The text to search for - can be an address, place name, POI, or general location query.
     * Must be properly URL encoded when sent to the API.
     *
     * @remarks
     * **Query Examples:**
     * - Street addresses: "123 Main Street, New York"
     * - Place names: "Eiffel Tower", "Central Park"
     * - POI names: "Starbucks", "McDonald's"
     * - General queries: "pizza near me", "gas station"
     * - Partial inputs: "Amst" (for autocomplete)
     *
     * The query is processed with fuzzy matching to handle typos and variations.
     *
     * @example
     * ```typescript
     * query: "1600 Pennsylvania Avenue, Washington DC"
     * query: "Amsterdam Central Station"
     * query: "coffee shop"
     * ```
     */
    query: string;
    /**
     * Geographic position to bias search results.
     *
     * When provided, results closer to this position are ranked higher.
     * Does not filter results, only influences ranking.
     *
     * @remarks
     * **Coordinates:**
     * - Longitude: -180 to +180 (East-West)
     * - Latitude: -90 to +90 (North-South)
     * - Format: [longitude, latitude]
     *
     * **Without Radius:**
     * Supplying position without a radius parameter biases results toward this area
     * but doesn't create a hard boundary.
     *
     * **Use Cases:**
     * - "Find pizza near me" - bias toward user's location
     * - "Main Street" - prioritize Main Streets in the target area
     * - Local search within a city or region
     *
     * @example
     * ```typescript
     * position: [4.9041, 52.3676]  // Amsterdam coordinates
     * position: [-74.0060, 40.7128]  // New York coordinates
     * ```
     */
    position?: HasLngLat;
    /**
     * Maximum number of results to return.
     *
     * Controls pagination by limiting the number of results in a single response.
     * Use with `offset` (in specific service params) for pagination.
     *
     * @remarks
     * **Range:** 1 to 100
     *
     * **Considerations:**
     * - Higher limits increase response size and processing time
     * - Lower limits improve performance
     * - Use pagination for large result sets
     *
     * @default 10
     *
     * @example
     * ```typescript
     * limit: 20   // Get 20 results
     * limit: 5    // Get only top 5 results
     * limit: 100  // Maximum allowed
     * ```
     */
    limit?: number;
    /**
     * Indexes for which to include extended postal codes in results.
     *
     * Extended postal codes provide more detailed postal code information
     * including sub-divisions and hierarchical structures.
     *
     * @remarks
     * **Default Behavior:**
     * Extended postal codes are included for all indexes except `Geo` by default.
     * Geographic entities can have very long postal code lists, so they must
     * be explicitly requested when needed.
     *
     * **Extended vs Regular Postal Codes:**
     * - Regular: "10001" (basic ZIP code)
     * - Extended: "10001-1234" (ZIP+4 format)
     *
     * **Performance Note:**
     * Including extended postal codes for geographies can significantly
     * increase response size.
     *
     * @example
     * ```typescript
     * // Include for addresses and POIs only
     * extendedPostalCodesFor: ['PAD', 'Addr', 'POI']
     *
     * // Include for all types including geographies
     * extendedPostalCodesFor: ['Geo', 'PAD', 'Addr', 'Str', 'XStr', 'POI']
     * ```
     */
    extendedPostalCodesFor?: SearchIndexType[];
    /**
     * Request mapcode representations for locations.
     *
     * Mapcodes are short, human-friendly location codes that can represent
     * any location on Earth to within a few meters. They're easier to
     * remember and communicate than coordinates.
     *
     * @remarks
     * **Mapcode Types:**
     * - `Local`: Short codes valid within a specific territory (e.g., "49.4V" in Netherlands)
     * - `International`: Codes that work globally (e.g., "NLD 49.4V")
     * - `Alternative`: Alternative representations for the same location
     *
     * **Use Cases:**
     * - Emergency services (shorter than full addresses)
     * - Areas without formal addressing systems
     * - Easy verbal communication of locations
     * - Navigation to precise spots
     *
     * @see [Mapcode Project](https://www.mapcode.com)
     *
     * @example
     * ```typescript
     * // Get all mapcode types
     * mapcodes: ['Local', 'International', 'Alternative']
     *
     * // Get only local mapcodes
     * mapcodes: ['Local']
     * ```
     */
    mapcodes?: MapcodeType[];
    /**
     * Geopolitical view for disputed territories.
     *
     * Determines how borders and place names are displayed for disputed
     * territories, according to different countries' perspectives.
     *
     * @remarks
     * **Available Views:**
     * - `Unified`: International/neutral view (default)
     * - `AR`: Argentina's perspective
     * - `IN`: India's perspective
     * - `PK`: Pakistan's perspective
     * - `IL`: Israel's perspective
     * - `MA`: Morocco's perspective
     * - `RU`: Russia's perspective
     * - `TR`: Turkey's perspective
     * - `CN`: China's perspective
     *
     * **Affected Elements:**
     * - Border lines on maps
     * - Territory names
     * - Administrative classifications
     * - Place name spellings
     *
     * **Legal Compliance:**
     * Use appropriate views based on your target audience and
     * legal requirements in different regions.
     *
     * @default 'Unified'
     *
     * @example
     * ```typescript
     * view: 'Unified'  // Neutral international view
     * view: 'IN'       // India's perspective
     * view: 'CN'       // China's perspective
     * ```
     */
    view?: View;
    /**
     * Filter results to specific geography types.
     *
     * Restricts results to only geographic entities of the specified types,
     * filtering out other result types like POIs or addresses.
     *
     * @remarks
     * **Geography Hierarchy (largest to smallest):**
     * - `Country`: Sovereign nations
     * - `CountrySubdivision`: States, provinces, regions
     * - `CountrySecondarySubdivision`: Counties, districts
     * - `CountryTertiarySubdivision`: Sub-districts
     * - `Municipality`: Cities, towns
     * - `MunicipalitySubdivision`: City districts
     * - `Neighbourhood`: Neighborhoods, quarters
     * - `PostalCodeArea`: Areas defined by postal codes
     *
     * **Filtering Behavior:**
     * When specified, only Geography results with matching entity types
     * are returned. POIs, addresses, and other result types are excluded.
     *
     * **Use Cases:**
     * - City/country search for travel apps
     * - Administrative boundary lookups
     * - Filtering out POI noise in geographic searches
     * - Hierarchical location pickers
     *
     * @example
     * ```typescript
     * // Search only for cities
     * geographyTypes: ['Municipality']
     *
     * // Search for countries and cities
     * geographyTypes: ['Country', 'Municipality']
     *
     * // Search for all administrative levels
     * geographyTypes: [
     *   'Country',
     *   'CountrySubdivision',
     *   'CountrySecondarySubdivision',
     *   'Municipality'
     * ]
     *
     * // Search for postal code areas only
     * geographyTypes: ['PostalCodeArea']
     * ```
     */
    geographyTypes?: GeographyType[];
};

/**
 * Common parameters shared across all routing service requests.
 *
 * These parameters configure how routes are calculated, including optimization
 * strategy, vehicle characteristics, timing constraints, and travel preferences.
 * They provide a consistent interface across different routing services.
 *
 * @remarks
 * Most routing services (calculateRoute, calculateMatrixRoute, calculateReachableRange)
 * accept these parameters to customize route calculation. They control:
 * - What to optimize for (time, distance, fuel)
 * - Vehicle constraints and capabilities
 * - When to travel (affecting traffic)
 * - What features to avoid
 * - Mode of transportation
 *
 * **Service Compatibility:**
 * - {@link calculateRoute}: All parameters supported
 * - {@link calculateMatrixRoute}: Subset of parameters
 * - {@link calculateReachableRange}: Subset of parameters
 *
 * @example
 * ```typescript
 * // Standard car route avoiding tolls
 * const routingParams: CommonRoutingParams = {
 *   costModel: {
 *     routeType: 'fast',
 *     traffic: 'live',
 *     avoid: ['tollRoads']
 *   },
 *   travelMode: 'car',
 *   when: {
 *     option: 'departAt',
 *     date: new Date('2025-10-20T08:00:00Z')
 *   }
 * };
 *
 * // Electric vehicle route with consumption model
 * const evRoutingParams: CommonRoutingParams = {
 *   costModel: {
 *     routeType: 'efficient',
 *     traffic: 'live'
 *   },
 *   travelMode: 'car',
 *   vehicle: {
 *     engineType: 'electric',
 *     model: {
 *       dimensions: {
 *         weightKG: 2000
 *       },
 *       engine: {
 *         consumption: {
 *           speedToConsumption: [
 *             { speedKMH: 50, consumptionUnitsPer100KM: 15 },
 *             { speedKMH: 90, consumptionUnitsPer100KM: 18 },
 *             { speedKMH: 120, consumptionUnitsPer100KM: 22 }
 *           ]
 *         }
 *       }
 *     },
 *     state: {
 *       currentChargeInkWh: 60
 *     }
 *   }
 * };
 *
 * // Truck route with restrictions
 * const truckParams: CommonRoutingParams = {
 *   costModel: {
 *     routeType: 'short',
 *     avoid: ['tollRoads', 'ferries']
 *   },
 *   travelMode: 'truck',
 *   vehicle: {
 *     model: {
 *       dimensions: {
 *         lengthMeters: 16.5,
 *         widthMeters: 2.5,
 *         heightMeters: 4.0,
 *         weightKG: 40000
 *       },
 *       restrictions: {
 *         restrictions: {
 *           commercial: true,
 *           maxSpeedKMH: 90
 *         }
 *       }
 *     }
 *   }
 * };
 * ```
 *
 * @see [Common Routing Parameters Documentation](https://docs.tomtom.com/routing-api/documentation/routing/common-routing-parameters)
 *
 * @group Routing
 */
export declare type CommonRoutingParams = {
    /**
     * Criteria that specifies what paths to prefer during routing.
     */
    costModel?: CostModel;
    /**
     * The primary means of transportation to be used while routing.
     *
     * The travel mode for the requested route.
     * Note that the requested travelMode may not be available for the entire route. Where
     * the requested travelMode is not available for a particular section, the element of the
     * response for that section will be 'other'.
     * @default None
     */
    travelMode?: TravelMode;
    /**
     * Specifies when to depart or arrive.
     * If past dates are supplied or in a way that are impossible to achieve
     * (e.g. an imminent arrival date for a long route), then it will default to departing now.
     * @default depart now
     */
    when?: DepartArriveParams;
    /**
     * Parameters for the vehicle that will be used to drive the route.
     */
    vehicle?: VehicleParameters;
    /**
     * The version of the API to use.
     * * The SDK will use the right default when not specified.
     * * Use it only if you really need to target a specific API version.
     */
    apiVersion?: number;
};

/**
 * Common parameters for search services with POI filtering capabilities.
 *
 * Extends basic places parameters with advanced search features including
 * category filtering, brand filtering, and EV charging station specifics.
 *
 * @typeParam ApiRequest - The API request type
 * @typeParam ApiResponse - The API response type
 *
 * @remarks
 * Used by:
 * - {@link search}
 * - {@link fuzzySearch}
 * - {@link geometrySearch}
 *
 * Provides extensive filtering options for:
 * - POI categories and brands
 * - EV charging station specifications
 * - Fuel type availability
 * - Opening hours and timezone data
 * - Related POI relationships
 *
 * @see [Search Service Documentation](https://docs.tomtom.com/search-api/documentation/search-service/search-service)
 *
 * @group Search
 */
export declare type CommonSearchParams<ApiRequest, ApiResponse> = CommonPlacesParams<ApiRequest, ApiResponse> & {
    /**
     * Specify which search indexes to query.
     *
     * Fine-tunes search by selecting specific data categories to include.
     * By default, all indexes are searched.
     *
     * @remarks
     * **Available Indexes:**
     * - `Geo`: Geographic entities (countries, cities, etc.)
     * - `PAD`: Point addresses with building numbers
     * - `Addr`: Address ranges on streets
     * - `Str`: Street names
     * - `XStr`: Cross streets (intersections)
     * - `POI`: Points of interest
     *
     * **Use Cases:**
     * - POI-only search: `['POI']`
     * - Address-only search: `['PAD', 'Addr']`
     * - Exclude geographies: `['PAD', 'Addr', 'Str', 'POI']`
     *
     * @example
     * ```typescript
     * // Search only POIs
     * indexes: ['POI']
     *
     * // Search addresses and streets only
     * indexes: ['PAD', 'Addr', 'Str']
     * ```
     */
    indexes?: SearchIndexType[];
    /**
     * Filter results to specific POI categories.
     *
     * Restricts results to Points of Interest belonging to the specified
     * categories. Use category IDs from the POI Categories API.
     *
     * @remarks
     * **Category Examples:**
     * - 7315: Restaurant
     * - 7311: Petrol/Gas Station
     * - 7313: Hotel/Motel
     * - 7832: ATM
     * - 9361: Parking
     *
     * **Multiple Categories:**
     * Results include POIs matching ANY of the specified categories (OR logic).
     *
     * **Discovery:**
     * Use the POI Categories endpoint to browse all available categories.
     *
     * @example
     * ```typescript
     * // Restaurants only
     * poiCategories: [7315]
     *
     * // Restaurants and cafes
     * poiCategories: [7315, 9376]
     *
     * // Gas stations and EV charging
     * poiCategories: [7311, 7309]
     * ```
     */
    poiCategories?: (number | POICategory)[];
    /**
     * Filter results to specific POI brands.
     *
     * Restricts results to Points of Interest belonging to the specified
     * brand names. Useful for finding specific chain locations.
     *
     * @remarks
     * **Brand Names:**
     * - Case-sensitive
     * - Exact match required
     * - Brands with commas must be quoted: `"A,B,C"`
     *
     * **Multiple Brands:**
     * Results include POIs matching ANY of the specified brands (OR logic).
     *
     * **Use Cases:**
     * - Find specific chain stores: "Starbucks", "McDonald's"
     * - Compare competing brands
     * - Brand-specific navigation
     *
     * @example
     * ```typescript
     * // Single brand
     * poiBrands: ['Starbucks']
     *
     * // Multiple brands
     * poiBrands: ['Shell', 'BP', 'Chevron']
     *
     * // Brand with comma in name
     * poiBrands: ['"A,B,C"']
     * ```
     */
    poiBrands?: string[];
    /**
     * Filter EV charging stations by connector types.
     *
     * Restricts results to EV charging stations that support at least one
     * of the specified connector types. Essential for EV drivers to find
     * compatible charging infrastructure.
     *
     * @remarks
     * **Common Connector Types:**
     * - `IEC62196Type2CableAttached`: Type 2 / Mennekes (Europe)
     * - `IEC62196Type2CCS`: CCS Combo 2 (Europe)
     * - `IEC62196Type1CCS`: CCS Combo 1 (North America)
     * - `Chademo`: CHAdeMO (Japan)
     * - `Tesla`: Tesla proprietary
     *
     * **Multiple Connectors:**
     * Results include stations with ANY of the specified connectors (OR logic).
     *
     * **Use Cases:**
     * - Find compatible chargers for specific EV model
     * - Route planning for long-distance EV travel
     * - Filter by fast charging capability
     *
     * @example
     * ```typescript
     * // CCS Combo 2 (common in Europe)
     * connectors: ['IEC62196Type2CCS']
     *
     * // Multiple connector types
     * connectors: ['IEC62196Type2CCS', 'Chademo']
     *
     * // Tesla or CCS
     * connectors: ['Tesla', 'IEC62196Type2CCS']
     * ```
     */
    connectors?: ConnectorType[];
    /**
     * Filter fuel stations by available fuel types.
     *
     * Restricts results to fuel stations that offer the specified fuel types.
     * Can be used with empty query to find any station with specific fuel.
     *
     * @remarks
     * **Common Fuel Types:**
     * - Petrol/Gasoline
     * - Diesel
     * - LPG (Liquefied Petroleum Gas)
     * - CNG (Compressed Natural Gas)
     * - E85 (Ethanol blend)
     * - AdBlue (Diesel exhaust fluid)
     *
     * **Multiple Fuel Types:**
     * Results include stations offering ANY of the specified fuels (OR logic).
     *
     * **Empty Query:**
     * When `fuelTypes` is specified, the query parameter can be empty,
     * and all POIs with matching fuel types will be returned.
     *
     * @example
     * ```typescript
     * // Diesel stations only
     * fuelTypes: ['Diesel']
     *
     * // Alternative fuels
     * fuelTypes: ['CNG', 'LPG', 'E85']
     *
     * // Standard fuels
     * fuelTypes: ['Petrol', 'Diesel']
     * ```
     */
    fuelTypes?: Fuel[];
    /**
     * Request opening hours information for POIs.
     *
     * Specifies the format and detail level of opening hours data
     * included in the response.
     *
     * @remarks
     * **Opening Hours Modes:**
     * Different modes provide varying levels of detail about when
     * a POI is open for business.
     *
     * **Use Cases:**
     * - Display "Open Now" status
     * - Show full weekly schedule
     * - Plan visits during open hours
     * - Filter to currently open locations
     *
     * @example
     * ```typescript
     * // Request opening hours
     * openingHours: 'nextSevenDays'
     * ```
     */
    openingHours?: OpeningHoursMode;
    /**
     * Request timezone information for POI locations.
     *
     * Includes timezone data in the response, useful for scheduling
     * and time-aware applications.
     *
     * @remarks
     * **Timezone Format:**
     * - `iana`: Returns IANA timezone identifier (e.g., "Europe/Amsterdam")
     *
     * **Use Cases:**
     * - Display local time for POI
     * - Schedule appointments across timezones
     * - Calculate opening hours in local time
     * - International business coordination
     *
     * @example
     * ```typescript
     * // Request IANA timezone ID
     * timeZone: 'iana'
     * ```
     */
    timeZone?: TimeZoneRequest;
    /**
     * Include related POIs in the response.
     *
     * Some POIs have hierarchical relationships (e.g., terminal inside airport).
     * This parameter controls which related POIs are included.
     *
     * @remarks
     * **Relationship Types:**
     * - `off`: No related POIs (default)
     * - `child`: Include child POIs (e.g., terminals of an airport)
     * - `parent`: Include parent POIs (e.g., airport of a terminal)
     * - `all`: Include both parent and child relationships
     *
     * **Use Cases:**
     * - Show all terminals when user searches for airport
     * - Navigate from specific location to broader facility
     * - Display hierarchical location structure
     * - Provide alternative entry points
     *
     * @default 'off'
     *
     * @example
     * ```typescript
     * // Include child POIs
     * relatedPois: 'child'  // Airport → show terminals
     *
     * // Include parent POIs
     * relatedPois: 'parent'  // Terminal → show airport
     *
     * // Include all related POIs
     * relatedPois: 'all'
     * ```
     */
    relatedPois?: RelatedPoisRequest;
    /**
     * Minimum charging power for EV stations (in kilowatts).
     *
     * Filters EV charging stations to those supporting at least one
     * connector with the specified minimum power output. Useful for
     * finding fast charging capabilities.
     *
     * @remarks
     * **Power Levels:**
     * - 3-7 kW: Level 2 AC (slow charging)
     * - 7-22 kW: Level 2 AC (moderate charging)
     * - 50+ kW: DC fast charging
     * - 150+ kW: Ultra-fast charging
     * - 350 kW: Maximum current technology
     *
     * **Closed Interval:**
     * Includes stations with exactly this power value.
     *
     * @example
     * ```typescript
     * // Fast charging (50kW+)
     * minPowerKW: 50
     *
     * // Ultra-fast charging (150kW+)
     * minPowerKW: 150
     *
     * // Combined with max power
     * minPowerKW: 50,
     * maxPowerKW: 150  // 50-150 kW range
     * ```
     */
    minPowerKW?: number;
    /**
     * Maximum charging power for EV stations (in kilowatts).
     *
     * Filters EV charging stations to those with at least one connector
     * not exceeding the specified maximum power output.
     *
     * @remarks
     * **Use Cases:**
     * - Find charging compatible with vehicle's maximum charge rate
     * - Exclude ultra-fast chargers when not needed
     * - Filter by infrastructure capability
     *
     * **Closed Interval:**
     * Includes stations with exactly this power value.
     *
     * @example
     * ```typescript
     * // Level 2 charging only (up to 22kW)
     * maxPowerKW: 22
     *
     * // Moderate fast charging (up to 50kW)
     * maxPowerKW: 50
     *
     * // Power range 50-150 kW
     * minPowerKW: 50,
     * maxPowerKW: 150
     * ```
     */
    maxPowerKW?: number;
};

/**
 * @ignore
 */
declare type CommonSearchPlaceResultAPI = Omit<SearchPlaceProps, 'distance' | 'position' | 'addressRanges' | 'geographyType' | 'entryPoints' | 'chargingPark' | 'poi'> & {
    id: string;
    position: LatLonAPI;
    dist?: number;
    viewport?: ViewportAPI;
    boundingBox?: BoundingBoxAPI;
    entryPoints?: EntryPointAPI[];
    address?: AddressProperties;
    poi?: POIAPI;
    chargingPark?: ChargingParkAPI;
};

/**
 * Common parameters shared across all service calls.
 *
 * @remarks
 * This type extends the global configuration and provides additional service-specific options
 * such as custom base URLs, request validation, and lifecycle event listeners.
 *
 * @typeParam ApiRequest - The type of the API request object
 * @typeParam ApiResponse - The type of the API response object
 *
 * @group Shared
 */
export declare type CommonServiceParams<ApiRequest = any, ApiResponse = any> = Partial<GlobalConfig> & {
    /**
     * Custom base URL for the service endpoint.
     *
     * @remarks
     * Should contain the URL up to the part that changes per service call.
     *
     * @example
     * ```ts
     * customServiceBaseURL: 'https://api.tomtom.com/search/10/reverseGeocode/'
     * ```
     *
     * @defaultValue `undefined` (uses default service URL)
     */
    customServiceBaseURL?: string;
    /**
     * Controls whether input request schema validation is performed.
     *
     * @remarks
     * When enabled, the SDK validates request parameters against the expected schema
     * before sending the request to the API. Set to `false` to skip validation.
     *
     * @defaultValue `true`
     */
    validateRequest?: boolean;
    /**
     * Callback invoked immediately before sending the request to the API.
     *
     * @remarks
     * Useful for tracking, logging, or debugging API requests before they are sent to the server.
     *
     * @param apiRequest - The API request to be sent (usually a URL for GET requests or URL with body for POST requests)
     */
    onAPIRequest?: (apiRequest: ApiRequest) => void;
    /**
     * Callback invoked when the raw response is received from the API.
     *
     * @remarks
     * Called as soon as the API response is received, before parsing.
     * The request object is the same reference as provided to {@link onAPIRequest}.
     * Useful for tracking, logging, or debugging successful API request-response pairs.
     *
     * @param apiRequest - The sent API request (same reference as in {@link onAPIRequest})
     * @param apiResponse - The received raw (unparsed) API response
     */
    onAPIResponse?: (apiRequest: ApiRequest, apiResponse: ApiResponse) => void;
};

/**
 * Common service parameters with zoom configuration.
 *
 * Extended by {@link GeometryDataParams} and {@link GeometryPlaceParams}.
 *
 * @group Geometry
 */
export declare type CommonServiceParamsWithZoom = CommonServiceParams<URL, GeometryDataResponseAPI> & {
    /**
     * Optional zoom level for geometry detail.
     *
     * @remarks
     * Controls the level of detail in the returned geometry:
     * - Lower zoom (0-5): Simplified geometry for continents/countries
     * - Medium zoom (6-12): Moderate detail for regions/cities
     * - High zoom (13-22): Full detail for neighborhoods/buildings
     *
     * **Recommendations:**
     * - Align with your map's current zoom level
     * - Use lower zoom for large geographies to reduce data size
     * - Essential for performance with very large areas
     *
     * @default undefined (returns highest detail available)
     * @minimum 0
     * @maximum 22
     *
     * @example
     * ```typescript
     * zoom: 10  // City-level detail
     * zoom: 15  // Neighborhood-level detail
     * ```
     */
    zoom?: number;
};

/**
 * Traffic computation mode for alternative travel time estimates.
 *
 * Controls whether to calculate additional travel times using different traffic scenarios.
 *
 * @remarks
 * - `none`: Only return default best-estimate travel time
 * - `all`: Return travel times for multiple traffic scenarios:
 *   - No traffic (free flow)
 *   - Historic traffic patterns
 *   - Live traffic incidents
 *
 * @example
 * ```typescript
 * // Get all traffic-based time estimates
 * const computeTravelTimeFor: ComputeTravelTimeFor = 'all';
 * ```
 *
 * @default 'none'
 *
 * @group Routing
 */
export declare type ComputeTravelTimeFor = 'none' | 'all';

/**
 * @ignore
 */
declare type ConnectorAPI = Omit<Connector, 'type' | 'chargingSpeed'> & {
    connectorType: ConnectorType;
};

declare type ConsumptionModelBase = {
    /**
     * Parameters related to consumption efficiency.
     */
    efficiency?: ConsumptionModelEfficiency;
};

/**
 * Parameters related to consumption efficiency.
 */
declare type ConsumptionModelEfficiency = {
    /**
     * Specifies the efficiency of converting stored to kinetic energy when the vehicle accelerates.
     * * For combustion, stored energy is in the form of fuel (KineticEnergyGained/ChemicalEnergyConsumed).
     * ChemicalEnergyConsumed is obtained by converting consumed fuel to chemical energy using fuelEnergyDensityInMJoulesPerLiter.
     * * For electric, stored energy is energy stored in batteries (KineticEnergyGained/ElectricEnergyConsumed).
     * * Note: This must be paired with deceleration efficiency.
     *
     * Minimum value: 0
     *
     * Maximum value: 1/deceleration
     */
    acceleration?: number;
    /**
     * Specifies the efficiency of converting kinetic energy to stored or not consumed energy when the vehicle decelerates.
     * * For combustion, the energy gain is about not consuming fuel (ChemicalEnergySaved/PotentialEnergyLost).
     * * For electric, the energy gain is about not consuming but also recharging batteries (ElectricEnergyGained/PotentialEnergyLost).
     * (i.e., ChemicalEnergySaved/KineticEnergyLost).
     * * ChemicalEnergySaved is obtained by converting saved (not consumed) fuel to energy using fuelEnergyDensityInMJoulesPerLiter.
     * * Note: This must be paired with acceleration efficiency.
     *
     * Minimum value: 0
     *
     * Maximum value: 1/acceleration
     */
    deceleration?: number;
    /**
     * Specifies the efficiency of converting stored to potential energy when the vehicle gains elevation.
     * * For combustion, stored energy is chemical energy stored in fuel (PotentialEnergyGained/ChemicalEnergyConsumed).
     * ChemicalEnergyConsumed is obtained by converting consumed fuel to chemical energy using fuelEnergyDensityInMJoulesPerLiter.
     * * For electric, stored energy is energy stored in batteries (PotentialEnergyGained/ElectricEnergyConsumed).
     *
     * Note: This must be paired with downhill efficiency.
     *
     * Minimum value: 0
     *
     * Maximum value: 1/downhill
     */
    uphill?: number;
    /**
     * Specifies the efficiency of converting potential to stored or not consumed energy when the vehicle loses elevation,
     * * For combustion, the energy gain is about not consuming fuel (ChemicalEnergySaved/PotentialEnergyLost).
     * ChemicalEnergySaved is obtained by converting saved (not consumed) fuel to energy using fuelEnergyDensityInMJoulesPerLiter.
     * * For electric, the energy gain is about not consuming but also recharging batteries (ElectricEnergyGained/PotentialEnergyLost).
     *
     * * Note: This must be paired with uphill efficiency.
     *
     * Minimum value: 0
     *
     * Maximum value: 1/uphill
     */
    downhill?: number;
};

/**
 * Intent indicating the query is a coordinate.
 *
 * Detected when the query matches a coordinate format
 * (e.g., "48.858380, 2.294440" or "52°31'N 13°24'E").
 *
 * @group Fuzzy Search
 */
export declare type CoordinateIntent = {
    /**
     * Query type identifier.
     *
     * The query is a coordinate in one of the supported formats.
     */
    type: 'COORDINATE';
    /**
     * Details about the detected coordinate.
     */
    details: CoordinateIntentDetails;
};

/**
 * @ignore
 */
export declare type CoordinateIntentAPI = {
    /**
     * the query is a coordinate in one of the supported formats (e.g., "48.858380, 2.294440").
     */
    type: 'COORDINATE';
    details: CoordinateIntentDetailsAPI;
};

/**
 * Details for a coordinate query intent.
 *
 * Contains the parsed coordinate position from the user's query.
 *
 * @group Fuzzy Search
 */
export declare type CoordinateIntentDetails = {
    /**
     * Position of the parsed coordinate from user input.
     *
     * Results will be places nearby this coordinate. If a position parameter
     * was also specified in the request, the distance field will show the
     * distance between the geo bias and the searched coordinate.
     */
    position: Position;
};

/**
 * @ignore
 */
export declare type CoordinateIntentDetailsAPI = {
    /**
     * Latitude of the (parsed) user input coordinate. See LatLon. The results will be places nearby this coordinate.
     * If lat and lon parameters are specified, the dist field will have the distance between the geoBias and the searched coordinate.
     */
    lat: number;
    /**
     * Longitude of the (parsed) user input coordinate.
     */
    lon: number;
};

/**
 * Cost model criteria for route optimization.
 *
 * Defines routing preferences and constraints that influence path selection.
 * Combines route type, traffic consideration, and avoidance criteria to determine
 * what makes a route "better" in the eyes of the routing engine.
 *
 * @remarks
 * The cost model balances multiple factors:
 * - Time efficiency
 * - Distance
 * - Fuel/energy consumption
 * - User preferences (avoid tolls, ferries, etc.)
 * - Traffic conditions
 *
 * @example
 * ```typescript
 * // Fast route avoiding tolls
 * const costModel: CostModel = {
 *   routeType: 'fast',
 *   traffic: 'live',
 *   avoid: ['tollRoads']
 * };
 *
 * // Eco-friendly route avoiding highways
 * const ecoCostModel: CostModel = {
 *   routeType: 'efficient',
 *   traffic: 'historical',
 *   avoid: ['motorways', 'ferries']
 * };
 *
 * // Scenic route for leisure
 * const scenicCostModel: CostModel = {
 *   routeType: 'thrilling',
 *   avoid: ['motorways', 'tollRoads']
 * };
 * ```
 *
 * @group Routing
 */
export declare type CostModel = {
    /**
     * Specifies something that the route calculation should try to avoid when determining the route.
     * @default None
     */
    avoid?: Avoidable[];
    /**
     * Decides how traffic is considered for computing routes.
     * Possible values are:
     * * live: In addition to historical travel times, routing and estimated travel time
     * consider traffic jams and short- and long-term closures during the travel time window.
     * * historical: Routing and estimated travel time consider historical travel times and long term closures.
     * Traffic jams and short-term closures during the travel time window do not influence routing or travel time.
     * @default live
     */
    traffic?: TrafficInput;
    /**
     * Specifies the type of optimization used when calculating routes.
     * Possible values are:
     *
     * * **fast**: Route calculation is optimized by travel time, while keeping the routes sensible. For example, the calculation may avoid shortcuts along inconvenient side roads or long detours that only save very little time.
     * * **short**: Route calculation is optimized such that a good compromise between small travel time and short travel distance is achieved.
     * * **efficient**: Route calculation is optimized such that a good compromise between small travel time and low fuel or energy consumption is achieved.
     * * **thrilling**: Route calculation is optimized such that routes include interesting or challenging roads and use as few motorways as possible.
     * There is a limit of 900km on routes planned with routeType=thrilling.
     * @default fast
     */
    routeType?: RouteType;
};

/**
 * @ignore
 */
declare type CurrentTypeAPI = 'Direct_Current' | 'Alternating_Current_1_Phase' | 'Alternating_Current_3_Phase';

/**
 * Access to service implementation components for advanced customization.
 *
 * This object provides low-level access to the internal components of each service,
 * allowing developers to customize request building, response parsing, and other
 * aspects of service behavior. This is useful for advanced use cases like:
 * - Custom request/response transformations
 * - Integration with custom API gateways or proxies
 * - Adding custom validation or error handling
 * - Implementing request/response logging or monitoring
 * - Adapting to custom API endpoints or versions
 *
 * @remarks
 * Most developers won't need to use this directly. The standard service functions
 * (like `geocode`, `search`, `calculateRoute`) are sufficient for typical use cases.
 * Only use customization when you need to modify the internal service behavior.
 *
 * Each service exposes:
 * - Request builders: Functions that construct API requests
 * - Response parsers: Functions that transform API responses
 * - Templates: Configuration objects defining service behavior
 * - Validation schemas: Input parameter validation rules
 *
 * @example
 * ```typescript
 * // Access request builder for custom processing
 * import { customizeService } from '@tomtom-international/web-sdk-services';
 *
 * const { buildRequest } = customizeService.geocode;
 * const request = buildRequest({
 *   key: 'your-api-key',
 *   query: 'Amsterdam'
 * });
 *
 * // Access response parser for custom handling
 * const { parseResponse } = customizeService.geocode;
 * const rawApiResponse = await fetch(request.url);
 * const parsedData = parseResponse(await rawApiResponse.json());
 * ```
 *
 * @group Advanced
 */
export declare const customizeService: {
    reverseGeocode: {
        buildRevGeoRequest: (params: ReverseGeocodingParams) => URL;
        parseRevGeoResponse: (apiResponse: ReverseGeocodingResponseAPI, params: ReverseGeocodingParams) => ReverseGeocodingResponse;
        reverseGeocodingTemplate: ReverseGeocodingTemplate;
    };
    geocode: {
        buildGeocodingRequest: (params: GeocodingParams) => URL;
        parseGeocodingResponse: (apiResponse: GeocodingResponseAPI) => GeocodingResponse;
        geocodingTemplate: GeocodingTemplate;
    };
    geometryData: {
        buildGeometryDataRequest: (params: GeometryParams) => URL;
        parseGeometryDataResponse: (apiResponse: GeometryDataResponseAPI) => PolygonFeatures;
        geometryDataTemplate: GeometryDataTemplate;
    };
    geometrySearch: {
        geometrySearch: (params: GeometrySearchParams, customTemplate?: Partial<GeometrySearchTemplate>) => Promise<GeometrySearchResponse>;
        buildGeometrySearchRequest: (params: GeometrySearchParams) => PostObject<GeometrySearchPayloadAPI>;
        parseGeometrySearchResponse: (apiResponse: GeometrySearchResponseAPI) => GeometrySearchResponse;
        geometrySearchTemplate: GeometrySearchTemplate;
    };
    calculateRoute: {
        buildCalculateRouteRequest: (params: CalculateRouteParams) => FetchInput<CalculateRoutePOSTDataAPI>;
        parseCalculateRouteResponse: (apiResponse: CalculateRouteResponseAPI, params: CalculateRouteParams) => Routes;
        calculateRouteTemplate: CalculateRouteTemplate;
    };
    reachableRange: {
        buildReachableRangeRequest: (params: ReachableRangeParams) => URL;
        parseReachableRangeResponse: (apiResponse: ReachableRangeResponseAPI, params: ReachableRangeParams) => PolygonFeature<ReachableRangeParams>;
        reachableRangeTemplate: ReachableRangeTemplate;
    };
    evChargingStationsAvailability: {
        buildEVChargingStationsAvailabilityRequest: (params: ChargingStationsAvailabilityParams) => URL;
        parseEVChargingStationsAvailabilityResponse: (apiResponse: ChargingStationsAvailabilityResponseAPI) => ChargingStationsAvailability | undefined;
        evChargingStationsAvailabilityTemplate: EVChargingStationsAvailabilityTemplate;
    };
    placeByID: {
        buildPlaceByIdRequest: (params: PlaceByIdParams) => URL;
        parsePlaceByIdResponse: (apiResponse: PlaceByIdResponseAPI) => PlaceByIdResponse;
        placeByIdTemplate: PlaceByIdTemplate;
    };
    autocompleteSearch: {
        autocompleteSearch: (params: AutocompleteSearchParams, customTemplate?: Partial<AutocompleteSearchTemplate>) => Promise<AutocompleteSearchResponse>;
        buildAutocompleteSearchRequest: (params: AutocompleteSearchParams) => URL;
        parseAutocompleteSearchResponse: (apiResponse: AutocompleteSearchResponseAPI) => AutocompleteSearchResponse;
        autocompleteSearchTemplate: AutocompleteSearchTemplate;
    };
};

/**
 * @ignore
 */
declare interface DefaultAPIResponseErrorBody extends BaseAPIResponseErrorBody {
    error?: string;
    errorText?: string;
}

declare type DepartArriveOption = 'departAt' | 'arriveBy';

/**
 * Departure or arrival time specification for route planning.
 *
 * Allows specifying either when to depart from the origin or when to arrive at the destination.
 * The routing engine calculates the route optimized for that specific time window, considering
 * traffic patterns for that time of day.
 *
 * @typeParam Option - Whether this specifies departure or arrival time
 *
 * @remarks
 * Traffic conditions vary significantly by:
 * - Time of day (rush hour vs off-peak)
 * - Day of week (weekday vs weekend)
 * - Special events or holidays
 *
 * Specifying a departure or arrival time enables the router to:
 * - Use appropriate traffic data for that time
 * - Plan around rush hour or quiet periods
 * - Calculate accurate arrival/departure times
 * - Account for time-dependent road restrictions
 *
 * **Important Notes:**
 * - Times are processed in the timezone of the origin/destination
 *
 * @example
 * ```typescript
 * // Depart at specific time (morning commute)
 * const departParams: DepartArriveParams = {
 *   option: 'departAt',
 *   date: new Date('2025-10-20T08:00:00Z')
 * };
 *
 * // Arrive by specific time (catch a flight)
 * const arriveParams: DepartArriveParams = {
 *   option: 'arriveBy',
 *   date: new Date('2025-10-20T14:00:00Z')
 * };
 *
 * // Plan route avoiding rush hour
 * const offPeakDepart: DepartArriveParams = {
 *   option: 'departAt',
 *   date: new Date('2025-10-20T10:30:00Z')  // After morning rush
 * };
 * ```
 *
 * @group Routing
 */
export declare type DepartArriveParams<Option extends DepartArriveOption = DepartArriveOption> = {
    /**
     * Whether to specify a departure or arrival time.
     *
     * @remarks
     * - `departAt`: Calculate route from this departure time forward
     * - `arriveBy`: Calculate route backward to arrive by this time
     */
    option: Option;
    /**
     * The date and time to depart or arrive.
     *
     * @remarks
     * If past dates are supplied or dates that are impossible to achieve
     * (e.g., an imminent arrival date for a very long route), the system
     * will default to departing immediately.
     *
     * Times should be specified in ISO 8601 format or as JavaScript Date objects.
     */
    date: Date;
};

/**
 * The electric consumption model is used when the engine type is set to "combustion".
 */
declare type ElectricConsumptionModel = ConsumptionModelBase & {
    /**
     * Specifies the speed-dependent component of consumption based on km/h and kW/h.
     */
    speedsToConsumptionsKWH: SpeedToConsumptionRate[];
    /**
     * Specifies the amount of power consumed for sustaining auxiliary systems, in kilowatts (kW).
     * * It can be used to specify consumption due to devices and systems such as AC systems, radio, heating, etc.
     *
     * Minimum value: 0
     */
    auxiliaryPowerInkW?: number;
    /**
     * Specifies the electric energy in kWh consumed by the vehicle through gaining 1000 meters of elevation.
     * * Note: It must be paired with recuperationInkWhPerKMAltitudeLoss.
     * * Note: It cannot be used with any efficiency parameters.
     *
     * Minimum value: recuperationInkWhPerKMAltitudeLoss
     *
     * Maximum value: 500.0
     */
    consumptionInKWHPerKMAltitudeGain?: number;
    /**
     * Specifies the electric energy in kWh gained by the vehicle through losing 1000 meters of elevation.
     * Note: It must be paired with consumptionInkWhPerKMAltitudeGain.
     * Note: It cannot be used with accelerationEfficiency, decelerationEfficiency, uphillEfficiency or downhillEfficiency.
     *
     * Minimum value: 0.0
     * Maximum value: consumptionInkWhPerKMAltitudeGain
     */
    recuperationInKWHPerKMAltitudeLoss?: number;
};

declare type ElectricEngineModel = {
    /**
     * Electric engine consumption model.
     */
    consumption: ElectricConsumptionModel;
    /**
     * Battery charging model.
     */
    charging?: ChargingModel;
};

/**
 * Parameters specific to electric vehicles (EVs).
 *
 * @remarks
 * Use for battery electric vehicles when you need accurate range predictions,
 * charging stop calculations, and EV-specific routing.
 *
 * **Key Features:**
 * - Battery consumption modeling
 * - Charging stop optimization
 * - Regenerative braking consideration
 * - Charging curve integration
 *
 * @example
 * ```typescript
 * const params: ElectricVehicleParams = {
 *   engineType: 'electric',
 *   model: {
 *     dimensions: {
 *       weightKG: 2000
 *     },
 *     engine: {
 *       charging: {
 *         maxChargeKWH: 75,
 *         batteryCurve: [
 *           { stateOfChargeInkWh: 50, maxPowerInkW: 200 },
 *           { stateOfChargeInkWh: 70, maxPowerInkW: 100 },
 *           { stateOfChargeInkWh: 80, maxPowerInkW: 40 },
 *         ],
 *         chargingConnectors: [
 *           {
 *             currentType: 'AC3',
 *             plugTypes: [
 *               'IEC_62196_Type_2_Outlet',
 *               'IEC_62196_Type_2_Connector_Cable_Attached',
 *               'Combo_to_IEC_62196_Type_2_Base',
 *             ],
 *             efficiency: 0.9,
 *             baseLoadInkW: 0.2,
 *             maxPowerInkW: 11,
 *           },
 *           {
 *             currentType: 'DC',
 *             plugTypes: [
 *               'IEC_62196_Type_2_Outlet',
 *               'IEC_62196_Type_2_Connector_Cable_Attached',
 *               'Combo_to_IEC_62196_Type_2_Base',
 *             ],
 *             voltageRange: { minVoltageInV: 0, maxVoltageInV: 500 },
 *             efficiency: 0.9,
 *             baseLoadInkW: 0.2,
 *             maxPowerInkW: 150,
 *           },
 *         ]
 *       },
 *       consumption: {
 *         speedsToConsumptionsKWH: [
 *           { speedKMH: 50, consumptionUnitsPer100KM: 15 },
 *           { speedKMH: 90, consumptionUnitsPer100KM: 18 },
 *           { speedKMH: 120, consumptionUnitsPer100KM: 23 }
 *         ]
 *       }
 *     }
 *   },
 *   state: {
 *     currentChargePCT: 80
 *   },
 *   preferences: {
 *     chargingPreferences: {
 *       minChargeAtDestinationPCT: 20,
 *       minChargeAtChargingStopsPCT: 10
 *     }
 *   }
 * };
 * ```
 *
 * @group Vehicle
 */
export declare type ElectricVehicleParams = {
    /**
     * Electric vehicles (EV).
     *
     * @remarks
     * Identifies this as a battery electric vehicle.
     */
    engineType: 'electric';
    /**
     * Model (static properties) specifically for electric vehicles.
     *
     * @remarks
     * Should include battery capacity, charging curve, and consumption profiles.
     */
    model?: VehicleModel<'electric'>;
    /**
     * State specifically for electric vehicles.
     *
     * @remarks
     * Must include current battery charge (percentage or kWh) for range calculations.
     */
    state?: VehicleState<'electric'>;
    /**
     * Preferences specifically for electric vehicles.
     *
     * @remarks
     * Includes charging preferences for long-distance trips with charging stops.
     */
    preferences?: VehiclePreferences<'electric'>;
};

/**
 * Preferences specific to electric vehicles.
 *
 * @remarks
 * Contains EV-specific routing preferences, primarily for long-distance trips
 * with charging stops.
 *
 * @example
 * ```typescript
 * const evPrefs: ElectricVehiclePreferences = {
 *   chargingPreferences: {
 *     minChargeAtDestinationPCT: 20,
 *     minChargeAtChargingStopsPCT: 10
 *   }
 * };
 * ```
 *
 * @group Vehicle
 */
export declare type ElectricVehiclePreferences = {
    /**
     * Charging preferences for Long Distance EV Routing.
     *
     * @remarks
     * Specifying these preferences will trigger the calculation of charging stops along your route.
     * Requires the ElectricConsumptionModel to be set.
     *
     * **When Charging Stops Are Added:**
     * - Route exceeds single-charge range
     * - Preferences ensure safe battery levels
     * - Optimal charger locations are found
     * - Charging time is minimized
     *
     * @see {@link https://docs.tomtom.com/routing-api/documentation/extended-routing/long-distance-ev-routing | Long Distance EV Routing}
     *
     * @example
     * ```typescript
     * chargingPreferences: {
     *   minChargeAtDestinationPCT: 20,
     *   minChargeAtChargingStopsPCT: 10
     * }
     * ```
     */
    chargingPreferences?: ChargingPreferences;
};

/**
 * Electric vehicle state - either percentage or absolute energy.
 *
 * @remarks
 * Choose the format that matches your data source:
 * - Use percentage when you have battery % and max capacity
 * - Use kWh when you have absolute energy values
 *
 * @example
 * ```typescript
 * // Percentage format
 * const pctState: ElectricVehicleState = {
 *   currentChargePCT: 75
 * };
 *
 * // Energy format
 * const kwhState: ElectricVehicleState = {
 *   currentChargeInkWh: 60
 * };
 * ```
 *
 * @group Vehicle
 */
export declare type ElectricVehicleState = ElectricVehicleStatePCT | ElectricVehicleStateKWH;

/**
 * Electric vehicle state specified by absolute energy in kilowatt-hours.
 *
 * @remarks
 * Use this when you know the exact energy remaining without needing
 * to specify the maximum battery capacity.
 *
 * @example
 * ```typescript
 * const state: ElectricVehicleStateKWH = {
 *   currentChargeInkWh: 60  // 60 kWh remaining
 * };
 * ```
 *
 * @group Vehicle
 */
export declare type ElectricVehicleStateKWH = {
    /**
     * Specifies the current battery charge in kWh.
     *
     * @remarks
     * Note: Needed if the `maxChargeKWH` is not set in the model.
     *
     * **Typical Battery Sizes:**
     * - Small EV: 30-40 kWh
     * - Mid-size EV: 60-75 kWh
     * - Large EV: 80-100+ kWh
     * - Electric truck: 150-200+ kWh
     *
     * Minimum: 0
     *
     * @example
     * ```typescript
     * currentChargeInkWh: 60   // 60 kWh remaining
     * currentChargeInkWh: 15   // Low battery (15 kWh)
     * ```
     */
    currentChargeInkWh: number;
};

/**
 * Electric vehicle state specified by battery percentage.
 *
 * @remarks
 * Requires `maxChargeKWH` to be set in the vehicle model for conversion
 * to actual energy values.
 *
 * @example
 * ```typescript
 * const state: ElectricVehicleStatePCT = {
 *   currentChargePCT: 75  // 75% battery remaining
 * };
 * ```
 *
 * @group Vehicle
 */
export declare type ElectricVehicleStatePCT = {
    /**
     * Specifies the current battery charge in percentage.
     *
     * @remarks
     * Note: Requires `model.charging.maxChargeKWH` to be set for proper
     * range calculations.
     *
     * **Minimum:** 0 (empty battery)
     * **Maximum:** 100 (fully charged)
     *
     * @example
     * ```typescript
     * currentChargePCT: 80   // 80% charged
     * currentChargePCT: 20   // 20% charged (low battery)
     * currentChargePCT: 100  // Fully charged
     * ```
     */
    currentChargePCT: number;
};

/**
 * The available engine types.
 */
declare const engineTypes: readonly ["combustion", "electric"];

/**
 * @ignore
 */
declare type EntryPointAPI = Omit<EntryPoint, 'position'> & {
    /**
     * Position of the entry point.
     */
    position: LatLonAPI;
};

/**
 * @ignore
 */
declare type EVChargingStationResultAPI = {
    id: string;
    name: string;
    position: LatLonAPI;
    openingHours: OpeningHoursAPI;
    timeZone: TimeZone;
    accessType: ChargingStationsAccessType;
    chargingStations: ChargingStation[];
};

/**
 * Get real-time availability of electric vehicle charging stations.
 *
 * Provides current operational status of charging points and connectors at EV charging parks,
 * enabling drivers to find available chargers before arriving at a location.
 *
 * @remarks
 * Key information returned:
 * - **Point-level status**: Available, Occupied, Reserved, Out of Service
 * - **Connector details**: Power ratings, plug types, current availability
 * - **Aggregated counts**: Quick overview of available vs occupied chargers
 * - **Access information**: Public, private, or restricted access
 * - **Opening hours**: When the charging facility is accessible
 *
 * Use cases:
 * - EV navigation apps: Show available chargers along routes
 * - Charging station maps: Display real-time availability
 * - Trip planning: Verify chargers will be available at destination
 * - Fleet management: Monitor charging infrastructure status
 *
 * @param params - Charging availability parameters with station ID
 * @param customTemplate - Advanced customization for request/response handling
 *
 * @returns Promise resolving to charging station availability information
 *
 * @example
 * ```typescript
 * // Get availability for a specific charging park
 * const availability = await evChargingStationsAvailability({
 *   key: 'your-api-key',
 *   id: 'charging-park-id-123'
 * });
 *
 * // Check how many chargers are available
 * const availableCount = availability.chargingPointAvailability.statusCounts.Available;
 * console.log(`${availableCount} chargers available`);
 *
 * // Find available CCS connectors
 * const ccsConnectors = availability.connectorAvailabilities.find(
 *   ca => ca.connector.type === 'IEC62196Type2CCS'
 * );
 * ```
 *
 * @see [EV Charging Availability API](https://docs.tomtom.com/search-api/documentation)
 * @see [Places Quickstart Guide](https://docs.tomtom.com/maps-sdk-js/guides/services/places/quickstart)
 * @see [EV Charging Stations Availability Guide](https://docs.tomtom.com/maps-sdk-js/guides/services/places/ev-charging-stations-availability)
 *
 * @group EV Charging
 */
export declare const evChargingStationsAvailability: (params: ChargingStationsAvailabilityParams, customTemplate?: Partial<EVChargingStationsAvailabilityTemplate>) => Promise<ChargingStationsAvailability | undefined>;

/**
 * EV Charging Stations Availability service template type.
 * @ignore
 */
declare type EVChargingStationsAvailabilityTemplate = ServiceTemplate<ChargingStationsAvailabilityParams, URL, ChargingStationsAvailabilityResponseAPI, ChargingStationsAvailability | undefined>;

/**
 * Explicit vehicle model with manually specified properties.
 *
 * @remarks
 * Use this when you want to specify custom vehicle characteristics instead of
 * using a predefined model from the Vehicle Database.
 *
 * **When to Use:**
 * - Custom or modified vehicles
 * - Vehicles not in the database
 * - Testing different configurations
 * - Generic vehicle types
 *
 * @typeParam E - The engine type (combustion, electric, or undefined for generic)
 *
 * @example
 * ```typescript
 * // Generic vehicle with dimensions only
 * const customVan: ExplicitVehicleModel<undefined> = {
 *   dimensions: {
 *     lengthMeters: 5.5,
 *     heightMeters: 2.5,
 *     weightKG: 3500
 *   }
 * };
 *
 * // Electric vehicle with consumption model
 * const customEV: ExplicitVehicleModel<'electric'> = {
 *   dimensions: {
 *     weightKG: 2000
 *   },
 *   engine: {
 *     consumption: {
 *       charging: {
 *         maxChargeKWH: 75,
 *         chargingCurve: [...]
 *       }
 *     }
 *   }
 * };
 * ```
 *
 * @group Vehicle
 */
declare type ExplicitVehicleModel<E extends VehicleEngineType> = {
    /**
     * Physical dimensions of the vehicle.
     *
     * @remarks
     * Specify sizes and weights to enable restriction checking.
     */
    dimensions?: VehicleDimensions;
    /**
     * Engine model with consumption characteristics.
     *
     * @remarks
     * Required for accurate fuel/energy consumption calculations and
     * EV routing with charging stops.
     */
    engine?: VehicleEngineModel<E>;
};

/**
 * Extended route representation options.
 *
 * Controls which additional progress information is included at route polyline points.
 *
 * @remarks
 * - `distance`: Cumulative distance from start to each point
 * - `travelTime`: Cumulative travel time from start to each point
 *
 * @example
 * ```typescript
 * // Include both distance and time progress
 * const extended: ExtendedRouteRepresentation[] = ['distance', 'travelTime'];
 * ```
 *
 * @default ['distance', 'travelTime']
 *
 * @group Routing
 */
export declare type ExtendedRouteRepresentation = 'distance' | 'travelTime';

/**
 * Hybrid HTTP fetch input, supporting different HTTP methods such as GET and POST.
 * * GET method comes with a URL.
 * * POST method comes with a URL and optional POST data.
 * @ignore
 */
export declare type FetchInput<PostData = void> = {
    method: 'GET';
    url: URL;
} | ({
    method: 'POST';
} & PostObject<PostData>);

/**
 * Additional properties for fuzzy search feature collection.
 *
 * Extends the base search summary with detected query intents that provide
 * insight into how the search engine interpreted the user's query.
 *
 * @group Fuzzy Search
 */
declare type FuzzySearchFeatureCollectionProps = SearchSummary & {
    /**
     * Array of detected query intents.
     *
     * Indicates how the search engine interpreted the query
     * (e.g., as coordinates, nearby search, what3words, or bookmark).
     */
    queryIntent: QueryIntent[];
};

/**
 * Parameters for fuzzy search queries.
 *
 * Fuzzy search finds places and addresses using partial or misspelled text queries.
 * It's designed to handle typos, abbreviations, and incomplete input gracefully.
 *
 * @remarks
 * **Key Features:**
 * - Tolerates typos and spelling mistakes
 * - Handles partial queries and abbreviations
 * - Searches both addresses and POIs
 * - Configurable fuzziness levels for precision control
 * - Ranked results by relevance
 *
 * **Use Cases:**
 * - Search box implementations
 * - User-entered free-form text searches
 * - Recovery from autocomplete failures
 * - Broad exploratory searches
 *
 * @example
 * ```typescript
 * // Basic fuzzy search
 * const params: FuzzySearchParams = {
 *   key: 'your-api-key',
 *   query: 'pizz',  // Will find "pizza" restaurants
 *   at: [4.9041, 52.3676]
 * };
 *
 * // Fuzzy search with custom fuzziness
 * const customParams: FuzzySearchParams = {
 *   key: 'your-api-key',
 *   query: 'restaurnt',  // Misspelled "restaurant"
 *   minFuzzyLevel: 1,
 *   maxFuzzyLevel: 3,
 *   limit: 10
 * };
 * ```
 *
 * @group Search
 */
export declare type FuzzySearchParams = CommonSearchParams<URL, FuzzySearchResponseAPI> & CommonGeocodeAndFuzzySearchParams & {
    /**
     * Minimum fuzziness level to be used.
     *
     * Controls how tolerant the search is to character differences.
     * Lower values require closer matches to the query text.
     *
     * @remarks
     * Fuzziness levels correspond to Levenshtein edit distance:
     * - Level 1: Allows 1 character difference
     * - Level 2: Allows 2 character differences
     * - Level 3: Allows 3 character differences
     * - Level 4: Allows 4 character differences
     *
     * Higher minimum levels make the search more lenient but may return
     * less relevant results.
     *
     * @default 1
     * @minimum 1
     * @maximum 4
     *
     * @example
     * ```typescript
     * minFuzzyLevel: 2  // Require at least moderate similarity
     * ```
     */
    minFuzzyLevel?: number;
    /**
     * Maximum fuzziness level to be used.
     *
     * Controls the upper limit of tolerance for character differences.
     * Higher values allow more variations but may include irrelevant results.
     *
     * @remarks
     * The search will try increasingly fuzzy matching up to this level
     * if no results are found at lower levels.
     *
     * @default 2
     * @minimum 1
     * @maximum 4
     *
     * @example
     * ```typescript
     * // Allow very fuzzy matching
     * maxFuzzyLevel: 4
     *
     * // Strict matching only
     * maxFuzzyLevel: 1
     * ```
     */
    maxFuzzyLevel?: number;
};

/**
 * Response from the fuzzy search service.
 *
 * Collection of places matching the search query, with additional metadata
 * about detected query intents (coordinates, nearby searches, what3words, bookmarks).
 *
 * @group Fuzzy Search
 */
export declare type FuzzySearchResponse = Places<SearchPlaceProps, FuzzySearchFeatureCollectionProps>;

/**
 * @ignore
 */
export declare type FuzzySearchResponseAPI = {
    /**
     * Summary information about the search that was performed.
     */
    summary: SummaryAPI & {
        queryIntent: QueryIntentAPI[];
    };
    /**
     * The result list, sorted in descending order by score.
     */
    results: FuzzySearchResultAPI[];
};

/**
 * @ignore
 */
export declare type FuzzySearchResultAPI = CommonSearchPlaceResultAPI;

/**
 * Fuzzy search service template type.
 * @ignore
 */
declare type FuzzySearchTemplate = ServiceTemplate<FuzzySearchParams, URL, FuzzySearchResponseAPI, FuzzySearchResponse>;

/**
 * Generic vehicle parameters without specific engine type.
 *
 * @remarks
 * Use for vehicles where engine type doesn't matter for routing,
 * or when you want to specify only basic restrictions.
 *
 * @example
 * ```typescript
 * const params: GenericVehicleParams = {
 *   model: {
 *     dimensions: {
 *       heightMeters: 2.5,
 *       weightKG: 3500
 *     }
 *   }
 * };
 * ```
 *
 * @group Vehicle
 */
export declare type GenericVehicleParams = {
    /**
     * Model (static properties) of the vehicle with generic/unspecified engine type.
     *
     * @remarks
     * Includes dimensions and other characteristics that don't change during travel.
     */
    model?: VehicleModel;
    /**
     * State of the vehicle with generic/unspecified engine type.
     *
     * @remarks
     * Includes current heading and other properties that vary during travel.
     */
    state?: VehicleState;
    /**
     * Generic vehicle preferences for unspecified engine type.
     *
     * @remarks
     * Currently no generic preferences exist; this is for future extensibility.
     */
    preferences?: VehiclePreferences;
};

/**
 * Generic vehicle state properties applicable to all vehicle types.
 *
 * @remarks
 * Contains state information that doesn't depend on the engine type.
 *
 * @example
 * ```typescript
 * const state: GenericVehicleState = {
 *   heading: 45  // Heading northeast
 * };
 * ```
 *
 * @group Vehicle
 */
export declare type GenericVehicleState = {
    /**
     * The current heading at the starting point, in degrees starting at true North and continuing in a clockwise direction.
     *
     * @remarks
     * **Bearing Reference:**
     * - North is 0 degrees
     * - East is 90 degrees
     * - South is 180 degrees
     * - West is 270 degrees
     *
     * Used to improve initial route calculation by considering the vehicle's
     * current direction of travel.
     *
     * Allowed values: 0-359
     *
     * @example
     * ```typescript
     * heading: 0    // Facing north
     * heading: 90   // Facing east
     * heading: 180  // Facing south
     * heading: 270  // Facing west
     * heading: 45   // Facing northeast
     * ```
     */
    heading?: number;
};

/**
 * Convert addresses into geographic coordinates (geocoding).
 *
 * The Geocode service translates addresses and place names into geographic coordinates,
 * enabling you to position markers on maps, calculate routes, or perform spatial analysis.
 *
 * @remarks
 * This service is optimized for address lookup and does not return POIs (Points of Interest).
 * For POI search, use the {@link search} function instead.
 *
 * Features:
 * - Highly tolerant of typos and incomplete addresses
 * - Handles various address formats and components
 * - Supports street addresses, intersections, and cross streets
 * - Works with higher-level geographies (cities, counties, states, countries)
 * - Returns structured address components
 *
 * @param params - Geocoding parameters including the address query
 * @param customTemplate - Advanced customization for request/response handling
 *
 * @returns Promise resolving to geocoded location results
 *
 * @example
 * ```typescript
 * // Geocode a complete address
 * const result = await geocode({
 *   key: 'your-api-key',
 *   query: '1600 Pennsylvania Avenue NW, Washington, DC'
 * });
 *
 * // Geocode with partial address
 * const partialResult = await geocode({
 *   key: 'your-api-key',
 *   query: 'Amsterdam, Netherlands'
 * });
 *
 * // Geocode with bias towards specific location
 * const biasedResult = await geocode({
 *   key: 'your-api-key',
 *   query: 'Main Street',
 *   at: [4.9041, 52.3676],  // Bias toward Amsterdam
 *   limit: 5
 * });
 *
 * // Geocode an intersection
 * const intersection = await geocode({
 *   key: 'your-api-key',
 *   query: '5th Avenue & 42nd Street, New York'
 * });
 * ```
 *
 * @see [Geocode API Documentation](https://docs.tomtom.com/search-api/documentation/geocoding-service/geocode)
 * @see [Places Quickstart Guide](https://docs.tomtom.com/maps-sdk-js/guides/services/places/quickstart)
 * @see [Geocoding Guide](https://docs.tomtom.com/maps-sdk-js/guides/services/places/geocoding)
 *
 * @group Geocoding
 */
export declare const geocode: (params: GeocodingParams, customTemplate?: Partial<GeocodingTemplate>) => Promise<GeocodingResponse>;

/**
 *
 * @param query
 * @group Geocoding
 */
export declare const geocodeOne: (query: string) => Promise<Place_3<GeocodingProps>>;

declare type GeocodingIndexTypesAbbreviation = Exclude<SearchIndexType, 'POI'>;

/**
 * Parameters for geocoding addresses into geographic coordinates.
 *
 * Geocoding converts human-readable addresses into latitude/longitude coordinates,
 * enabling you to place markers on maps or perform spatial operations.
 *
 * @remarks
 * This service is optimized for address lookups and does not return POIs.
 * For POI search, use the search service instead.
 *
 * **Features:**
 * - Tolerant of typos and incomplete addresses
 * - Handles various address formats
 * - Supports street addresses, intersections, cross streets
 * - Works with geographies (cities, counties, states, countries)
 * - Returns structured address components
 *
 * @example
 * ```typescript
 * // Geocode a complete address
 * const params: GeocodingParams = {
 *   key: 'your-api-key',
 *   query: '1600 Pennsylvania Avenue NW, Washington, DC'
 * };
 *
 * // Geocode with bias toward a location
 * const biasedParams: GeocodingParams = {
 *   key: 'your-api-key',
 *   query: 'Main Street',
 *   at: [4.9041, 52.3676],  // Bias toward Amsterdam
 *   limit: 5
 * };
 * ```
 *
 * @group Geocoding
 */
export declare type GeocodingParams = Omit<CommonPlacesParams<URL, GeocodingResponseAPI> & CommonGeocodeAndFuzzySearchParams, 'extendedPostalCodesFor'> & {
    /**
     * Indexes for which extended postal codes should be included in the results.
     *
     * @remarks
     * Extended postal codes provide additional postal code detail for addresses.
     * By default, they are included for all indexes except geographic areas (Geo).
     *
     * **Available index types:**
     * - `PAD`: Point Address
     * - `Addr`: Address Range
     * - `Str`: Street
     * - `Xstr`: Cross Street
     * - `Geo`: Geography
     *
     * Geographic areas (Geo) can have very long postal code lists, so they must
     * be explicitly requested when needed.
     *
     * @default All indexes except Geo
     *
     * @example
     * ```typescript
     * // Include extended postal codes for addresses only
     * extendedPostalCodesFor: ['PAD', 'Addr']
     *
     * // Include for all indexes including geographies
     * extendedPostalCodesFor: ['PAD', 'Addr', 'Str', 'Xstr', 'Geo']
     * ```
     */
    extendedPostalCodesFor?: GeocodingIndexTypesAbbreviation[];
};

/**
 * Place type for geocoding results.
 *
 * Excludes POI from the standard PlaceType union, as geocoding specifically
 * handles administrative and address-level entities rather than points of interest.
 *
 * @group Geocoding
 */
declare type GeocodingPlaceType = Exclude<PlaceType, 'POI'>;

/**
 * Properties specific to geocoding search results.
 *
 * Extends search place properties with geocoding-specific information,
 * including match confidence scoring to indicate how well the result matches
 * the input query. The info property is excluded as it's not used in geocoding responses.
 *
 * @group Geocoding
 */
export declare type GeocodingProps = Omit<SearchPlaceProps, 'info'> & {
    /**
     * The type of place (Address, Street, Geography, etc).
     *
     * POI type is excluded as geocoding focuses on administrative and address entities.
     */
    type: GeocodingPlaceType;
    /**
     * The confidence of the result's textual match with the query.
     *
     * Indicates how well the returned result matches the input query text.
     * Higher scores represent better textual matches.
     */
    matchConfidence: {
        score: number;
    };
};

/**
 * Response from the geocoding service.
 *
 * Collection of places matching the geocoding query, each with address information
 * and match confidence scoring.
 *
 * @group Geocoding
 */
export declare type GeocodingResponse = Places<GeocodingProps>;

/**
 * @ignore
 */
declare type GeocodingResponseAPI = {
    /**
     * Summary information about the search that was performed.
     */
    summary: SummaryAPI;
    /**
     * The result list, sorted in descending order by score.
     */
    results: GeocodingResultAPI[];
};

/**
 * @ignore
 */
declare type GeocodingResultAPI = Omit<GeocodingProps, 'distance' | 'position' | 'boundingBox' | 'addressRanges' | 'geographyType' | 'entryPoints'> & {
    id: string;
    position: LatLonAPI;
    dist?: number;
    boundingBox?: BoundingBoxAPI;
    viewport?: ViewportAPI;
    entityType?: string;
    entryPoints?: EntryPointAPI[];
    addressRanges?: AddressRangesAPI;
};

/**
 * Geocoding service template type.
 * @ignore
 */
declare type GeocodingTemplate = ServiceTemplate<GeocodingParams, URL, GeocodingResponseAPI, GeocodingResponse>;

/**
 * Geometry IDs as strings.
 *
 * @remarks
 * Geometry IDs are obtained from previous search results or place data that
 * includes geometry data source references.
 *
 * @example
 * ```typescript
 * const ids: GeometriesInput = ['g1234567890', 'g0987654321'];
 * ```
 *
 * @group Geometry
 */
export declare type GeometriesInput = string[];

/**
 * @ignore
 */
export declare type GeometryAPI = PolygonAPI | CircleAPI;

/**
 * Retrieve polygon geometries representing geographic area boundaries.
 *
 * The Geometry Data service returns coordinate sets that define the outlines of
 * geographic areas such as cities, countries, administrative regions, or POI footprints.
 * These polygons enable visualization of area boundaries, spatial analysis, and
 * geofencing applications.
 *
 * @remarks
 * Key features:
 * - **Batch requests**: Fetch up to 20 geometries in a single call
 * - **Multiple scales**: From countries down to building footprints
 * - **Place integration**: Can merge with place data for enriched results
 * - **Standard GeoJSON**: Returns standard Polygon/MultiPolygon features
 *
 * Common use cases:
 * - Display city or country boundaries on maps
 * - Show POI building footprints
 * - Create geofences for spatial queries
 * - Visualize administrative divisions
 * - Calculate areas and spatial relationships
 *
 * @param params - Geometry parameters with IDs or places to fetch boundaries for
 * @param customTemplate - Advanced customization for request/response handling
 *
 * @returns Promise resolving to polygon features representing area boundaries
 *
 * @example
 * ```typescript
 * // Fetch geometry by ID
 * const cityBoundary = await geometryData({
 *   key: 'your-api-key',
 *   geometries: ['geometry-id-123']
 * });
 *
 * // Fetch multiple geometries at once
 * const boundaries = await geometryData({
 *   key: 'your-api-key',
 *   geometries: ['country-id-1', 'city-id-2', 'poi-id-3']
 * });
 *
 * // Fetch and merge with place data
 * const searchResults = await search({ query: 'Amsterdam' });
 * const withBoundaries = await geometryData({
 *   key: 'your-api-key',
 *   geometries: searchResults  // Places with geometry IDs
 * });
 * // Result includes both place properties and polygon boundaries
 * ```
 *
 * @see [Geometry Data API Documentation](https://docs.tomtom.com/search-api/documentation/additional-data-service/additional-data)
 * @see [Places Quickstart Guide](https://docs.tomtom.com/maps-sdk-js/guides/services/places/quickstart)
 * @see [Geometry Data Guide](https://docs.tomtom.com/maps-sdk-js/guides/services/places/geometry-data)
 *
 * @group Geometry
 */
export declare function geometryData(params: GeometryDataParams, customTemplate?: Partial<GeometryDataTemplate>): Promise<PolygonFeatures>;

export declare function geometryData(params: GeometryPlaceParams, customTemplate?: Partial<GeometryDataTemplate>): Promise<PolygonFeatures<CommonPlaceProps>>;

/**
 * Parameters for fetching geometry data by IDs.
 *
 * @remarks
 * Use this when you have geometry IDs from previous API calls and want to
 * fetch the actual polygon/multipolygon coordinates.
 *
 * @example
 * ```typescript
 * // Fetch geometries by ID
 * const params: GeometryDataParams = {
 *   key: 'your-api-key',
 *   geometries: ['g1234567890', 'g0987654321'],
 *   zoom: 12
 * };
 * ```
 *
 * @group Geometry
 */
export declare type GeometryDataParams = CommonServiceParamsWithZoom & {
    /**
     * Array of geometry IDs to fetch.
     *
     * @remarks
     * **Constraints:**
     * - Minimum: 1 geometry ID
     * - Maximum: 20 geometry IDs per request
     *
     * IDs are obtained from place data sources, typically from search results
     * that include `dataSources.geometry.id`.
     *
     * @example
     * ```typescript
     * // Single geometry
     * geometries: ['g1234567890']
     *
     * // Multiple geometries
     * geometries: ['g1234567890', 'g0987654321', 'g1122334455']
     * ```
     */
    geometries: GeometriesInput;
};

/**
 * @ignore
 */
export declare type GeometryDataResponseAPI = {
    additionalData: AdditionalDataAPI[];
};

/**
 * @ignore
 */
declare type GeometryDataTemplate = ServiceTemplate<GeometryParams, URL, GeometryDataResponseAPI, PolygonFeatures>;

/**
 * Union type for all geometry data parameter formats.
 *
 * Accepts either geometry IDs directly or places containing geometry IDs.
 *
 * @remarks
 * **Choose the right type:**
 * - {@link GeometryDataParams}: When you have geometry IDs as strings
 * - {@link GeometryPlaceParams}: When you have place objects from search
 *
 * @example
 * ```typescript
 * // Using IDs
 * const idParams: GeometryParams = {
 *   key: 'your-api-key',
 *   geometries: ['g1234567890']
 * };
 *
 * // Using places
 * const placeParams: GeometryParams = {
 *   key: 'your-api-key',
 *   geometries: searchResults
 * };
 * ```
 *
 * @group Geometry
 */
export declare type GeometryParams = GeometryDataParams | GeometryPlaceParams;

/**
 * Parameters for fetching geometry data from places.
 *
 * @remarks
 * Use this when you have place objects (from search results) and want to
 * fetch their boundaries. The function will automatically extract geometry IDs
 * from the places.
 *
 * @example
 * ```typescript
 * // From search results
 * const searchResults = await search({ query: 'Amsterdam' });
 * const params: GeometryPlaceParams = {
 *   key: 'your-api-key',
 *   geometries: searchResults,
 *   zoom: 10
 * };
 *
 * // From individual places
 * const params: GeometryPlaceParams = {
 *   key: 'your-api-key',
 *   geometries: [place1, place2],
 *   zoom: 12
 * };
 * ```
 *
 * @group Geometry
 */
export declare type GeometryPlaceParams = CommonServiceParamsWithZoom & {
    /**
     * Places or place array containing geometry IDs.
     *
     * @remarks
     * The places must have geometry data sources with IDs. Places without
     * geometry IDs will be skipped.
     *
     * **Supported Formats:**
     * - Single Place object
     * - Array of Place objects
     * - Places FeatureCollection
     *
     * @example
     * ```typescript
     * // FeatureCollection from search
     * geometries: searchResults
     *
     * // Array of places
     * geometries: [place1, place2, place3]
     * ```
     */
    geometries: Place_2[] | Places;
};

/**
 * Properties attached to the geometry search feature collection.
 *
 * Contains summary information about the search operation and its results.
 *
 * @remarks
 * Provides metadata about:
 * - Number of results found
 * - Query that was executed
 * - Performance metrics
 * - Fuzzy matching level applied
 *
 * @example
 * ```typescript
 * const collectionProps: GeometrySearchFeatureCollectionProps = {
 *   numResults: 25,
 *   query: 'coffee shop',
 *   queryTime: 123,
 *   fuzzyLevel: 1
 * };
 * ```
 *
 * @group Geometry Search
 */
export declare type GeometrySearchFeatureCollectionProps = SearchSummary;

/**
 * Parameters for searching places within specific geographic areas (geometry search).
 *
 * Geometry search finds places that fall within or near the boundaries of one or more
 * geometric shapes (polygons, circles, or multipolygons). This enables area-based searches
 * like "restaurants in this neighborhood" or "hotels within these city boundaries".
 *
 * @remarks
 * **Key Features:**
 * - Search within multiple geometries simultaneously
 * - Supports polygons, multipolygons, and circles
 * - Can use geometries from previous search results
 * - Combines with text queries for filtered results
 *
 * **Use Cases:**
 * - Find POIs within administrative boundaries
 * - Search within custom drawn areas on map
 * - Filter results to specific neighborhoods or regions
 * - Proximity searches using circles
 *
 * @example
 * ```typescript
 * // Search within a circular area
 * const results = await search({
 *   key: 'your-api-key',
 *   query: 'restaurant',
 *   geometries: [{
 *     type: 'Circle',
 *     coordinates: [4.9041, 52.3676],
 *     radius: 1000  // meters
 *   }]
 * });
 * ```
 *
 * @example
 * ```typescript
 * // Search within a polygon
 * const results = await search({
 *   key: 'your-api-key',
 *   query: 'parking',
 *   geometries: [{
 *     type: 'Polygon',
 *     coordinates: [[
 *       [4.88, 52.36],
 *       [4.90, 52.36],
 *       [4.90, 52.38],
 *       [4.88, 52.38],
 *       [4.88, 52.36]
 *     ]]
 *   }]
 * });
 * ```
 *
 * @group Search
 */
export declare type GeometrySearchParams = CommonSearchParams<GeometrySearchRequestAPI, GeometrySearchResponseAPI> & {
    /**
     * List of geometries to search within.
     *
     * Can be a mix of polygons, multipolygons, circles, or geometry feature collections
     * from previous search results. Places that fall within or near these geometries
     * will be returned.
     *
     * @remarks
     * Also referred to as "geometryList" in API documentation.
     *
     * **Supported Types:**
     * - {@link Circle} - Circular search area with radius
     * - `Polygon` - Custom polygon boundary (GeoJSON)
     * - `MultiPolygon` - Multiple polygon areas (GeoJSON)
     * - `PolygonFeatures` - Feature collection with polygon geometries
     *
     * @example
     * ```typescript
     * // Multiple geometries
     * geometries: [
     *   { type: 'Circle', coordinates: [4.9, 52.3], radius: 500 },
     *   { type: 'Polygon', coordinates: [[...]] }
     * ]
     * ```
     */
    geometries: SearchGeometryInput[];
};

/**
 * @ignore
 */
export declare type GeometrySearchPayloadAPI = {
    geometryList: GeometryAPI[];
};

/**
 * Geometry search request type.
 * @ignore
 */
export declare type GeometrySearchRequestAPI = PostObject<GeometrySearchPayloadAPI>;

/**
 * Response from a geometry search query.
 *
 * Contains places found within or along a specified geometry (polygon or circle),
 * along with summary information about the search results.
 *
 * @remarks
 * **Use Cases:**
 * - Find POIs within a delivery zone
 * - Search along a route corridor
 * - Discover places within a custom boundary
 * - Find facilities within a service area
 * - Search within administrative boundaries
 *
 * **Supported Geometries:**
 * - Polygon: Search within a multi-sided boundary
 * - Circle: Search within a radius around a point
 *
 * @example
 * ```typescript
 * const response: GeometrySearchResponse = {
 *   type: 'FeatureCollection',
 *   features: [
 *     {
 *       type: 'Feature',
 *       geometry: { type: 'Point', coordinates: [4.9, 52.3] },
 *       properties: {
 *         type: 'POI',
 *         poi: { name: 'Restaurant', categories: ['RESTAURANT'] },
 *         address: { streetName: 'Main Street' },
 *         score: 0.95
 *       }
 *     }
 *   ],
 *   summary: {
 *     numResults: 1,
 *     query: 'restaurant',
 *     queryTime: 45
 *   }
 * };
 * ```
 *
 * @group Geometry Search
 */
export declare type GeometrySearchResponse = Places<SearchPlaceProps, GeometrySearchFeatureCollectionProps>;

/**
 * @ignore
 */
export declare type GeometrySearchResponseAPI = {
    /**
     * Summary information about the search that was performed.
     */
    summary: SummaryAPI;
    /**
     * The result list, sorted in descending order by score.
     */
    results: GeometrySearchResultAPI[];
};

/**
 * @ignore
 */
export declare type GeometrySearchResultAPI = CommonSearchPlaceResultAPI;

/**
 * Geometry search service template type.
 */
declare type GeometrySearchTemplate = ServiceTemplate<GeometrySearchParams, GeometrySearchRequestAPI, GeometrySearchResponseAPI, GeometrySearchResponse>;

/**
 * @ignore
 */
declare type GuidanceAPI = Omit<Guidance, 'instructions'> & {
    instructions: InstructionAPI[];
};

/**
 * Configuration for turn-by-turn guidance instructions.
 *
 * Specifies the format and detail level for navigation guidance.
 *
 * @example
 * ```typescript
 * // Request coded guidance with phonetics
 * const guidance: GuidanceParams = {
 *   type: 'coded',
 *   version: 2,
 *   phonetics: 'IPA',
 *   roadShieldReferences: 'all'
 * };
 * ```
 *
 * @group Routing
 */
export declare type GuidanceParams = {
    /**
     * Guidance instruction format type.
     *
     * Currently only 'coded' format is supported.
     */
    type: 'coded';
    /**
     * Guidance instruction version.
     *
     * @default 2
     */
    version?: 2;
    /**
     * Phonetic transcription format for street names.
     *
     * @remarks
     * - `LHP`: Language-specific phonetic representation
     * - `IPA`: International Phonetic Alphabet
     *
     * @default 'IPA'
     */
    phonetics?: 'LHP' | 'IPA';
    /**
     * Include road shield references for displaying road signs.
     *
     * When set to 'all', includes references to road shield images
     * that can be fetched from the TomTom Road Shield API.
     */
    roadShieldReferences?: 'all';
};

/**
 * Route section type that can be requested in routing parameters.
 *
 * @remarks
 * Note: Some section types (like "leg") are automatically included regardless of this parameter.
 *
 * @group Routing
 */
export declare type InputSectionType = (typeof inputSectionTypes)[number];

/**
 * Array of section types to include in the route response.
 *
 * Sections divide the route into portions with specific characteristics, helping you
 * display additional context like toll roads, ferry crossings, or traffic incidents.
 *
 * @remarks
 * Available section types:
 * - `carTrain`: Sections requiring car train transport
 * - `ferry`: Water crossings requiring ferry
 * - `tunnel`: Underground tunnel sections
 * - `motorway`: Highway/freeway sections
 * - `pedestrian`: Pedestrian-only sections
 * - `toll`: Sections requiring toll payment
 * - `tollVignette`: Sections requiring toll vignette
 * - `country`: Different countries traversed
 * - `traffic`: Sections with traffic incidents
 * - `vehicleRestricted`: Sections with vehicle restrictions
 * - `carpool`: HOV/carpool lane sections
 * - `urban`: Urban area sections
 * - `unpaved`: Unpaved road sections
 * - `lowEmissionZone`: Low emission zones
 * - `speedLimit`: Speed limit changes
 * - `roadShields`: Road shield information
 *
 * @example
 * ```typescript
 * // Request toll, ferry, and traffic sections
 * const sectionTypes: InputSectionTypes = ['toll', 'ferry', 'traffic'];
 *
 * // Request all available sections
 * const sectionTypes: InputSectionTypes = inputSectionTypes;
 *
 * // Request no optional sections (leg sections still included)
 * const sectionTypes: InputSectionTypes = [];
 * ```
 *
 * @default All available section types
 *
 * @group Routing
 */
export declare type InputSectionTypes = InputSectionType[];

/**
 * @ignore
 */
declare type InstructionAPI = Omit<Instruction, 'maneuverPoint' | 'routePath' | 'pathPointIndex'> & {
    maneuverPoint: LatitudeLongitudePointAPI;
    routePath: RoutePathPointAPI[];
};

/**
 * @ignore
 * @see {@link https://docs.tomtom.com/routing-api/documentation/routing/common-routing-parameters point}
 */
declare type LatitudeLongitudePointAPI = {
    latitude: number;
    longitude: number;
};

/**
 * @ignore
 */
declare type LatLonAPI = {
    /**
     * Latitude. min/max: -90 to +90
     */
    lat: number;
    /**
     * Longitude. min/max: -180 to +180
     */
    lon: number;
};

/**
 * @ignore
 */
declare type LegAPI = {
    points: LatitudeLongitudePointAPI[];
    summary: SummaryAPI_2;
};

/**
 * Basic low/normal/high intensity level option.
 *
 * Used for configuring route characteristics like hilliness or windingness.
 *
 * @remarks
 * - `low`: Minimal intensity
 * - `normal`: Moderate intensity
 * - `high`: Maximum intensity
 *
 * @group Routing
 */
export declare type LNH = 'low' | 'normal' | 'high';

/**
 * Known hazardous truck load types. Should be used for trucks carrying hazardous materials.
 *
 * Use these values for routing in the USA:
 * * USHazmatClass1: Explosives
 * * USHazmatClass2: Compressed gas
 * * USHazmatClass3: Flammable liquids
 * * USHazmatClass4: Flammable solids
 * * USHazmatClass5: Oxidizers
 * * USHazmatClass6: Poisons
 * * USHazmatClass7: Radioactive
 * * USHazmatClass8: Corrosives
 * * USHazmatClass9: Miscellaneous
 *
 * Use these values for routing in all other countries:
 * * otherHazmatExplosive: Explosives
 * * otherHazmatGeneral: Miscellaneous
 * * otherHazmatHarmfulToWater: Harmful to water
 */
declare type LoadType = (typeof loadTypes)[number];

/**
 * Known hazardous truck load types. Should be used for trucks carrying hazardous materials.
 */
declare const loadTypes: readonly ["USHazmatClass1", "USHazmatClass2", "USHazmatClass3", "USHazmatClass4", "USHazmatClass5", "USHazmatClass6", "USHazmatClass7", "USHazmatClass8", "USHazmatClass9", "otherHazmatExplosive", "otherHazmatGeneral", "otherHazmatHarmfulToWater"];

/**
 * Maximum number of alternative routes to calculate.
 *
 * Alternative routes provide different options for traveling between the same origin and destination.
 *
 * @remarks
 * - `0`: Only calculate the best route (default)
 * - `1-5`: Calculate best route plus up to N alternatives
 *
 * More alternatives increase computation time but provide more route options.
 *
 * @example
 * ```typescript
 * // Request up to 2 alternative routes
 * const maxAlternatives: MaxNumberOfAlternatives = 2;
 * ```
 *
 * @default 0
 *
 * @group Routing
 */
export declare type MaxNumberOfAlternatives = 0 | 1 | 2 | 3 | 4 | 5;

/**
 * @ignore
 */
declare type MomentAPI = {
    date: string;
    hour: number;
    minute: number;
};

/**
 * Intent indicating a proximity-based search.
 *
 * Detected when the query asks for entities near a location
 * (e.g., "hotel near Lyon" or "restaurants near me").
 *
 * @group Fuzzy Search
 */
export declare type NearbyIntent = {
    /**
     * Query type identifier.
     *
     * The query asks for entities in proximity to another entity.
     */
    type: 'NEARBY';
    /**
     * Details about the nearby search parameters.
     */
    details: NearbyIntentDetails;
};

/**
 * @ignore
 */
export declare type NearbyIntentAPI = {
    /**
     * the query asks for some entity in the proximity of another entity (e.g., "hotel near Lyon").
     */
    type: 'NEARBY';
    details: NearbyIntentDetailsAPI;
};

/**
 * Details for a nearby search query intent.
 *
 * Contains information about what the user is searching for and where,
 * extracted from proximity-based queries.
 *
 * @group Fuzzy Search
 */
export declare type NearbyIntentDetails = {
    /**
     * Position of the reference location in the nearby search.
     *
     * For example, for "restaurant near Berlin central station", this is
     * the position of Berlin Central Station. If position parameters were
     * specified in the request, the distance field will show the distance
     * between the geo bias and the returned results.
     */
    position: Position;
    /**
     * Normalized phrase for what the user is searching for.
     *
     * For example, for "restaurant near Berlin central station",
     * the query is "restaurant".
     */
    query: string;
    /**
     * Normalized phrase for the reference location.
     *
     * For example, for "restaurant near Berlin central station",
     * the text is "berlin central station".
     */
    text: string;
};

/**
 * @ignore
 */
export declare type NearbyIntentDetailsAPI = Omit<NearbyIntentDetails, 'position'> & {
    /**
     * Latitude of the place, near which the user searches for something.
     * For example, for the input restaurant near Berlin central station this is the position of "Berlin Central Station".
     * If lat and lon parameters are specified, the dist field will have the distance between the geoBias and the returned restaurants.
     */
    lat: number;
    /**
     * Longitude of the place, near which the user searches for something.
     */
    lon: number;
};

/**
 * @ignore
 */
declare type OpeningHoursAPI = Omit<OpeningHours, 'alwaysOpenThisPeriod' | 'timeRanges'> & {
    timeRanges: TimeRangeAPI[];
};

/**
 * @ignore
 * @param error
 * @param serviceName
 */
export declare const parseDefaultResponseError: ParseResponseError<DefaultAPIResponseErrorBody>;

export declare type ParsedFetchResponse<T> = Promise<{
    data: Promise<T>;
    status: number;
}>;

/**
 * Function type for parsing API error responses into SDK service errors.
 *
 * @typeParam T - The type of the error response body (defaults to {@link DefaultAPIResponseErrorBody})
 *
 * @param apiError - The API error response received from the server
 * @param serviceName - The name of the service that encountered the error
 * @returns A structured {@link SDKServiceError} object
 *
 * @group Shared
 */
export declare type ParseResponseError<T = DefaultAPIResponseErrorBody> = (apiError: APIErrorResponse<T>, serviceName: string) => SDKServiceError;

/**
 * Retrieve detailed information about a place using its unique identifier.
 *
 * The Place by ID service fetches comprehensive data for a specific place when you
 * have its ID from a previous search or from a place's dataSources. This is useful
 * for getting additional details or refreshing information about a known location.
 *
 * @remarks
 * Use cases:
 * - **Fetch POI details**: Get extended information like reviews, photos, amenities
 * - **Refresh place data**: Update information for a cached place
 * - **Deep linking**: Allow users to share/bookmark specific places
 * - **Related POI navigation**: Explore parent/child relationships
 *
 * The ID can be obtained from:
 * - Previous search results (place.id)
 * - POI details data source (place.properties.dataSources.poiDetails.id)
 * - Related POIs (place.properties.relatedPois[].id)
 * - Deep links or bookmarks
 *
 * @param params - Place by ID parameters with the place identifier
 * @param customTemplate - Advanced customization for request/response handling
 *
 * @returns Promise resolving to detailed place information
 *
 * @example
 * ```typescript
 * // Get place by ID from search result
 * const searchResult = await search({ query: 'Eiffel Tower' });
 * const placeId = searchResult.features[0].id;
 *
 * const placeDetails = await placeById({
 *   key: 'your-api-key',
 *   entityId: placeId
 * });
 *
 * // Get extended POI details
 * const place = searchResult.features[0];
 * const poiDetailsId = place.properties.dataSources?.poiDetails?.id;
 *
 * if (poiDetailsId) {
 *   const detailedPOI = await placeById({
 *     key: 'your-api-key',
 *     entityId: poiDetailsId
 *   });
 *   // May include additional photos, reviews, extended hours, etc.
 * }
 *
 * // Navigate to related POI
 * const relatedPOI = place.properties.relatedPois?.[0];
 * if (relatedPOI) {
 *   const parentPlace = await placeById({
 *     key: 'your-api-key',
 *     entityId: relatedPOI.id
 *   });
 *   console.log('Parent location:', parentPlace.properties.address);
 * }
 * ```
 *
 * @see [Place by ID API Documentation](https://docs.tomtom.com/search-api/documentation/place-by-id-service/place-by-id)
 * @see [Places Quickstart Guide](https://docs.tomtom.com/maps-sdk-js/guides/services/places/quickstart)
 *
 * @group Place
 */
export declare const placeById: (params: PlaceByIdParams, customTemplate?: Partial<PlaceByIdTemplate>) => Promise<PlaceByIdResponse>;

/**
 * Mandatory parameters for the Place by ID service.
 *
 * @group Place
 */
export declare type PlaceByIdMandatoryParams = {
    /**
     * The unique POI identifier.
     *
     * @remarks
     * This ID can be obtained from:
     * - Previous search results (place.id)
     * - POI details data source (place.properties.dataSources.poiDetails.id)
     * - Related POIs (place.properties.relatedPois[].id)
     *
     * @example
     * ```typescript
     * entityId: '528009002822995'
     * ```
     */
    entityId: string;
};

/**
 * Optional parameters for the Place by ID service.
 *
 * @group Place
 */
export declare type PlaceByIdOptionalParams = {
    /**
     * Enable comma-separated mapcodes list in the response.
     *
     * @remarks
     * Mapcodes are short location codes representing a specific location
     * to within a few meters. Can filter to show only selected mapcode types.
     *
     * **Mapcode Types:**
     * - `Local`: Short local codes for use within a territory
     * - `International`: Longer codes that work worldwide
     * - `Alternative`: Alternative codes for the same location
     *
     * @see [Mapcode Project](https://www.mapcode.com/)
     *
     * @example
     * ```typescript
     * mapcodes: ['Local', 'International']
     * ```
     */
    mapcodes?: MapcodeType[];
    /**
     * Geopolitical view context for disputed territories.
     *
     * @remarks
     * Determines how disputed territories are handled in the response.
     *
     * **Available Views:**
     * - `Unified`: International view (default)
     * - `AR`: Argentina
     * - `IN`: India
     * - `PK`: Pakistan
     * - `IL`: Israel
     * - `MA`: Morocco
     * - `RU`: Russia
     * - `TR`: Turkey
     * - `CN`: China
     *
     * @default 'Unified'
     *
     * @example
     * ```typescript
     * view: 'IN'  // Indian geopolitical view
     * ```
     */
    view?: View;
    /**
     * Include opening hours information in the response.
     *
     * @remarks
     * Provides operating hours for POIs (restaurants, stores, etc.).
     *
     * @example
     * ```typescript
     * openingHours: 'nextSevenDays'
     * ```
     */
    openingHours?: OpeningHoursMode;
    /**
     * Include timezone information in the response.
     *
     * @remarks
     * Returns the timezone of the place's location (e.g., "America/New_York").
     *
     * @example
     * ```typescript
     * timeZone: 'iana'
     * ```
     */
    timeZone?: TimeZoneRequest;
    /**
     * Include related Points of Interest in the response.
     *
     * @remarks
     * POIs can have parent/child relationships. For example, an airport terminal
     * is a child of the airport.
     *
     * **Relation Types:**
     * - `child`: Return POIs that are children of this place
     * - `parent`: Return POIs that are parents of this place
     * - `all`: Return both child and parent relations
     * - `off`: No related POIs (default)
     *
     * @default 'off'
     *
     * @example
     * ```typescript
     * relatedPois: 'child'  // Get terminals inside an airport
     * relatedPois: 'parent'  // Get the airport containing a terminal
     * relatedPois: 'all'  // Get all related POIs
     * ```
     */
    relatedPois?: RelatedPoisRequest;
};

/**
 * Parameters for the Place by ID service.
 *
 * Combines mandatory and optional parameters for fetching detailed information
 * about a specific place using its unique identifier.
 *
 * @remarks
 * Use this service to:
 * - Get detailed POI information
 * - Refresh cached place data
 * - Navigate between related POIs
 * - Fetch additional place properties not in search results
 *
 * @example
 * ```typescript
 * // Basic lookup
 * const params: PlaceByIdParams = {
 *   key: 'your-api-key',
 *   entityId: '528009002822995'
 * };
 *
 * // With additional information
 * const detailedParams: PlaceByIdParams = {
 *   key: 'your-api-key',
 *   entityId: '528009002822995',
 *   openingHours: 'nextSevenDays',
 *   mapcodes: ['Local'],
 *   relatedPois: 'child'
 * };
 * ```
 *
 * @group Place
 */
export declare type PlaceByIdParams = CommonServiceParams<URL, PlaceByIdResponseAPI> & PlaceByIdMandatoryParams & PlaceByIdOptionalParams;

/**
 * Response from the place by ID service.
 *
 * Returns detailed information for a specific place identified by its unique ID,
 * or undefined if the place is not found.
 *
 * @remarks
 * This service is typically used to fetch complete details for a place when you
 * already have its ID from a previous search or geocoding operation.
 *
 * @group Place By ID
 */
export declare type PlaceByIdResponse = Place_2<SearchPlaceProps> | undefined;

/**
 * @ignore
 */
export declare type PlaceByIdResponseAPI = {
    /**
     * Summary information about the search that was performed.
     */
    summary: SummaryAPI;
    /**
     * The result list, sorted in descending order by score.
     */
    results: PlaceByIdResultAPI[];
};

/**
 * @ignore
 */
export declare type PlaceByIdResultAPI = CommonSearchPlaceResultAPI;

/**
 * Place By Is template type.
 * @ignore
 */
declare type PlaceByIdTemplate = ServiceTemplate<PlaceByIdParams, URL, PlaceByIdResponseAPI, PlaceByIdResponse>;

/**
 * @ignore
 * place of interest api type.
 */
declare type POIAPI = {
    name: string;
    phone?: string;
    brands?: BrandAPI[];
    url?: string;
    categorySet?: CategoryAPI[];
    categories?: string[];
    openingHours?: OpeningHoursAPI;
    classifications?: Classification[];
    timeZone?: TimeZone;
};

/**
 * @ignore
 */
declare type PointWaypointAPI = {
    waypointSourceType: 'USER_DEFINED' | 'AUTO_GENERATED';
    supportingPointIndex: number;
};

/**
 * @ignore
 */
export declare type PolygonAPI = {
    type: 'POLYGON';
    vertices: string[];
};

/**
 * POST object with URL and optional payload.
 * @ignore
 */
export declare type PostObject<D> = {
    url: URL;
    data?: D;
};

/**
 * A predefined vehicle model which comes from TomTom's curated Vehicle Database.
 *
 * @remarks
 * The Vehicle Database contains real-world vehicle specifications including:
 * - Physical dimensions
 * - Engine characteristics
 * - Consumption profiles
 * - Performance data
 *
 * Using a predefined model ensures accurate routing based on actual vehicle capabilities.
 *
 * **Benefits:**
 * - No need to manually specify technical details
 * - Continuously updated database
 * - Real-world tested consumption models
 * - Accurate range predictions
 *
 * @example
 * ```typescript
 * // Use a specific vehicle model
 * const teslaModel: PredefinedVehicleModel = {
 *   variantId: 'tesla-model-3-long-range-2023'
 * };
 *
 * // Use a specific truck model
 * const truckModel: PredefinedVehicleModel = {
 *   variantId: 'volvo-fh16-750-2022'
 * };
 * ```
 *
 * @group Vehicle
 */
declare type PredefinedVehicleModel = {
    /**
     * The ID specifying the vehicle model with exact variant (if any).
     *
     * @remarks
     * Identifiers follow the pattern: `{make}-{model}-{variant}-{year}`
     *
     * Contact TomTom support to get available vehicle IDs from the database.
     *
     * @example
     * ```typescript
     * variantId: 'tesla-model-3-long-range-2023'
     * variantId: 'nissan-leaf-e-plus-2022'
     * variantId: 'mercedes-sprinter-316-2021'
     * ```
     */
    variantId: string;
};

/**
 * Union type for all possible query intents.
 *
 * Represents different ways the search engine can interpret a user's query,
 * helping applications provide more contextual results.
 *
 * @group Fuzzy Search
 */
export declare type QueryIntent = CoordinateIntent | NearbyIntent | W3WIntent | BookmarkIntent;

/**
 * @ignore
 */
export declare type QueryIntentAPI = CoordinateIntentAPI | NearbyIntentAPI | W3WIntent | BookmarkIntent;

/**
 * Budget constraint for reachable range calculation.
 *
 * Defines the limit (time, distance, or fuel/charge) for calculating
 * how far you can travel from a starting point.
 *
 * @remarks
 * **Use Cases:**
 * - Service area visualization (30-min delivery zone)
 * - EV range anxiety mitigation (show reachable area)
 * - Emergency response coverage (10-min response time)
 * - Delivery zone planning
 * - Store location analysis
 *
 * @example
 * ```typescript
 * // 30-minute travel time
 * const timeBudget: ReachableRangeBudget = {
 *   type: 'timeMinutes',
 *   value: 30
 * };
 *
 * // 50 km distance
 * const distanceBudget: ReachableRangeBudget = {
 *   type: 'distanceKM',
 *   value: 50
 * };
 *
 * // 50% battery remaining
 * const evBudget: ReachableRangeBudget = {
 *   type: 'remainingChargeCPT',
 *   value: 50
 * };
 *
 * // 20 liters of fuel
 * const fuelBudget: ReachableRangeBudget = {
 *   type: 'spentFuelLiters',
 *   value: 20
 * };
 * ```
 *
 * @group Reachable Range
 */
declare type ReachableRangeBudget = {
    /**
     * The type of budget, including units.
     *
     * @remarks
     * - `timeMinutes`: Minutes of travel time
     * - `distanceKM`: Kilometers of travel distance
     * - `remainingChargeCPT`: Battery percentage remaining
     * - `spentChargePCT`: Battery percentage consumed
     * - `spentFuelLiters`: Liters of fuel consumed
     */
    type: BudgetType;
    /**
     * The value of the budget based on the units mentioned in the type.
     *
     * @remarks
     * **Typical Values:**
     * - Time: 5-60 minutes
     * - Distance: 5-100 km
     * - Charge: 10-100 percentage
     * - Fuel: 5-50 liters
     *
     * @example
     * ```typescript
     * value: 30    // 30 minutes/km/percent/liters depending on type
     * value: 15.5  // Decimal values supported
     * ```
     */
    value: number;
};

/**
 * Parameters specific to reachable range calculation.
 *
 * @remarks
 * These parameters are combined with common routing parameters to calculate
 * the reachable area from a starting point.
 *
 * @group Reachable Range
 */
declare type ReachableRangeOwnParams = {
    /**
     * Location from which the range calculation should start.
     *
     * @remarks
     * The center point from which reachability is calculated. Can be:
     * - An object with `lon` and `lat` properties
     * - An array `[longitude, latitude]`
     *
     * @example
     * ```typescript
     * // Object format
     * origin: { lon: 4.9, lat: 52.3 }
     *
     * // Array format
     * origin: [4.9, 52.3]
     * ```
     */
    origin: HasLngLat;
    /**
     * The budget for the reachable range calculation.
     *
     * @remarks
     * Consists of a type indicating whether it's about time, distance, or
     * fuel/charge and the units, plus its value.
     *
     * Determines the extent of the reachable area polygon.
     */
    budget: ReachableRangeBudget;
    /**
     * Maximum ferry length in meters to consider.
     *
     * @remarks
     * Ferries longer than this value will be avoided in the calculation.
     * Useful for excluding long ferry routes that might extend the range
     * unrealistically.
     *
     * @example
     * ```typescript
     * maxFerryLengthMeters: 5000  // Avoid ferries longer than 5 km
     * ```
     */
    maxFerryLengthMeters?: number;
    /**
     * Specifies when to depart.
     *
     * @remarks
     * If past dates are supplied or dates that are impossible to achieve,
     * it will default to departing now.
     *
     * **Traffic Impact:**
     * - Future departure times use predictive traffic
     * - Current time uses live traffic
     * - Historic times use historical patterns
     *
     * @default Depart now
     *
     * @example
     * ```typescript
     * when: { departAt: new Date('2025-10-20T08:00:00Z') }
     * when: { departAt: 'now' }
     * ```
     */
    when?: DepartArriveParams<'departAt'>;
};

/**
 * Complete parameters for calculating a reachable range.
 *
 * Combines common service parameters, routing parameters, and reachable range
 * specific options to compute an isochrone or isodistance polygon.
 *
 * @remarks
 * **What it Returns:**
 * A polygon representing the area reachable from the origin within the
 * specified budget (time, distance, or fuel/charge).
 *
 * **Use Cases:**
 * - Delivery zone visualization
 * - Service area mapping
 * - Emergency response coverage
 * - EV range display
 * - Store catchment areas
 * - Real estate search (30-min commute)
 *
 * **Traffic Consideration:**
 * Results vary based on departure time and traffic conditions. Use
 * appropriate `when` values for accurate predictions.
 *
 * @example
 * ```typescript
 * // 30-minute driving range
 * const params: ReachableRangeParams = {
 *   key: 'your-api-key',
 *   origin: [4.9, 52.3],
 *   budget: {
 *     type: 'timeMinutes',
 *     value: 30
 *   },
 *   routeType: 'fastest',
 *   traffic: 'live',
 *   when: { departAt: 'now' }
 * };
 *
 * // 50 km distance range
 * const distanceParams: ReachableRangeParams = {
 *   key: 'your-api-key',
 *   origin: [4.9, 52.3],
 *   budget: {
 *     type: 'distanceKM',
 *     value: 50
 *   }
 * };
 *
 * // EV range with 50% battery
 * const evParams: ReachableRangeParams = {
 *   key: 'your-api-key',
 *   origin: [4.9, 52.3],
 *   budget: {
 *     type: 'remainingChargeCPT',
 *     value: 50
 *   },
 *   vehicle: {
 *     engineType: 'electric',
 *     model: {
 *       engine: {
 *         consumption: {
 *           charging: { maxChargeKWH: 100 }
 *         }
 *       }
 *     },
 *     state: {
 *       currentChargePCT: 80
 *     }
 *   }
 * };
 *
 * // Avoid toll roads
 * const noTollParams: ReachableRangeParams = {
 *   key: 'your-api-key',
 *   origin: [4.9, 52.3],
 *   budget: {
 *     type: 'timeMinutes',
 *     value: 45
 *   },
 *   avoid: ['tollRoads']
 * };
 * ```
 *
 * @group Reachable Range
 */
declare type ReachableRangeParams = CommonServiceParams<URL, ReachableRangeResponseAPI> & CommonRoutingParams & ReachableRangeOwnParams;

/**
 * @ignore
 */
declare type ReachableRangeResponseAPI = {
    reachableRange: {
        center: LatitudeLongitudePointAPI;
        boundary: LatitudeLongitudePointAPI[];
    };
};

declare type ReachableRangeTemplate = ServiceTemplate<ReachableRangeParams, URL, ReachableRangeResponseAPI, PolygonFeature<ReachableRangeParams>>;

/**
 * Related POI inclusion mode for search requests.
 *
 * Controls which related Points of Interest are included in search results
 * based on hierarchical relationships (parent/child).
 *
 * @remarks
 * **Relationship Modes:**
 * - `off`: No related POIs included (default)
 * - `child`: Include child POIs (e.g., terminals within an airport)
 * - `parent`: Include parent POIs (e.g., airport containing a terminal)
 * - `all`: Include both parent and child relationships
 *
 * **Example Relationships:**
 * - Airport (parent) ↔ Terminal (child)
 * - Shopping Mall (parent) ↔ Individual Store (child)
 * - University (parent) ↔ Department Building (child)
 *
 * @example
 * ```typescript
 * const mode: RelatedPoisRequest = 'child';  // Include child POIs
 * const mode2: RelatedPoisRequest = 'all';   // Include all related
 * ```
 *
 * @group Search
 */
export declare type RelatedPoisRequest = 'child' | 'parent' | 'all' | 'off';

/**
 * @ignore
 */
declare type ReportAPI = {
    effectiveSettings: {
        key: string;
        value: string;
    }[];
};

/**
 * Configuration for services request validation.
 * @ignore
 */
declare type RequestValidationConfig<Params = any> = {
    /**
     * Schema from Zod for validating input parameters.
     * This will be compiled and used for validation.
     * @see https://zod.dev/?id=basic-usage
     */
    schema: ZodMiniObject;
    /**
     * Optional refinements from Zod for schema.refine advanced calls.
     * @see ZodObject.refine
     */
    refinements?: SchemaRefinement<Params>[];
};

/**
 * Convert geographic coordinates into human-readable addresses (reverse geocoding).
 *
 * Reverse geocoding translates latitude/longitude coordinates into street addresses,
 * which is essential for location-based applications that need to display addresses
 * from GPS coordinates or map clicks.
 *
 * @remarks
 * Common use cases:
 * - **Tracking applications**: Convert GPS coordinates from devices into addresses
 * - **Map interactions**: Display address when user clicks on map
 * - **Location sharing**: Show readable location instead of coordinates
 * - **Delivery apps**: Confirm pickup/dropoff addresses from driver location
 * - **Asset tracking**: Display current location of vehicles or equipment
 *
 * Features:
 * - Returns complete address hierarchy (street, city, state, country)
 * - Supports cross-street results
 * - Includes side of street information
 * - Provides address ranges for streets
 * - Returns multiple result types (street, POI, geography)
 *
 * @param params - Reverse geocoding parameters including coordinates
 * @param customTemplate - Advanced customization for request/response handling
 *
 * @returns Promise resolving to the address for the given coordinates
 *
 * @example
 * ```typescript
 * // Get address for coordinates
 * const address = await reverseGeocode({
 *   key: 'your-api-key',
 *   position: [4.9041, 52.3676]  // Amsterdam coordinates
 * });
 * // Returns: Dam, 1012 Amsterdam, Netherlands
 *
 * // Get address with specific street number
 * const specificAddress = await reverseGeocode({
 *   key: 'your-api-key',
 *   position: [-77.0369, 38.8977],  // Washington DC
 *   number: '1600'
 * });
 * // Returns: 1600 Pennsylvania Avenue NW
 *
 * // Get nearest cross street
 * const crossStreet = await reverseGeocode({
 *   key: 'your-api-key',
 *   position: [-74.0060, 40.7128],  // New York
 *   returnRoadUse: true
 * });
 * ```
 *
 * @see [Reverse Geocode API Documentation](https://docs.tomtom.com/search-api/documentation/reverse-geocoding-service/reverse-geocode)
 * @see [Places Quickstart Guide](https://docs.tomtom.com/maps-sdk-js/guides/services/places/quickstart)
 * @see [Reverse Geocoding Guide](https://docs.tomtom.com/maps-sdk-js/guides/services/places/reverse-geocoding)
 *
 * @group Reverse Geocoding
 */
export declare const reverseGeocode: (params: ReverseGeocodingParams, customTemplate?: Partial<ReverseGeocodingTemplate>) => Promise<ReverseGeocodingResponse>;

/**
 * Required parameters for reverse geocoding requests.
 *
 * @remarks
 * These parameters must be provided for any reverse geocoding service call.
 *
 * @group Reverse Geocoding
 */
export declare type ReverseGeocodingMandatoryParams = {
    /**
     * Geographic position to reverse geocode.
     *
     * @remarks
     * The longitude and latitude coordinates for which to retrieve address information.
     * Accepts any format implementing the {@link HasLngLat} interface.
     */
    position: HasLngLat;
};

/**
 * Optional parameters for customizing reverse geocoding requests.
 *
 * @remarks
 * These parameters allow fine-tuning of the reverse geocoding behavior,
 * including filtering, formatting, and additional data retrieval.
 *
 * @group Reverse Geocoding
 */
export declare type ReverseGeocodingOptionalParams = {
    /**
     * Controls newline formatting in the returned address.
     *
     * @remarks
     * When `true`, the formatted address will contain newline characters.
     * When `false` or omitted, newlines are converted to spaces.
     *
     * @defaultValue `false`
     */
    allowFreeformNewline?: boolean;
    /**
     * Filters results to specific geography entity types.
     *
     * @remarks
     * Narrows the search to specified geography types (e.g., country, state, city).
     * The response includes the geography ID, which can be used to retrieve the geometry.
     *
     * **Note:** When set, the following parameters are ignored:
     * - `heading`
     * - `number`
     * - `returnRoadUse`
     * - `returnSpeedLimit`
     * - `roadUse`
     * - `returnMatchType`
     */
    geographyType?: GeographyType[];
    /**
     * Directional heading of the vehicle in degrees.
     *
     * @remarks
     * Specifies the travel direction along a road segment to provide
     * direction-aware address information.
     *
     * - `0` = North
     * - `90` = East
     * - `180` = South
     * - `270` = West
     *
     * @example
     * ```ts
     * heading: 90.5  // Traveling east-northeast
     * ```
     *
     * @minimum -360
     * @maximum 360
     */
    heading?: number;
    /**
     * Enables mapcode inclusion in the response.
     *
     * @remarks
     * Returns a comma-separated list of mapcodes for the location.
     * Mapcodes are short codes representing specific locations within a few meters.
     * Can filter to show only selected mapcode types.
     *
     * Available types:
     * - `Local` - Territory-specific mapcode
     * - `International` - Globally valid mapcode
     * - `Alternative` - Alternative mapcode representations
     *
     * @see {@link https://www.mapcode.com | Mapcode Project}
     */
    mapcodes?: MapcodeType[];
    /**
     * Street number for enhanced address matching.
     *
     * @remarks
     * When provided, the response may include:
     * - Side of the street (Left/Right)
     * - Offset position for the street number
     *
     * @example
     * ```ts
     * number: "123"
     * ```
     */
    number?: string;
    /**
     * Search radius in meters from the specified position.
     *
     * @remarks
     * Limits the search area using the provided coordinates as the center point.
     * Must be a positive integer value.
     *
     * @minimum 1
     */
    radiusMeters?: number;
    /**
     * Includes match type information in the response.
     *
     * @remarks
     * When `true`, the response includes details about how well the
     * geocoder matched the provided coordinates to an address.
     *
     * @defaultValue `false`
     */
    returnMatchType?: boolean;
    /**
     * Includes road use classification in the response.
     *
     * @remarks
     * When `true` and reverse geocoding at street level, returns an array
     * of applicable road use types for the location.
     *
     * @defaultValue `false`
     */
    returnRoadUse?: boolean;
    /**
     * Includes speed limit information in the response.
     *
     * @remarks
     * When `true`, returns the speed limit at the given location if available.
     *
     * @defaultValue `false`
     */
    returnSpeedLimit?: boolean;
    /**
     * Restricts results to specific road use types.
     *
     * @remarks
     * Filters reverse geocoding results to only include addresses
     * on roads matching the specified use classifications.
     *
     * @example
     * ```ts
     * roadUses: ['LimitedAccess', 'Arterial']  // Only highways and major roads
     * ```
     */
    roadUses?: RoadUse[];
    /**
     * Specifies the geopolitical view for the results.
     *
     * @remarks
     * Determines how disputed territories and borders are represented in the response.
     *
     * Available views:
     * - `Unified` - International view (default)
     * - `AR` - Argentina
     * - `IN` - India
     * - `PK` - Pakistan
     * - `IL` - Israel
     * - `MA` - Morocco
     * - `RU` - Russia
     * - `TR` - Turkey
     * - `CN` - China
     *
     * @defaultValue `"Unified"`
     */
    view?: View;
};

/**
 * Complete parameter set for reverse geocoding service calls.
 *
 * @remarks
 * Combines common service parameters with reverse geocoding-specific
 * mandatory and optional parameters.
 *
 * @group Reverse Geocoding
 */
export declare type ReverseGeocodingParams = CommonServiceParams<URL, ReverseGeocodingResponseAPI> & ReverseGeocodingMandatoryParams & ReverseGeocodingOptionalParams;

/**
 * Response from the reverse geocoding service.
 *
 * Contains a place with address information for the given coordinates.
 *
 * @group Reverse Geocoding
 */
export declare type ReverseGeocodingResponse = Place<RevGeoAddressProps>;

/**
 * @ignore
 */
declare type ReverseGeocodingResponseAPI = {
    summary: {
        queryTime: number;
        numResults: number;
    };
    addresses: [
        {
        address: AddressProperties & {
            boundingBox?: {
                northEast: string;
                southWest: string;
                entity: 'position';
            };
            sideOfStreet?: SideOfStreet;
            offsetPosition?: string;
            [key: string]: any;
        };
        linkedAddress?: AddressProperties & {
            boundingBox?: {
                northEast: string;
                southWest: string;
                entity: 'position';
            };
            [key: string]: any;
        };
        dataSources?: PlaceDataSources;
        entityType?: PlaceType;
        mapcodes?: Mapcode[];
        position: string;
        roadUse?: string[];
    }
    ];
};

/**
 * Reverse Geocoding service template type.
 * @ignore
 */
declare type ReverseGeocodingTemplate = ServiceTemplate<ReverseGeocodingParams, URL, ReverseGeocodingResponseAPI, ReverseGeocodingResponse>;

/**
 * Road use classification types for filtering reverse geocoding results.
 *
 * @remarks
 * Use these values to restrict reverse geocoding results to specific road types.
 *
 * @group Reverse Geocoding
 */
export declare type RoadUse = 'LimitedAccess' | 'Arterial' | 'Terminal' | 'Ramp' | 'Rotary' | 'LocalStreet';

/**
 * @ignore
 */
declare type RouteAPI = {
    legs: LegAPI[];
    sections: SectionAPI[];
    summary: SummaryAPI_2;
    guidance?: GuidanceAPI;
    progress?: RouteProgress;
};

/**
 * @ignore
 */
declare type RoutePathPointAPI = Omit<RoutePathPoint, 'point'> & {
    point: LatitudeLongitudePointAPI;
};

/**
 * Route optimization strategy for route calculation.
 *
 * Determines what the routing engine optimizes for when calculating the route.
 * Each type produces different routes suited to different use cases.
 *
 * @remarks
 * **Route Type Strategies:**
 *
 * - **`fast`**: Minimize travel time while maintaining practicality
 *   - Prefers major roads and highways
 *   - Avoids unnecessary detours and shortcuts on minor roads
 *   - Best for most everyday use cases (commuting, business travel)
 *
 * - **`short`**: Balance between time and distance
 *   - Good compromise between speed and mileage
 *   - May use smaller roads to save distance
 *   - Useful for short trips or when fuel costs matter
 *
 * - **`efficient`**: Minimize fuel or energy consumption
 *   - Optimizes for least energy use
 *   - Considers vehicle consumption model
 *   - Avoids rapid acceleration/deceleration
 *   - Best used with vehicle consumption parameters
 *
 * - **`thrilling`**: Scenic and engaging routes
 *   - Prefers curvy, interesting roads
 *   - Minimizes motorway usage
 *   - **Limited to 900km maximum route length**
 *   - Ideal for motorcycle rides or scenic drives
 *
 * @example
 * ```typescript
 * // Fastest route for commuting
 * const routeType: RouteType = 'fast';
 *
 * // Most fuel-efficient route for long trip
 * const ecoRoute: RouteType = 'efficient';
 *
 * // Scenic route for leisure
 * const scenicRoute: RouteType = 'thrilling';
 * ```
 *
 * @group Routing
 */
export declare type RouteType = (typeof routeTypes)[number];

/**
 * Available route types, where each type specifies the type of optimization used when calculating routes:
 * * **fast**: Route calculation is optimized by travel time, while keeping the routes sensible. For example, the calculation may avoid shortcuts along inconvenient side roads or long detours that only save very little time.
 * * **short**: Route calculation is optimized such that a good compromise between small travel time and short travel distance is achieved.
 * * **efficient**: Route calculation is optimized such that a good compromise between small travel time and low fuel or energy consumption is achieved.
 * * **thrilling**: Route calculation is optimized such that routes include interesting or challenging roads and use as few motorways as possible.
 * There is a limit of 900km on routes planned with routeType=thrilling.
 *
 * @group Routing
 */
export declare const routeTypes: readonly ["fast", "short", "efficient", "thrilling"];

/**
 * @ignore
 */
declare type SchemaRefinement<T = any> = {
    check: (data: T) => boolean;
    message: string;
};

/**
 * Base error class for all SDK-related errors.
 *
 * The SDK handles two distinct categories of errors:
 * 1. **Programming errors**: Configuration or usage errors in the user's application,
 *    such as passing incorrect types to parameters or functions.
 * 2. **API errors**: Recoverable errors that occur during SDK operations,
 *    such as network failures or invalid API responses.
 *
 * @example
 * ```typescript
 * try {
 *   // SDK operation
 * } catch (error) {
 *   if (error instanceof SDKError) {
 *     console.error(`Error in ${error.service}: ${error.message}`);
 *   }
 * }
 * ```
 *
 * @group Errors
 */
export declare class SDKError extends Error {
    readonly service: string;
    readonly issues?: $ZodIssue[] | undefined;
    /**
     * Creates a new SDKError instance.
     *
     * @param message - Human-readable error description
     * @param service - Name of the service where the error occurred
     * @param issues - Optional array of Zod validation issues for detailed error information
     */
    constructor(message: string, service: string, issues?: $ZodIssue[] | undefined);
}

/**
 * Error class for HTTP API response errors.
 *
 * Extends {@link SDKError} to include HTTP status codes and automatically
 * maps known error codes to user-friendly messages using {@link APIErrorCode}.
 *
 * @example
 * ```typescript
 * throw new SDKServiceError('Invalid request', 'geocoding', 400);
 * ```
 *
 * @group Errors
 */
export declare class SDKServiceError extends SDKError {
    /**
     * HTTP status code of the failed API request.
     *
     * Common values:
     * - `400`: Bad Request
     * - `403`: Forbidden
     * - `429`: Too Many Requests
     * - `500`: Internal Server Error
     */
    status?: number;
    /**
     * Creates a new SDKServiceError instance.
     *
     * If the status code matches a known error in {@link APIErrorCode},
     * the message will be automatically replaced with the standardized message.
     *
     * @param message - Error message from the API or custom message
     * @param service - Name of the service that generated the error
     * @param status - HTTP status code of the failed request
     */
    constructor(message: string, service: string, status?: number);
}

/**
 * Universal search function for finding places by text query or within geometries.
 *
 * This is a unified interface that automatically routes to either:
 * - **Geometry Search**: When geometries parameter is provided (search within specific areas)
 * - **Fuzzy Search**: When no geometries provided (free-text search)
 *
 * @remarks
 * The search service provides:
 * - POI (Points of Interest) search
 * - Address search
 * - Geographic area search
 * - Category-based filtering
 * - Position-based relevance ranking
 *
 * Results are ranked by relevance with scores and optional distances.
 *
 * @param params - Search parameters (either GeometrySearchParams or FuzzySearchParams)
 * @param customTemplate - Advanced customization for request/response handling
 *
 * @returns Promise resolving to a collection of matching places
 *
 * @example
 * ```typescript
 * // Free-text search near a location
 * const results = await search({
 *   key: 'your-api-key',
 *   query: 'pizza restaurant',
 *   at: [4.9041, 52.3676],  // Amsterdam
 *   limit: 10
 * });
 *
 * // Search within a specific area
 * const areaResults = await search({
 *   key: 'your-api-key',
 *   query: 'coffee shop',
 *   geometries: [polygon],  // Search within this polygon
 *   limit: 20
 * });
 *
 * // Category search
 * const restaurants = await search({
 *   key: 'your-api-key',
 *   query: 'restaurant',
 *   categorySet: [7315],  // Restaurant category
 *   at: [4.9041, 52.3676],
 *   radius: 5000  // Within 5km
 * });
 * ```
 *
 * @see [Search API Documentation](https://docs.tomtom.com/search-api/documentation/search-service/search-service)
 * @see [Places Quickstart Guide](https://docs.tomtom.com/maps-sdk-js/guides/services/places/quickstart)
 * @see [Search Guide](https://docs.tomtom.com/maps-sdk-js/guides/services/places/search)
 *
 * @group Search
 */
export declare const search: (params: GeometrySearchParams | FuzzySearchParams, customTemplate?: Partial<GeometrySearchTemplate | FuzzySearchTemplate>) => Promise<SearchResponse>;

declare type SearchFeatureCollectionProps = SearchSummary & {
    queryIntent?: QueryIntent[];
};

/**
 * Union type of all supported geometry search input formats.
 *
 * Accepts standard GeoJSON polygons/multipolygons, custom circles, or polygon
 * feature collections (such as those returned from previous searches or the
 * geometry data service).
 *
 * @remarks
 * **Flexibility:**
 * - Mix different geometry types in a single search
 * - Use results from {@link geometryData} directly
 * - Pass search results with geometries as boundaries
 * - Define custom polygons for precise area searches
 *
 * @example
 * ```typescript
 * // Using different geometry types
 * const geometries: SearchGeometryInput[] = [
 *   // Circle
 *   { type: 'Circle', coordinates: [4.9, 52.3], radius: 1000 },
 *
 *   // Polygon
 *   {
 *     type: 'Polygon',
 *     coordinates: [[
 *       [4.88, 52.36], [4.90, 52.36], [4.90, 52.38], [4.88, 52.38], [4.88, 52.36]
 *     ]]
 *   },
 *
 *   // From previous geometry data call
 *   cityBoundaries  // PolygonFeatures
 * ];
 * ```
 *
 * @group Search
 */
export declare type SearchGeometryInput = Polygon | MultiPolygon | Circle | PolygonFeatures_2;

/**
 * Index representing the type of place data to search.
 *
 * Specifies which category of place data to include in search results.
 * Different index types return different kinds of location information.
 *
 * @remarks
 * **Index Types:**
 * - `Geo`: Geographic entities (countries, states, cities, neighborhoods)
 * - `PAD`: Point Address - Specific street addresses with building numbers
 * - `Addr`: Address Range - Street segments with address ranges
 * - `Str`: Street names without specific addresses
 * - `XStr`: Cross Streets - Intersections of two streets
 * - `POI`: Points of Interest (businesses, landmarks, facilities)
 *
 * **Use with `extendedPostalCodesFor`:**
 * By default, extended postal codes are included for all indexes except `Geo`.
 * Use this type to explicitly request extended postal codes for specific indexes.
 *
 * @example
 * ```typescript
 * // Request extended postal codes for addresses and POIs
 * const indexes: SearchIndexType[] = ['PAD', 'Addr', 'POI'];
 * ```
 *
 * @group Search
 */
export declare type SearchIndexType = 'Geo' | 'PAD' | 'Addr' | 'Str' | 'XStr' | 'POI';

/**
 * Search service response containing places that match the query.
 *
 * Collection of place features with search-specific properties like relevance scores and distances.
 *
 * @group Search
 */
export declare type SearchResponse = Places_2<SearchPlaceProps_2, SearchFeatureCollectionProps>;

/**
 * Metadata summary for search API responses.
 *
 * Provides information about the search query execution, result counts,
 * and pagination details. This metadata helps understand how the search
 * was processed and manage result navigation.
 *
 * @remarks
 * This summary is included in responses from:
 * - {@link search}
 * - {@link fuzzySearch}
 * - {@link geometrySearch}
 * - {@link autocompleteSearch}
 *
 * @example
 * ```typescript
 * const results = await search({
 *   key: 'your-api-key',
 *   query: 'pizza',
 *   at: [4.9, 52.3]
 * });
 *
 * const summary = results.summary;
 * console.log(`Found ${summary.totalResults} total results`);
 * console.log(`Showing ${summary.numResults} results`);
 * console.log(`Query type: ${summary.queryType}`); // 'NEARBY'
 * console.log(`Search took ${summary.queryTime}ms`);
 * ```
 *
 * @group Search
 */
export declare type SearchSummary = {
    /**
     * The search query as interpreted and processed by the search engine.
     *
     * May differ from the original input due to:
     * - Normalization (case, spacing, diacritics)
     * - Spelling corrections
     * - Query expansion
     * - Stop word removal
     *
     * @example
     * ```typescript
     * // User input: "pizzza restaurant"
     * query: "pizza restaurant"  // Corrected spelling
     * ```
     */
    query: string;
    /**
     * Classification of the search type.
     *
     * Indicates whether results are location-biased (NEARBY) or general (NON_NEAR).
     */
    queryType: SummaryQueryType;
    /**
     * Query processing time in milliseconds.
     *
     * Time spent by the search engine to process and return results.
     * Does not include network latency.
     *
     * @example
     * ```typescript
     * queryTime: 42  // Search took 42ms to execute
     * ```
     */
    queryTime: number;
    /**
     * Number of results included in this response.
     *
     * This is the actual count of features in the results array,
     * which may be less than `totalResults` due to pagination limits.
     *
     * @remarks
     * Controlled by the `limit` parameter in the search request.
     *
     * @example
     * ```typescript
     * // If limit=10 and totalResults=50
     * numResults: 10  // Only 10 results in this response
     * totalResults: 50  // 50 total matches exist
     * ```
     */
    numResults: number;
    /**
     * Starting position of these results within the complete result set.
     *
     * Zero-based index indicating where this page of results begins.
     * Used for pagination to retrieve subsequent pages.
     *
     * @remarks
     * Set using the `offset` parameter in the search request.
     *
     * @example
     * ```typescript
     * // First page (results 0-9)
     * offset: 0, numResults: 10
     *
     * // Second page (results 10-19)
     * offset: 10, numResults: 10
     *
     * // Third page (results 20-29)
     * offset: 20, numResults: 10
     * ```
     */
    offset: number;
    /**
     * Total number of matching results found by the search.
     *
     * The complete count of all results that match the query,
     * regardless of pagination limits.
     *
     * @remarks
     * Use this with `offset` and `numResults` to implement pagination:
     * - Current page: `offset / limit + 1`
     * - Total pages: `Math.ceil(totalResults / limit)`
     * - Has more results: `offset + numResults < totalResults`
     *
     * @example
     * ```typescript
     * totalResults: 50  // 50 total matches found
     * numResults: 10    // Showing first 10
     * offset: 0         // Starting from beginning
     *
     * // Can fetch more with offset: 10, 20, 30, 40
     * ```
     */
    totalResults: number;
    /**
     * Maximum fuzzy matching level used to find results.
     *
     * Indicates how much the search relaxed exact matching to find results.
     * Higher values mean more tolerance for typos and variations.
     *
     * @remarks
     * Fuzzy levels (typically 1-4):
     * - 1: Single character variation (typo, insertion, deletion)
     * - 2: Two character variations
     * - 3: Three character variations
     * - 4: Four character variations
     *
     * If results are found with exact or near-exact matching, this will be low.
     * If the query has typos, this increases to find matches.
     *
     * @example
     * ```typescript
     * // Query: "amstrdam" (typo)
     * fuzzyLevel: 2  // Needed 2-character correction to match "amsterdam"
     *
     * // Query: "amsterdam" (correct)
     * fuzzyLevel: 0  // Exact match, no fuzzy matching needed
     * ```
     */
    fuzzyLevel: number;
    /**
     * Geographic position used to bias search results.
     *
     * When present, indicates that results were prioritized based on
     * proximity to this location. Format: [longitude, latitude]
     *
     * @remarks
     * This reflects the position from:
     * - The `at` parameter (explicit position bias)
     * - The `in` parameter (area center, if applicable)
     * - Automatic geolocation (if enabled)
     *
     * Results closer to this position are ranked higher.
     *
     * @example
     * ```typescript
     * // Search biased toward Amsterdam
     * geoBias: [4.9041, 52.3676]  // [longitude, latitude]
     *
     * // Query: "Main Street" will prioritize Main Streets near Amsterdam
     * ```
     */
    geoBias?: Position;
};

/**
 * @ignore
 */
declare type SectionAPI = {
    sectionType: SectionTypeAPI;
    startPointIndex: number;
    endPointIndex: number;
    travelMode?: TravelMode | 'other';
    countryCode?: string;
    simpleCategory?: TrafficCategoryAPI;
    magnitudeOfDelay?: number;
    effectiveSpeedInKmh?: number;
    delayInSeconds?: number;
    tec?: TrafficIncidentTEC;
    lanes?: LaneDirection[];
    laneSeparators?: PossibleLaneSeparator[];
    properties?: string[];
    maxSpeedLimitInKmh?: number;
    roadShieldReferences?: RoadShieldReference[];
    importantRoadStretchIndex?: number;
    streetName?: {
        text: string;
    };
    roadNumbers?: {
        text: string;
    }[];
};

/**
 * @ignore
 */
declare type SectionTypeAPI = 'CAR_TRAIN' | 'COUNTRY' | 'FERRY' | 'MOTORWAY' | 'PEDESTRIAN' | 'TOLL' | 'TOLL_VIGNETTE' | 'TRAFFIC' | 'TRAVEL_MODE' | 'TUNNEL' | 'UNPAVED' | 'URBAN' | 'CARPOOL' | 'LOW_EMISSION_ZONE' | 'LANES' | 'SPEED_LIMIT' | 'ROAD_SHIELDS' | 'IMPORTANT_ROAD_STRETCH';

/**
 * Name of a service managed by the SDK.
 */
export declare type ServiceName = string;

/**
 * Template interface defining the lifecycle methods for any service implementation.
 *
 * @remarks
 * This type provides a standardized structure for implementing service calls,
 * including request building, validation, sending, response parsing, and error handling.
 *
 * @typeParam Params - Service-specific parameters extending {@link CommonServiceParams}
 * @typeParam ApiRequest - The type of the API request object
 * @typeParam ApiResponse - The type of the raw API response object
 * @typeParam Response - The type of the parsed response returned to the caller
 *
 * @group Shared
 */
export declare type ServiceTemplate<Params extends CommonServiceParams<ApiRequest, ApiResponse>, ApiRequest, ApiResponse, Response> = {
    /**
     * Configuration for validating request parameters.
     *
     * @remarks
     * Defines the validation schema and rules applied to request parameters
     * before the request is built and sent.
     */
    requestValidation?: RequestValidationConfig<Params>;
    /**
     * Builds the API request from the provided parameters.
     *
     * @param params - The service call parameters
     * @returns The constructed API request object
     */
    buildRequest: (params: Params) => ApiRequest;
    /**
     * Determines the API version to use for the service call.
     *
     * @remarks
     * Useful for services that require a specific API version different from the global configuration.
     * If not provided, the API version from the global or provided configuration will be used.
     *
     * @param params - Input parameters that may influence the API version selection
     * @returns The API version number
     */
    getAPIVersion?: (params?: Params) => number;
    /**
     * Sends the constructed request to the API server.
     *
     * @remarks
     * Handles the actual HTTP communication (e.g., GET or POST) with optional custom headers.
     *
     * @param request - The request object to send
     * @param headers - Custom TomTom headers to include in the request
     * @returns A promise resolving to the parsed fetch response
     */
    sendRequest: (request: ApiRequest, headers: TomTomHeaders) => ParsedFetchResponse<ApiResponse>;
    /**
     * Parses the successful API response into the expected return type.
     *
     * @remarks
     * Transforms the raw API response into a structured format suitable for the caller.
     *
     * @param apiResponse - The raw API response received from the server
     * @param params - The original service call parameters
     * @returns The parsed response object
     */
    parseResponse: (apiResponse: ApiResponse, params: Params) => Response;
    /**
     * Parses an API error response before propagating it to the caller.
     *
     * @remarks
     * Allows custom error handling and transformation of API errors into SDK-specific error types.
     */
    parseResponseError?: ParseResponseError<any>;
};

/**
 * Specifies the speed-dependent component of consumption.
 * Provided as an unordered list of speed/consumption-rate pairs.
 * The list defines points on a consumption curve.
 *
 * Consumption rates for speeds not in the list are found as follows:
 * By linear interpolation if the given speed lies in between two speeds in the list.
 * By linear extrapolation otherwise, assuming a constant (&ΔConsumption/&ΔSpeed) determined by the nearest two points in the list.
 *
 * The list must contain between 1 and 25 points (inclusive), and may not contain duplicate points for the same speed.
 * If it only contains a single point, then the consumption rate of that point is used without further processing.
 * Consumption specified for the largest speed must be greater than or equal to that of the penultimate largest speed. This ensures that extrapolation does not lead to negative consumption rates.
 * Similarly, consumption values specified for the two smallest speeds in the list cannot lead to a negative consumption rate for any smaller speed. The minimum and maximum values described here refer to the valid range for the consumption values (expressed in kWh/100km).
 *
 * Minimum value: 01
 * Maximum value: 100000.0
 */
declare type SpeedToConsumptionRate = {
    speedKMH: number;
    consumptionUnitsPer100KM: number;
};

/**
 * @ignore
 */
declare type SummaryAPI = Omit<SearchSummary, 'geoBias'> & {
    geoBias?: LatLonAPI;
};

/**
 * @ignore
 */
declare type SummaryAPI_2 = Omit<RouteSummary & LegSummary, 'arrivalTime' | 'departureTime' | 'batteryConsumptionInPCT' | 'remainingChargeAtArrivalInPCT' | 'chargingInformationAtEndOfLeg' | 'deviationPoint'> & {
    arrivalTime: string;
    departureTime: string;
    chargingInformationAtEndOfLeg?: ChargingStopAPI;
    deviationDistance?: number;
    deviationTime?: number;
    deviationPoint?: LatitudeLongitudePointAPI;
};

/**
 * Query type classification for search results.
 *
 * Indicates whether the search was location-based or general.
 *
 * @remarks
 * - `NEARBY`: Results are based on proximity to a specified location (uses `at` parameter)
 * - `NON_NEAR`: General search without location bias, or results span a wide area
 *
 * @group Search
 */
declare type SummaryQueryType = 'NEARBY' | 'NON_NEAR';

/**
 * @ignore
 */
declare type TimeRangeAPI = {
    startTime: MomentAPI;
    endTime: MomentAPI;
};

/**
 * Timezone data format for POI responses.
 *
 * Specifies which timezone identifier format to include in search results.
 *
 * @remarks
 * **Format:**
 * - `iana`: IANA Time Zone Database identifier (e.g., "Europe/Amsterdam", "America/New_York")
 *
 * **Use Cases:**
 * - Display local time at POI location
 * - Schedule appointments considering timezone
 * - Calculate opening hours in local time
 * - International coordination
 *
 * @see [IANA Time Zone Database](https://www.iana.org/time-zones)
 *
 * @example
 * ```typescript
 * const format: TimeZoneRequest = 'iana';
 * // Response includes: { ianaId: "Europe/Amsterdam" }
 * ```
 *
 * @group Search
 */
export declare type TimeZoneRequest = 'iana';

/**
 * @ignore
 */
declare type TrafficCategoryAPI = 'JAM' | 'ROAD_WORK' | 'ROAD_CLOSURE' | 'OTHER';

/**
 * Traffic consideration mode for route calculation.
 *
 * Controls how traffic conditions are factored into routing and travel time estimates.
 *
 * @remarks
 * **Traffic Modes:**
 *
 * - **`live`**: Real-time + historical traffic
 *   - Includes current traffic jams and incidents
 *   - Considers short-term and long-term road closures
 *   - Most accurate for immediate departures
 *   - Updates with current conditions
 *
 * - **`historical`**: Typical traffic patterns only
 *   - Based on historical data for time of day/week
 *   - Ignores current traffic conditions
 *   - Good for future trip planning
 *   - More predictable for scheduled departures
 *
 * @example
 * ```typescript
 * // Route considering current traffic (departing now)
 * const trafficMode: TrafficInput = 'live';
 *
 * // Route based on typical patterns (planning ahead)
 * const plannedRoute: TrafficInput = 'historical';
 * ```
 *
 * @group Routing
 */
export declare type TrafficInput = 'live' | 'historical';

/**
 * Validate Error Class for validating params input, this will be used by SDKError class.
 * @group Shared
 * @ignore
 */
declare class ValidationError extends Error {
    issues: $ZodIssue[];
    constructor(zodError: $ZodError);
}

/**
 * Physical properties of the vehicle (sizes and weights).
 *
 * @remarks
 * Dimensions are used to:
 * - Check road restrictions (height, width, weight limits)
 * - Avoid unsuitable routes (narrow streets, low bridges)
 * - Calculate toll costs (weight-based pricing)
 * - Determine parking availability
 *
 * **Important for:**
 * - Commercial vehicles (trucks, vans)
 * - Recreational vehicles (RVs, caravans)
 * - Oversized vehicles
 *
 * @example
 * ```typescript
 * // Standard delivery van
 * const vanDimensions: VehicleDimensions = {
 *   lengthMeters: 5.5,
 *   widthMeters: 2.0,
 *   heightMeters: 2.5,
 *   weightKG: 3500
 * };
 *
 * // Large truck
 * const truckDimensions: VehicleDimensions = {
 *   lengthMeters: 16.5,
 *   widthMeters: 2.55,
 *   heightMeters: 4.0,
 *   weightKG: 40000,
 *   axleWeightKG: 10000
 * };
 * ```
 *
 * @group Vehicle
 */
declare type VehicleDimensions = {
    /**
     * Length of the vehicle in meters.
     *
     * @remarks
     * A value of 0 means that length restrictions are not considered.
     *
     * **Typical Values:**
     * - Small car: 3-4 m
     * - SUV/Van: 4-6 m
     * - Small truck: 6-10 m
     * - Large truck: 12-18 m
     *
     * @default 0
     *
     * @example
     * ```typescript
     * lengthMeters: 5.5   // Delivery van
     * lengthMeters: 16.5  // Articulated truck
     * ```
     */
    lengthMeters?: number;
    /**
     * Width of the vehicle in meters.
     *
     * @remarks
     * A value of 0 means that width restrictions are not considered.
     *
     * **Typical Values:**
     * - Standard car: 1.7-1.9 m
     * - Van/truck: 2.0-2.5 m
     * - Maximum legal (Europe/US): 2.55 m
     *
     * @default 0
     *
     * @example
     * ```typescript
     * widthMeters: 1.8   // Standard car
     * widthMeters: 2.5   // Wide truck
     * ```
     */
    widthMeters?: number;
    /**
     * Height of the vehicle in meters.
     *
     * @remarks
     * A value of 0 means that height restrictions are not considered.
     *
     * **Typical Values:**
     * - Sedan: 1.4-1.5 m
     * - SUV: 1.7-1.9 m
     * - Van: 2.0-2.8 m
     * - Truck: 3.5-4.5 m
     *
     * **Important:** Critical for avoiding low bridges and tunnels.
     *
     * @default 0
     *
     * @example
     * ```typescript
     * heightMeters: 1.5  // Sedan
     * heightMeters: 4.0  // Container truck
     * ```
     */
    heightMeters?: number;
    /**
     * Weight of the vehicle in kilograms.
     *
     * @remarks
     * If a detailed Consumption model is specified, refer to the Consumption model
     * parameters section for the documentation of vehicleWeight.
     *
     * If a detailed Consumption model is not specified, and the value of vehicleWeight
     * is non-zero, then weight restrictions are considered.
     *
     * In all other cases, this parameter is ignored.
     *
     * **Typical Values:**
     * - Small car: 1,000-1,500 kg
     * - SUV: 1,800-2,500 kg
     * - Van: 2,000-3,500 kg
     * - Truck (empty): 7,500-12,000 kg
     * - Truck (loaded): 20,000-40,000 kg
     *
     * @default 0
     *
     * @example
     * ```typescript
     * weightKG: 1500   // Compact car
     * weightKG: 3500   // Loaded van
     * weightKG: 40000  // Fully loaded truck
     * ```
     */
    weightKG?: number;
    /**
     * Weight per axle of the vehicle in kilograms.
     *
     * @remarks
     * A value of 0 means that weight restrictions per axle are not considered.
     *
     * **Use Cases:**
     * - Older bridges with axle weight limits
     * - Specialized roads with axle restrictions
     * - Heavy load transport
     *
     * **Typical Values:**
     * - Single axle: 6,000-10,000 kg
     * - Tandem axle: 8,000-11,500 kg (per axle)
     *
     * @default 0
     *
     * @example
     * ```typescript
     * axleWeightKG: 10000  // Heavy truck
     * ```
     */
    axleWeightKG?: number;
};

/**
 * The consumption model describes vehicle energy (fuel/electricity) consumption attributes.
 * * "combustion" vehicles can contain a combustion consumption model
 * * "electric" vehicles (EVs) can contain an EV consumption model
 */
declare type VehicleEngineModel<E extends VehicleEngineType> = E extends 'combustion' ? CombustionEngineModel : E extends 'electric' ? ElectricEngineModel : never;

/**
 * The engine type of the vehicle.
 * * When a detailed Consumption model is specified, it must be consistent with the provided engine type.
 */
declare type VehicleEngineType = (typeof engineTypes)[number] | undefined;

/**
 * Vehicle model definition - either predefined or explicitly specified.
 *
 * @remarks
 * Represents the static properties of a vehicle (model characteristics that
 * don't change during a journey).
 *
 * **Two Options:**
 * 1. **Predefined**: Use a vehicle from TomTom's database (recommended)
 * 2. **Explicit**: Manually specify dimensions and engine characteristics
 *
 * @typeParam E - The engine type (combustion, electric, or undefined for generic)
 *
 * @example
 * ```typescript
 * // Option 1: Predefined model
 * const model: VehicleModel = {
 *   variantId: 'tesla-model-3-long-range-2023'
 * };
 *
 * // Option 2: Explicit model
 * const customModel: VehicleModel = {
 *   dimensions: {
 *     heightMeters: 4.0,
 *     weightKG: 25000
 *   }
 * };
 * ```
 *
 * @group Vehicle
 */
declare type VehicleModel<E extends VehicleEngineType = undefined> = PredefinedVehicleModel | ExplicitVehicleModel<E>;

/**
 * Object describing vehicle details for routing.
 *
 * @remarks
 * Combines all vehicle-related parameters including:
 * - **Model**: Static properties (dimensions, engine specs)
 * - **State**: Current conditions (fuel/charge level, heading)
 * - **Preferences**: Routing preferences (charging stops, etc.)
 * - **Restrictions**: Cargo and usage restrictions
 *
 * **Three Types:**
 * 1. **Generic**: Basic vehicle without engine-specific features
 * 2. **Combustion**: Fuel-powered with consumption modeling
 * 3. **Electric**: Battery-powered with charging stop optimization
 *
 * **When to Specify:**
 * - Size restrictions matter (trucks, vans)
 * - Accurate range prediction needed
 * - EV routing with charging stops
 * - Hazardous material transport
 * - Commercial vehicle routing
 *
 * @example
 * ```typescript
 * // Generic vehicle with just dimensions
 * const van: VehicleParameters = {
 *   model: {
 *     dimensions: {
 *       heightMeters: 2.5,
 *       weightKG: 3500
 *     }
 *   },
 *   restrictions: {
 *     commercial: true
 *   }
 * };
 *
 * // Combustion vehicle with fuel tracking
 * const fuelCar: VehicleParameters = {
 *   engineType: 'combustion',
 *   model: {
 *     dimensions: { weightKG: 1500 }
 *   },
 *   state: {
 *     currentFuelInLiters: 45
 *   }
 * };
 *
 * // Electric vehicle with charging
 * const ev: VehicleParameters = {
 *   engineType: 'electric',
 *   model: {
 *     engine: {
 *       consumption: {
 *         charging: {
 *           maxChargeKWH: 75,
 *           connectorTypes: ['IEC_62196_TYPE_2']
 *         }
 *       }
 *     }
 *   },
 *   state: {
 *     currentChargePCT: 80
 *   },
 *   preferences: {
 *     chargingPreferences: {
 *       minChargeAtDestinationPCT: 20,
 *       minChargeAtChargingStopsPCT: 10
 *     }
 *   }
 * };
 *
 * // Hazmat truck
 * const hazmatTruck: VehicleParameters = {
 *   model: {
 *     dimensions: {
 *       heightMeters: 4.0,
 *       weightKG: 40000
 *     }
 *   },
 *   restrictions: {
 *     loadTypes: ['USHazmatClass3'],
 *     commercial: true,
 *     maxSpeedKMH: 80
 *   }
 * };
 * ```
 *
 * @group Vehicle
 */
export declare type VehicleParameters = (GenericVehicleParams | CombustionVehicleParams | ElectricVehicleParams) & VehicleRestrictions;

/**
 * Vehicle preferences - optional routing preferences based on engine type.
 *
 * @remarks
 * Currently only electric vehicles have specific preferences (charging stops).
 * Future versions may add preferences for combustion vehicles.
 *
 * @typeParam E - The engine type (combustion, electric, or undefined for generic)
 *
 * @example
 * ```typescript
 * // Electric vehicle with charging preferences
 * const evPrefs: VehiclePreferences<'electric'> = {
 *   chargingPreferences: {
 *     minChargeAtDestinationPCT: 20,
 *     minChargeAtChargingStopsPCT: 10
 *   }
 * };
 *
 * // Combustion or generic vehicle (no preferences)
 * const genericPrefs: VehiclePreferences = {};
 * ```
 *
 * @group Vehicle
 */
export declare type VehiclePreferences<E extends VehicleEngineType = undefined> = E extends 'electric' ? ElectricVehiclePreferences : {};

/**
 * Parameters for a vehicle which are related to restrictions (e.g. related to the cargo and purpose of the vehicle).
 */
declare type VehicleRestrictions = {
    /**
     * Vehicle restrictions including load types, speed limits, ADR codes, and commercial usage.
     */
    restrictions?: {
        /**
         * Specifies types of cargo that may be classified as hazardous materials and are restricted from some roads.
         */
        loadTypes?: LoadType[];
        /**
         * Maximum speed of the vehicle in kilometers/hour.
         * * Must have a value in the range [0, 250].
         * * A value of 0 means that an appropriate value for the vehicle will be determined and applied during route planning.
         *
         * @default 0
         */
        maxSpeedKMH?: number;
        /**
         * Subjects the vehicle to ADR tunnel restrictions.
         * * Vehicles with code B are restricted from roads with ADR tunnel categories B, C, D, and E.
         * * Vehicles with code C are restricted from roads with ADR tunnel categories C, D, and E.
         * * Vehicles with code D are restricted from roads with ADR tunnel categories D and E.
         * * Vehicles with code E are restricted from roads with ADR tunnel category E.
         *
         * Notes:
         * If travelMode is pedestrian or bicycle, adrCode is not considered.
         * The adrCode and loadType parameters are independent; please provide both if applicable.
         * @see https://unece.org/about-adr
         */
        adrCode?: 'B' | 'C' | 'D' | 'E';
        /**
         *
         * The vehicle is used for commercial purposes (big letters on the side) and thus may not be allowed to drive on some roads.
         * This restriction is applicable only in some countries (e.g. US).
         *
         * @default false
         */
        commercial?: boolean;
    };
};

/**
 * Vehicle state - current conditions that change during travel.
 *
 * @remarks
 * Represents dynamic properties that vary during a journey:
 * - Fuel or battery level
 * - Current heading/direction
 *
 * Unlike the vehicle model (static properties), state changes as the
 * vehicle travels and consumes fuel/energy.
 *
 * @typeParam E - The engine type (combustion, electric, or undefined for generic)
 *
 * @example
 * ```typescript
 * // Generic vehicle with heading
 * const genericState: VehicleState = {
 *   heading: 90  // Facing east
 * };
 *
 * // Combustion vehicle with fuel
 * const combustionState: VehicleState<'combustion'> = {
 *   currentFuelInLiters: 45,
 *   heading: 180
 * };
 *
 * // Electric vehicle with battery percentage
 * const evState: VehicleState<'electric'> = {
 *   currentChargePCT: 75,
 *   heading: 0
 * };
 *
 * // Electric vehicle with absolute energy
 * const evKwhState: VehicleState<'electric'> = {
 *   currentChargeInkWh: 60,
 *   heading: 45
 * };
 * ```
 *
 * @group Vehicle
 */
export declare type VehicleState<E extends VehicleEngineType = undefined> = GenericVehicleState & (E extends 'combustion' ? CombustionVehicleState : E extends 'electric' ? ElectricVehicleState : {});

/**
 * @ignore
 */
declare type ViewportAPI = {
    /**
     * Top-left corner of the rectangle
     */
    topLeftPoint: LatLonAPI;
    /**
     * Bottom-right corner of the rectangle
     */
    btmRightPoint: LatLonAPI;
};

/**
 * Intent indicating the query contains a what3words address.
 *
 * Detected when the query matches the what3words format
 * (e.g., "///classic.calls.replace").
 *
 * @group Fuzzy Search
 */
export declare type W3WIntent = {
    /**
     * Query type identifier.
     *
     * The query contains a (likely) what3words code.
     */
    type: 'W3W';
    /**
     * Details about the detected what3words address.
     */
    details: W3WIntentDetails;
};

/**
 * Details for a what3words query intent.
 *
 * Contains the detected what3words address that can be converted to coordinates.
 *
 * @group Fuzzy Search
 */
export declare type W3WIntentDetails = {
    /**
     * The detected what3words address.
     *
     * For example, for the query "classic.calls.replace", the address is
     * "///classic.calls.replace". Use the what3words service to convert
     * this address to coordinates.
     */
    address: string;
};

export { }
